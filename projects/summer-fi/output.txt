const {getExports} = require('../helper/heroku-api')
const chains = ['ethereum']

module.exports = {
    timetravel: false,
    ...getExports("summer-fi", chains)
}
const {
  getCdpData,
  getCdpManagerData,
  getIlkRegistryData,
  getDecimalsData,
} = require("../helpers");

const makerTvl = async ({ api, cdpIdList, confirmedSummerFiMakerVaults }) => {
  const confirmedSummerFiMakerVaultsArray = [
    ...Object.keys(confirmedSummerFiMakerVaults),
  ];
  const confirmedSummerFiMakerVaultsSet = new Set(
    confirmedSummerFiMakerVaultsArray
  );
  ([...cdpIdList]).forEach((cdpId) => {
    confirmedSummerFiMakerVaultsSet.delete(cdpId);
  });

  const filteredVaultsList = [...confirmedSummerFiMakerVaultsSet].filter(
    (i) => {
      const [startBlock] = confirmedSummerFiMakerVaults[i];
      return api.block > startBlock;
    }
  );
  const cdpIds = [...new Set(filteredVaultsList)]
  const ilkNames = await getCdpManagerData(cdpIds, api);
  const cdpIlkIds = {}
  ilkNames.forEach((val, idx) => cdpIlkIds[cdpIds[idx]] = val)
  const ilkIds = [...new Set(ilkNames)];
  const tokens = (await getIlkRegistryData(ilkIds, api)).map((i) => i[4]);
  const decimals = await getDecimalsData(tokens, api);
  const collData = await getCdpData(filteredVaultsList.map(i => [i, cdpIlkIds[i]]), api);
  collData.forEach(({ collateralLocked }, i) => {
    const idx = ilkIds.indexOf(ilkNames[i]);
    if (idx === -1) {
      return;
    }
    api.add(tokens[idx], collateralLocked / 10 ** (18 - decimals[idx]));
  });
};

module.exports = {
  makerTvl,
};
const ADDRESSES = require('../../helper/coreAssets.json')
const BigNumber = require("bignumber.js");
const { blockQuery } = require("../../helper/http");
const { endpoints } = require("../constants/endpoints");

const NEGATIVE_WAD_PRECISION = -18;
const WETH_ADDRESS = ADDRESSES.ethereum.WETH;

const aaveQuery = (block) => `
query {
  positions(first: 10000, where: {
    and: [
      { collateral_gt: 0 },
      { or: [{ protocol: "AAVE" }, { protocol: "AAVE_V3" }] }
    ]
  }, block: { number: ${block} }) {
    collateral
    collateralAddress
  }
}`;

const ajnaQuery = (block) => `
query {
  accounts(first: 10000, where: {
    and: [
      { isDPM: true },
      { protocol: "Ajna" },
    ]
  }, block: { number: ${block} }) {
    collateralToken
    borrowPositions {
      collateral
    }
    pool {
      address
    }
  }
  pools(block: { number: ${block} }) {
    address
    depositSize
    debt
    quoteTokenAddress
  }
}`;

const dpmPositions = async ({ api, }) => {
  const aave = await blockQuery(endpoints.aave(), aaveQuery(api.block - 500), { api,  });
  // const ajna = await blockQuery(endpoints.ajna(), ajnaQuery(api.block - 500), { api, });

  const supportedAjnaPools = [
    // ...new Set(ajna.accounts.map(({ pool: { address } }) => address)),
  ];

  const aaveBorrowishPositions = aave.positions.map(
    ({ collateral, collateralAddress }) => ({
      collateral: new BigNumber(collateral),
      collateralAddress,
    })
  );
  /* const ajnaBorrowishPositions = ajna.accounts
    .filter(({ borrowPositions }) => borrowPositions.length)
    .map(({ borrowPositions: [{ collateral }], collateralToken }) => ({
      collateral: new BigNumber(collateral).shiftedBy(NEGATIVE_WAD_PRECISION),
      collateralAddress: collateralToken,
    }));
  const ajnaEarnPositions = ajna.pools
    .filter(({ address }) => supportedAjnaPools.includes(address))
    .map(({ debt, depositSize, quoteTokenAddress }) => ({
      collateral: new BigNumber(depositSize)
        .minus(new BigNumber(debt))
        .shiftedBy(NEGATIVE_WAD_PRECISION),
      collateralAddress: quoteTokenAddress,
    }));
 */
  const tokensWithAmounts = [
    ...aaveBorrowishPositions,
    // ...ajnaBorrowishPositions,
    // ...ajnaEarnPositions,
  ].reduce(
    (total, { collateral, collateralAddress }) => ({
      ...total,
      [collateralAddress]: total[collateralAddress]
        ? total[collateralAddress].plus(collateral)
        : collateral,
    }),
    {}
  );

  const fallbackDecimal = await api.call({
    abi: "erc20:decimals",
    target: WETH_ADDRESS,
  });
  const decimals = await api.multiCall({
    abi: "erc20:decimals",
    calls: Object.keys(tokensWithAmounts),
  });

  Object.keys(tokensWithAmounts).forEach((collateralAddress, i) => {
    api.add(
      collateralAddress,
      tokensWithAmounts[collateralAddress].toNumber() *
        10 ** (decimals[i] || fallbackDecimal)
    );
  });
};

module.exports = {
  dpmPositions,
};
const {
  getCdpData,
  getCdpManagerData,
  getIlkRegistryData,
  getDecimalsData,
} = require("../helpers");

const automationTvl = async ({ api, cdpIdList }) => {
  let positionsWithTriggersAndCollateral = 0;

  const cdpIds = [...cdpIdList];
  const ilkNames = await getCdpManagerData(cdpIds, api);
  const cdpIlkIds = {}
  ilkNames.forEach((val, idx) => cdpIlkIds[cdpIds[idx]] = val)
  const ilkIds = [...new Set(ilkNames)];
  const tokens = (await getIlkRegistryData(ilkIds, api)).map((i) => i[4]);
  const decimals = await getDecimalsData(tokens, api);
  const collData = await getCdpData(cdpIds.map(i => [i, cdpIlkIds[i]]), api);
  collData.forEach(({ collateralLocked }, i) => {
    if (collateralLocked > 0) {
      positionsWithTriggersAndCollateral++;
    }
    const idx = ilkIds.indexOf(ilkNames[i]);
    api.add(tokens[idx], collateralLocked / 10 ** (18 - decimals[idx]));
  });
};

module.exports = {
  automationTvl,
};
const { automationTvl } = require("./automation-v1");
const { dpmPositions } = require("./dpm-positions");
const { makerTvl } = require("./maker-vaults");

module.exports = {
  automationTvl,
  dpmPositions,
  makerTvl,
};
const { automationTvl } = require("./handlers");
const { getAutomationCdpIdList, setCallCache } = require("./helpers");
const sdk = require("@defillama/sdk");
const { getCache, setCache } = require("../helper/cache");

module.exports = {
  doublecounted: true,
  methodology: "Summer.fi PRO TVL is calculated by fetching on-chain data, retrieving CDP IDs, and using them to determine locked assets via the automationTvl function, excluding frontend-managed Maker vaults",
  ethereum: { tvl },
};

async function tvl(api) {
  await api.getBlock();
  const executionStart = Date.now() / 1000;
  const [cdpIdList, cache] = await Promise.all([
    getAutomationCdpIdList({ api }),
    getCache("summer-fi/cache", api.chain),
  ]);

  setCallCache(cache);

  sdk.log([...cdpIdList].length, "cdpIdList");

  await Promise.all([
    automationTvl({ api, cdpIdList }),
  ]);

  await setCache("summer-fi/cache", api.chain, cache);
  sdk.log("Execution time", Date.now() / 1000 - executionStart, "seconds");
}
const { getLogs } = require("../../helper/cache/getLogs");

const { abi, contracts, logsTopic, creationBlocks } = require("../constants");

const getAutomationCdpIdList = async ({ api }) => {
  const cdpIdList = new Set();
  const [triggerAddedEvents, triggerRemovedEvents, triggerExecutedEvents] =
    await Promise.all(
      Object.keys(logsTopic).map((key) =>
        getLogs({
          api,
          fromBlock: creationBlocks.AutomationV1Contract,
          target: contracts.AutomationV1Contract,
          topics: [logsTopic[key]],
          eventAbi: abi[key],
          extraKey: key,
          onlyArgs: true,
        })
      )
    );
  const triggerEvents = [
    ...triggerAddedEvents.map((event) => ({
      cdp: event.cdpId.toString(),
      trigger: event.triggerId.toString(),
      action: "triggerAdded",
    })),
    ...triggerRemovedEvents.map((event) => ({
      cdp: event.cdpId.toString(),
      trigger: event.triggerId.toString(),
      action: "triggerRemoved",
    })),
    ...triggerExecutedEvents.map((event) => ({
      cdp: event.cdpId.toString(),
      trigger: event.triggerId.toString(),
      action: "triggerExecuted",
    })),
  ].sort((a, b) => a.trigger - b.trigger);

  triggerEvents.forEach((event) => {
    const { cdp, action } = event;
    if (action === "triggerAdded") {
      cdpIdList.add(cdp);
    } else if (action === "triggerRemoved" || action === "triggerExecuted") {
      cdpIdList.delete(cdp);
    }
  });
  return cdpIdList;
};

module.exports = {
  getAutomationCdpIdList,
};
const { sliceIntoChunks } = require("@defillama/sdk/build/util/index.js");
const abi = require("../constants/abi.js");
const contracts = require("../constants/contracts.js");
const sdk = require("@defillama/sdk");

const getCdpData = async (cdpIds, api) => {
  const res = [];
  const chunks = sliceIntoChunks(cdpIds, 100);
  for (const chunk of chunks)
    res.push(
      ...(await api.multiCall({
        abi: abi.getVaultInfo,
        target: contracts.McdMonitorV2,
        calls: chunk.map(i => ({ params: i})),
      }))
    );

  return res;
};

const getCdpManagerData = async (cdpIds, api) => {
  return cachedCalls({
    items: cdpIds,
    multiCall: async (calls) =>
      api.multiCall({
        abi: abi.ilks,
        target: contracts.CdpManager,
        calls,
      }),
    key: "getCdpManagerData",
  });
};

const getIlkRegistryData = async (ilks, api) => {
  return cachedCalls({
    items: ilks,
    multiCall: async (calls) =>
      api.multiCall({
        abi: abi.info,
        target: contracts.IlkRegistry,
        calls,
      }),
    key: "getIlkRegistryData",
  });
};

const getDecimalsData = async (tokens, api) => {
  return cachedCalls({
    items: tokens,
    multiCall: async (calls) =>
      api.multiCall({
        abi: "erc20:decimals",
        calls,
      }),
    key: "getDecimalsData",
  });
};

let cache = {};
function setCallCache(_cache) {
  cache = _cache;
}

async function cachedCalls({ items, multiCall, key }) {
  if (!cache[key]) cache[key] = {};
  const res = [];
  const missingIds = [];
  const missingIndices = [];
  items.forEach((id, i) => {
    if (cache[key][id]) res[i] = cache[key][id];
    else {
      missingIds.push(id);
      missingIndices.push(i);
    }
  });

  if (missingIds.length) {
    sdk.log("Missing ids", missingIds.length, "key", key);
    const tempRes = await multiCall(missingIds);
    missingIds.forEach((id, i) => {
      res[missingIndices[i]] = tempRes[i];
      cache[key][id] = tempRes[i];
    });
  }
  return res;
}

module.exports = {
  getCdpData,
  getCdpManagerData,
  getIlkRegistryData,
  getDecimalsData,
  setCallCache,
};
const { getAutomationCdpIdList } = require("./get-automation-cdp-ids");
const {
  getCdpData,
  getCdpManagerData,
  getIlkRegistryData,
  getDecimalsData,
  setCallCache,
} = require("./calls");

module.exports = {
  setCallCache,
  getAutomationCdpIdList,
  getCdpData,
  getCdpManagerData,
  getIlkRegistryData,
  getDecimalsData,
};
const creationBlocks = {
  AutomationV1Contract: 14583413,
};

module.exports = creationBlocks;
module.exports = {
  AutomationV1Contract: "0x6E87a7A0A03E51A741075fDf4D1FCce39a4Df01b",
  McdMonitorV2: "0xa59d5E94BFE605A9a4aC7e02f5380e02061c8dd2",
  CdpManager: "0x5ef30b9986345249bc32d8928b7ee64de9435e39",
  IlkRegistry: "0x5a464c28d19848f44199d003bef5ecc87d090f87",
};
const { getEnv } = require("../../helper/env");

const endpoints = {
  aave: () => getEnv("SUMMER_HISTORY_ENDPOINT"),
  ajna: () => getEnv("SUMMER_AJNA_ENDPOINT"),
  makerVaults: () => getEnv("SUMMER_CONFIRMED_VAULTS_ENDPOINT"),
};

module.exports = {
  endpoints,
};
module.exports = {
  TriggerAdded:
    "0xcb616360dd177f28577e33576c8ac7ffcc1008cba7ac2323e0b2f170faf60bd2",
  TriggerExecuted:
    "0xc10f224f2f1ceab5e36f97effaa05c4b75eccbecd77b65bfb20c484de9096cdd",
  TriggerRemoved:
    "0xb4a1fc324bd863f8cd42582bebf2ce7f2d309c6a84bf371f28e069f95a4fa9e1",
};
const creationBlocks = require("./creation-blocks");
const abi = require("./abi");
const contracts = require("./contracts");
const logsTopic = require("./logs-topic");

module.exports = {
  creationBlocks,
  abi,
  contracts,
  logsTopic,
};
module.exports = {
  TriggerAdded:
    "event TriggerAdded(uint256 indexed triggerId, address indexed commandAddress, uint256 indexed cdpId, bytes triggerData)",
  TriggerExecuted:
    "event TriggerExecuted(uint256 indexed triggerId, uint256 indexed cdpId, bytes executionData)",
  TriggerRemoved:
    "event TriggerRemoved(uint256 indexed cdpId, uint256 indexed triggerId)",
  activeTriggers:
    "function activeTriggers(uint256) view returns (bytes32 triggerHash, uint256 cdpId)",
  self: "address:self",
  serviceRegistry: "address:serviceRegistry",
  triggersCounter: "uint256:triggersCounter",
  getVaultInfo:
    "function getCdpInfo(uint256 vaultId,bytes32) view returns (uint256 collateralLocked, uint256)",
  ilks: "function ilks(uint256) view returns (bytes32)",
  info: "function info(bytes32 ilk) view returns (string name, string symbol, uint256 class, uint256 dec, address gem, address pip, address join, address xlip)",
};
