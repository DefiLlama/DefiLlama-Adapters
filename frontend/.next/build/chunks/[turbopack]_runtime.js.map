{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared/runtime-utils.ts"],"sourcesContent":["/**\r\n * This file contains runtime types and functions that are shared between all\r\n * TurboPack ECMAScript runtimes.\r\n *\r\n * It will be prepended to the runtime code of each runtime.\r\n */\r\n\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"./runtime-types.d.ts\" />\r\n\r\ntype EsmNamespaceObject = Record<string, any>\r\n\r\n// @ts-ignore Defined in `dev-base.ts`\r\ndeclare function getOrInstantiateModuleFromParent<M>(\r\n  id: ModuleId,\r\n  sourceModule: M\r\n): M\r\n\r\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\r\n\r\n/**\r\n * Constructs the `__turbopack_context__` object for a module.\r\n */\r\nfunction Context(\r\n  this: TurbopackBaseContext<Module>,\r\n  module: Module,\r\n  exports: Exports\r\n) {\r\n  this.m = module\r\n  // We need to store this here instead of accessing it from the module object to:\r\n  // 1. Make it available to factories directly, since we rewrite `this` to\r\n  //    `__turbopack_context__.e` in CJS modules.\r\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\r\n  //    can still access the original exports object from functions like\r\n  //    `esmExport`\r\n  // Ideally we could find a new approach for async modules and drop this property altogether.\r\n  this.e = exports\r\n}\r\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\r\n\r\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\r\n\r\ninterface ModuleContextEntry {\r\n  id: () => ModuleId\r\n  module: () => any\r\n}\r\n\r\ninterface ModuleContext {\r\n  // require call\r\n  (moduleId: string): Exports | EsmNamespaceObject\r\n\r\n  // async import call\r\n  import(moduleId: string): Promise<Exports | EsmNamespaceObject>\r\n\r\n  keys(): ModuleId[]\r\n\r\n  resolve(moduleId: string): ModuleId\r\n}\r\n\r\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\r\n  moduleId: M['id'],\r\n  parentModule: M\r\n) => M\r\n\r\ndeclare function getOrInstantiateRuntimeModule(\r\n  chunkPath: ChunkPath,\r\n  moduleId: ModuleId\r\n): Module\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\r\n\r\nfunction defineProp(\r\n  obj: any,\r\n  name: PropertyKey,\r\n  options: PropertyDescriptor & ThisType<any>\r\n) {\r\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\r\n}\r\n\r\nfunction getOverwrittenModule(\r\n  moduleCache: ModuleCache<Module>,\r\n  id: ModuleId\r\n): Module {\r\n  let module = moduleCache[id]\r\n  if (!module) {\r\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\r\n    // instantiateModule and the cache entry wasn't created yet.\r\n    module = createModuleObject(id)\r\n    moduleCache[id] = module\r\n  }\r\n  return module\r\n}\r\n\r\n/**\r\n * Creates the module object. Only done here to ensure all module objects have the same shape.\r\n */\r\nfunction createModuleObject(id: ModuleId): Module {\r\n  return {\r\n    exports: {},\r\n    error: undefined,\r\n    id,\r\n    namespaceObject: undefined,\r\n  }\r\n}\r\n\r\ntype BindingTag = 0\r\nconst BindingTag_Value = 0 as BindingTag\r\n\r\n// an arbitrary sequence of bindings as\r\n// - a prop name\r\n// - BindingTag_Value, a value to be bound directly, or\r\n// - 1 or 2 functions to bind as getters and sdetters\r\ntype EsmBindings = Array<\r\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\r\n>\r\n\r\n/**\r\n * Adds the getters to the exports object.\r\n */\r\nfunction esm(exports: Exports, bindings: EsmBindings) {\r\n  defineProp(exports, '__esModule', { value: true })\r\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\r\n  let i = 0\r\n  while (i < bindings.length) {\r\n    const propName = bindings[i++] as string\r\n    const tagOrFunction = bindings[i++]\r\n    if (typeof tagOrFunction === 'number') {\r\n      if (tagOrFunction === BindingTag_Value) {\r\n        defineProp(exports, propName, {\r\n          value: bindings[i++],\r\n          enumerable: true,\r\n          writable: false,\r\n        })\r\n      } else {\r\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\r\n      }\r\n    } else {\r\n      const getterFn = tagOrFunction as () => unknown\r\n      if (typeof bindings[i] === 'function') {\r\n        const setterFn = bindings[i++] as (v: unknown) => void\r\n        defineProp(exports, propName, {\r\n          get: getterFn,\r\n          set: setterFn,\r\n          enumerable: true,\r\n        })\r\n      } else {\r\n        defineProp(exports, propName, {\r\n          get: getterFn,\r\n          enumerable: true,\r\n        })\r\n      }\r\n    }\r\n  }\r\n  Object.seal(exports)\r\n}\r\n\r\n/**\r\n * Makes the module an ESM with exports\r\n */\r\nfunction esmExport(\r\n  this: TurbopackBaseContext<Module>,\r\n  bindings: EsmBindings,\r\n  id: ModuleId | undefined\r\n) {\r\n  let module: Module\r\n  let exports: Module['exports']\r\n  if (id != null) {\r\n    module = getOverwrittenModule(this.c, id)\r\n    exports = module.exports\r\n  } else {\r\n    module = this.m\r\n    exports = this.e\r\n  }\r\n  module.namespaceObject = exports\r\n  esm(exports, bindings)\r\n}\r\ncontextPrototype.s = esmExport\r\n\r\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\r\nfunction ensureDynamicExports(\r\n  module: Module,\r\n  exports: Exports\r\n): ReexportedObjects {\r\n  let reexportedObjects: ReexportedObjects | undefined =\r\n    REEXPORTED_OBJECTS.get(module)\r\n\r\n  if (!reexportedObjects) {\r\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\r\n    module.exports = module.namespaceObject = new Proxy(exports, {\r\n      get(target, prop) {\r\n        if (\r\n          hasOwnProperty.call(target, prop) ||\r\n          prop === 'default' ||\r\n          prop === '__esModule'\r\n        ) {\r\n          return Reflect.get(target, prop)\r\n        }\r\n        for (const obj of reexportedObjects!) {\r\n          const value = Reflect.get(obj, prop)\r\n          if (value !== undefined) return value\r\n        }\r\n        return undefined\r\n      },\r\n      ownKeys(target) {\r\n        const keys = Reflect.ownKeys(target)\r\n        for (const obj of reexportedObjects!) {\r\n          for (const key of Reflect.ownKeys(obj)) {\r\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\r\n          }\r\n        }\r\n        return keys\r\n      },\r\n    })\r\n  }\r\n  return reexportedObjects\r\n}\r\n\r\n/**\r\n * Dynamically exports properties from an object\r\n */\r\nfunction dynamicExport(\r\n  this: TurbopackBaseContext<Module>,\r\n  object: Record<string, any>,\r\n  id: ModuleId | undefined\r\n) {\r\n  let module: Module\r\n  let exports: Exports\r\n  if (id != null) {\r\n    module = getOverwrittenModule(this.c, id)\r\n    exports = module.exports\r\n  } else {\r\n    module = this.m\r\n    exports = this.e\r\n  }\r\n  const reexportedObjects = ensureDynamicExports(module, exports)\r\n\r\n  if (typeof object === 'object' && object !== null) {\r\n    reexportedObjects.push(object)\r\n  }\r\n}\r\ncontextPrototype.j = dynamicExport\r\n\r\nfunction exportValue(\r\n  this: TurbopackBaseContext<Module>,\r\n  value: any,\r\n  id: ModuleId | undefined\r\n) {\r\n  let module: Module\r\n  if (id != null) {\r\n    module = getOverwrittenModule(this.c, id)\r\n  } else {\r\n    module = this.m\r\n  }\r\n  module.exports = value\r\n}\r\ncontextPrototype.v = exportValue\r\n\r\nfunction exportNamespace(\r\n  this: TurbopackBaseContext<Module>,\r\n  namespace: any,\r\n  id: ModuleId | undefined\r\n) {\r\n  let module: Module\r\n  if (id != null) {\r\n    module = getOverwrittenModule(this.c, id)\r\n  } else {\r\n    module = this.m\r\n  }\r\n  module.exports = module.namespaceObject = namespace\r\n}\r\ncontextPrototype.n = exportNamespace\r\n\r\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\r\n  return () => obj[key]\r\n}\r\n\r\n/**\r\n * @returns prototype of the object\r\n */\r\nconst getProto: (obj: any) => any = Object.getPrototypeOf\r\n  ? (obj) => Object.getPrototypeOf(obj)\r\n  : (obj) => obj.__proto__\r\n\r\n/** Prototypes that are not expanded for exports */\r\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\r\n\r\n/**\r\n * @param raw\r\n * @param ns\r\n * @param allowExportDefault\r\n *   * `false`: will have the raw module as default export\r\n *   * `true`: will have the default property as default export\r\n */\r\nfunction interopEsm(\r\n  raw: Exports,\r\n  ns: EsmNamespaceObject,\r\n  allowExportDefault?: boolean\r\n) {\r\n  const bindings: EsmBindings = []\r\n  let defaultLocation = -1\r\n  for (\r\n    let current = raw;\r\n    (typeof current === 'object' || typeof current === 'function') &&\r\n    !LEAF_PROTOTYPES.includes(current);\r\n    current = getProto(current)\r\n  ) {\r\n    for (const key of Object.getOwnPropertyNames(current)) {\r\n      bindings.push(key, createGetter(raw, key))\r\n      if (defaultLocation === -1 && key === 'default') {\r\n        defaultLocation = bindings.length - 1\r\n      }\r\n    }\r\n  }\r\n\r\n  // this is not really correct\r\n  // we should set the `default` getter if the imported module is a `.cjs file`\r\n  if (!(allowExportDefault && defaultLocation >= 0)) {\r\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\r\n    if (defaultLocation >= 0) {\r\n      // Replace the getter with the value\r\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\r\n    } else {\r\n      bindings.push('default', BindingTag_Value, raw)\r\n    }\r\n  }\r\n\r\n  esm(ns, bindings)\r\n  return ns\r\n}\r\n\r\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\r\n  if (typeof raw === 'function') {\r\n    return function (this: any, ...args: any[]) {\r\n      return raw.apply(this, args)\r\n    }\r\n  } else {\r\n    return Object.create(null)\r\n  }\r\n}\r\n\r\nfunction esmImport(\r\n  this: TurbopackBaseContext<Module>,\r\n  id: ModuleId\r\n): Exclude<Module['namespaceObject'], undefined> {\r\n  const module = getOrInstantiateModuleFromParent(id, this.m)\r\n\r\n  // any ES module has to have `module.namespaceObject` defined.\r\n  if (module.namespaceObject) return module.namespaceObject\r\n\r\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\r\n  const raw = module.exports\r\n  return (module.namespaceObject = interopEsm(\r\n    raw,\r\n    createNS(raw),\r\n    raw && (raw as any).__esModule\r\n  ))\r\n}\r\ncontextPrototype.i = esmImport\r\n\r\nfunction asyncLoader(\r\n  this: TurbopackBaseContext<Module>,\r\n  moduleId: ModuleId\r\n): Promise<Exports> {\r\n  const loader = this.r(moduleId) as (\r\n    importFunction: EsmImport\r\n  ) => Promise<Exports>\r\n  return loader(esmImport.bind(this))\r\n}\r\ncontextPrototype.A = asyncLoader\r\n\r\n// Add a simple runtime require so that environments without one can still pass\r\n// `typeof require` CommonJS checks so that exports are correctly registered.\r\nconst runtimeRequire =\r\n  // @ts-ignore\r\n  typeof require === 'function'\r\n    ? // @ts-ignore\r\n      require\r\n    : function require() {\r\n        throw new Error('Unexpected use of runtime require')\r\n      }\r\ncontextPrototype.t = runtimeRequire\r\n\r\nfunction commonJsRequire(\r\n  this: TurbopackBaseContext<Module>,\r\n  id: ModuleId\r\n): Exports {\r\n  return getOrInstantiateModuleFromParent(id, this.m).exports\r\n}\r\ncontextPrototype.r = commonJsRequire\r\n\r\n/**\r\n * Remove fragments and query parameters since they are never part of the context map keys\r\n *\r\n * This matches how we parse patterns at resolving time.  Arguably we should only do this for\r\n * strings passed to `import` but the resolve does it for `import` and `require` and so we do\r\n * here as well.\r\n */\r\nfunction parseRequest(request: string): string {\r\n  // Per the URI spec fragments can contain `?` characters, so we should trim it off first\r\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\r\n  const hashIndex = request.indexOf('#')\r\n  if (hashIndex !== -1) {\r\n    request = request.substring(0, hashIndex)\r\n  }\r\n\r\n  const queryIndex = request.indexOf('?')\r\n  if (queryIndex !== -1) {\r\n    request = request.substring(0, queryIndex)\r\n  }\r\n\r\n  return request\r\n}\r\n/**\r\n * `require.context` and require/import expression runtime.\r\n */\r\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\r\n  function moduleContext(id: string): Exports {\r\n    id = parseRequest(id)\r\n    if (hasOwnProperty.call(map, id)) {\r\n      return map[id].module()\r\n    }\r\n\r\n    const e = new Error(`Cannot find module '${id}'`)\r\n    ;(e as any).code = 'MODULE_NOT_FOUND'\r\n    throw e\r\n  }\r\n\r\n  moduleContext.keys = (): string[] => {\r\n    return Object.keys(map)\r\n  }\r\n\r\n  moduleContext.resolve = (id: string): ModuleId => {\r\n    id = parseRequest(id)\r\n    if (hasOwnProperty.call(map, id)) {\r\n      return map[id].id()\r\n    }\r\n\r\n    const e = new Error(`Cannot find module '${id}'`)\r\n    ;(e as any).code = 'MODULE_NOT_FOUND'\r\n    throw e\r\n  }\r\n\r\n  moduleContext.import = async (id: string) => {\r\n    return await (moduleContext(id) as Promise<Exports>)\r\n  }\r\n\r\n  return moduleContext\r\n}\r\ncontextPrototype.f = moduleContext\r\n\r\n/**\r\n * Returns the path of a chunk defined by its data.\r\n */\r\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\r\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\r\n}\r\n\r\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\r\n  return (\r\n    maybePromise != null &&\r\n    typeof maybePromise === 'object' &&\r\n    'then' in maybePromise &&\r\n    typeof maybePromise.then === 'function'\r\n  )\r\n}\r\n\r\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\r\n  return turbopackQueues in obj\r\n}\r\n\r\nfunction createPromise<T>() {\r\n  let resolve: (value: T | PromiseLike<T>) => void\r\n  let reject: (reason?: any) => void\r\n\r\n  const promise = new Promise<T>((res, rej) => {\r\n    reject = rej\r\n    resolve = res\r\n  })\r\n\r\n  return {\r\n    promise,\r\n    resolve: resolve!,\r\n    reject: reject!,\r\n  }\r\n}\r\n\r\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\r\n// The CompressedModuleFactories format is\r\n// - 1 or more module ids\r\n// - a module factory function\r\n// So walking this is a little complex but the flat structure is also fast to\r\n// traverse, we can use `typeof` operators to distinguish the two cases.\r\nfunction installCompressedModuleFactories(\r\n  chunkModules: CompressedModuleFactories,\r\n  offset: number,\r\n  moduleFactories: ModuleFactories,\r\n  newModuleId?: (id: ModuleId) => void\r\n) {\r\n  let i = offset\r\n  while (i < chunkModules.length) {\r\n    let moduleId = chunkModules[i] as ModuleId\r\n    let end = i + 1\r\n    // Find our factory function\r\n    while (\r\n      end < chunkModules.length &&\r\n      typeof chunkModules[end] !== 'function'\r\n    ) {\r\n      end++\r\n    }\r\n    if (end === chunkModules.length) {\r\n      throw new Error('malformed chunk format, expected a factory function')\r\n    }\r\n    // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\r\n    // present we know all the additional ids are also present, so we don't need to check.\r\n    if (!moduleFactories.has(moduleId)) {\r\n      const moduleFactoryFn = chunkModules[end] as Function\r\n      applyModuleFactoryName(moduleFactoryFn)\r\n      newModuleId?.(moduleId)\r\n      for (; i < end; i++) {\r\n        moduleId = chunkModules[i] as ModuleId\r\n        moduleFactories.set(moduleId, moduleFactoryFn)\r\n      }\r\n    }\r\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\r\n  }\r\n}\r\n\r\n// everything below is adapted from webpack\r\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\r\n\r\nconst turbopackQueues = Symbol('turbopack queues')\r\nconst turbopackExports = Symbol('turbopack exports')\r\nconst turbopackError = Symbol('turbopack error')\r\n\r\nconst enum QueueStatus {\r\n  Unknown = -1,\r\n  Unresolved = 0,\r\n  Resolved = 1,\r\n}\r\n\r\ntype AsyncQueueFn = (() => void) & { queueCount: number }\r\ntype AsyncQueue = AsyncQueueFn[] & {\r\n  status: QueueStatus\r\n}\r\n\r\nfunction resolveQueue(queue?: AsyncQueue) {\r\n  if (queue && queue.status !== QueueStatus.Resolved) {\r\n    queue.status = QueueStatus.Resolved\r\n    queue.forEach((fn) => fn.queueCount--)\r\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\r\n  }\r\n}\r\n\r\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\r\n\r\ntype AsyncModuleExt = {\r\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\r\n  [turbopackExports]: Exports\r\n  [turbopackError]?: any\r\n}\r\n\r\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\r\n\r\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\r\n  return deps.map((dep): AsyncModuleExt => {\r\n    if (dep !== null && typeof dep === 'object') {\r\n      if (isAsyncModuleExt(dep)) return dep\r\n      if (isPromise(dep)) {\r\n        const queue: AsyncQueue = Object.assign([], {\r\n          status: QueueStatus.Unresolved,\r\n        })\r\n\r\n        const obj: AsyncModuleExt = {\r\n          [turbopackExports]: {},\r\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\r\n        }\r\n\r\n        dep.then(\r\n          (res) => {\r\n            obj[turbopackExports] = res\r\n            resolveQueue(queue)\r\n          },\r\n          (err) => {\r\n            obj[turbopackError] = err\r\n            resolveQueue(queue)\r\n          }\r\n        )\r\n\r\n        return obj\r\n      }\r\n    }\r\n\r\n    return {\r\n      [turbopackExports]: dep,\r\n      [turbopackQueues]: () => {},\r\n    }\r\n  })\r\n}\r\n\r\nfunction asyncModule(\r\n  this: TurbopackBaseContext<Module>,\r\n  body: (\r\n    handleAsyncDependencies: (\r\n      deps: Dep[]\r\n    ) => Exports[] | Promise<() => Exports[]>,\r\n    asyncResult: (err?: any) => void\r\n  ) => void,\r\n  hasAwait: boolean\r\n) {\r\n  const module = this.m\r\n  const queue: AsyncQueue | undefined = hasAwait\r\n    ? Object.assign([], { status: QueueStatus.Unknown })\r\n    : undefined\r\n\r\n  const depQueues: Set<AsyncQueue> = new Set()\r\n\r\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\r\n\r\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\r\n    [turbopackExports]: module.exports,\r\n    [turbopackQueues]: (fn) => {\r\n      queue && fn(queue)\r\n      depQueues.forEach(fn)\r\n      promise['catch'](() => {})\r\n    },\r\n  } satisfies AsyncModuleExt)\r\n\r\n  const attributes: PropertyDescriptor = {\r\n    get(): any {\r\n      return promise\r\n    },\r\n    set(v: any) {\r\n      // Calling `esmExport` leads to this.\r\n      if (v !== promise) {\r\n        promise[turbopackExports] = v\r\n      }\r\n    },\r\n  }\r\n\r\n  Object.defineProperty(module, 'exports', attributes)\r\n  Object.defineProperty(module, 'namespaceObject', attributes)\r\n\r\n  function handleAsyncDependencies(deps: Dep[]) {\r\n    const currentDeps = wrapDeps(deps)\r\n\r\n    const getResult = () =>\r\n      currentDeps.map((d) => {\r\n        if (d[turbopackError]) throw d[turbopackError]\r\n        return d[turbopackExports]\r\n      })\r\n\r\n    const { promise, resolve } = createPromise<() => Exports[]>()\r\n\r\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\r\n      queueCount: 0,\r\n    })\r\n\r\n    function fnQueue(q: AsyncQueue) {\r\n      if (q !== queue && !depQueues.has(q)) {\r\n        depQueues.add(q)\r\n        if (q && q.status === QueueStatus.Unresolved) {\r\n          fn.queueCount++\r\n          q.push(fn)\r\n        }\r\n      }\r\n    }\r\n\r\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\r\n\r\n    return fn.queueCount ? promise : getResult()\r\n  }\r\n\r\n  function asyncResult(err?: any) {\r\n    if (err) {\r\n      reject((promise[turbopackError] = err))\r\n    } else {\r\n      resolve(promise[turbopackExports])\r\n    }\r\n\r\n    resolveQueue(queue)\r\n  }\r\n\r\n  body(handleAsyncDependencies, asyncResult)\r\n\r\n  if (queue && queue.status === QueueStatus.Unknown) {\r\n    queue.status = QueueStatus.Unresolved\r\n  }\r\n}\r\ncontextPrototype.a = asyncModule\r\n\r\n/**\r\n * A pseudo \"fake\" URL object to resolve to its relative path.\r\n *\r\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\r\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\r\n * hydration mismatch.\r\n *\r\n * This is based on webpack's existing implementation:\r\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\r\n */\r\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\r\n  const realUrl = new URL(inputUrl, 'x:/')\r\n  const values: Record<string, any> = {}\r\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\r\n  values.href = inputUrl\r\n  values.pathname = inputUrl.replace(/[?#].*/, '')\r\n  values.origin = values.protocol = ''\r\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\r\n  for (const key in values)\r\n    Object.defineProperty(this, key, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      value: values[key],\r\n    })\r\n}\r\nrelativeURL.prototype = URL.prototype\r\ncontextPrototype.U = relativeURL\r\n\r\n/**\r\n * Utility function to ensure all variants of an enum are handled.\r\n */\r\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\r\n  throw new Error(`Invariant: ${computeMessage(never)}`)\r\n}\r\n\r\n/**\r\n * A stub function to make `require` available but non-functional in ESM.\r\n */\r\nfunction requireStub(_moduleId: ModuleId): never {\r\n  throw new Error('dynamic usage of require is not supported')\r\n}\r\ncontextPrototype.z = requireStub\r\n\r\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\r\ncontextPrototype.g = globalThis\r\n\r\ntype ContextConstructor<M> = {\r\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\r\n}\r\n\r\nfunction applyModuleFactoryName(factory: Function) {\r\n  // Give the module factory a nice name to improve stack traces.\r\n  Object.defineProperty(factory, 'name', {\r\n    value: 'module evaluation',\r\n  })\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED,oDAAoD,GAEpD,6CAA6C;AAU7C,MAAM,qBAAqB,IAAI;AAE/B;;CAEC,GACD,SAAS,QAEP,MAAc,EACd,OAAgB;IAEhB,IAAI,CAAC,CAAC,GAAG;IACT,gFAAgF;IAChF,yEAAyE;IACzE,+CAA+C;IAC/C,8EAA8E;IAC9E,sEAAsE;IACtE,iBAAiB;IACjB,4FAA4F;IAC5F,IAAI,CAAC,CAAC,GAAG;AACX;AACA,MAAM,mBAAmB,QAAQ,SAAS;AA+B1C,MAAM,iBAAiB,OAAO,SAAS,CAAC,cAAc;AACtD,MAAM,cAAc,OAAO,WAAW,eAAe,OAAO,WAAW;AAEvE,SAAS,WACP,GAAQ,EACR,IAAiB,EACjB,OAA2C;IAE3C,IAAI,CAAC,eAAe,IAAI,CAAC,KAAK,OAAO,OAAO,cAAc,CAAC,KAAK,MAAM;AACxE;AAEA,SAAS,qBACP,WAAgC,EAChC,EAAY;IAEZ,IAAI,SAAS,WAAW,CAAC,GAAG;IAC5B,IAAI,CAAC,QAAQ;QACX,0FAA0F;QAC1F,4DAA4D;QAC5D,SAAS,mBAAmB;QAC5B,WAAW,CAAC,GAAG,GAAG;IACpB;IACA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,mBAAmB,EAAY;IACtC,OAAO;QACL,SAAS,CAAC;QACV,OAAO;QACP;QACA,iBAAiB;IACnB;AACF;AAGA,MAAM,mBAAmB;AAUzB;;CAEC,GACD,SAAS,IAAI,OAAgB,EAAE,QAAqB;IAClD,WAAW,SAAS,cAAc;QAAE,OAAO;IAAK;IAChD,IAAI,aAAa,WAAW,SAAS,aAAa;QAAE,OAAO;IAAS;IACpE,IAAI,IAAI;IACR,MAAO,IAAI,SAAS,MAAM,CAAE;QAC1B,MAAM,WAAW,QAAQ,CAAC,IAAI;QAC9B,MAAM,gBAAgB,QAAQ,CAAC,IAAI;QACnC,IAAI,OAAO,kBAAkB,UAAU;YACrC,IAAI,kBAAkB,kBAAkB;gBACtC,WAAW,SAAS,UAAU;oBAC5B,OAAO,QAAQ,CAAC,IAAI;oBACpB,YAAY;oBACZ,UAAU;gBACZ;YACF,OAAO;gBACL,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,eAAe;YACpD;QACF,OAAO;YACL,MAAM,WAAW;YACjB,IAAI,OAAO,QAAQ,CAAC,EAAE,KAAK,YAAY;gBACrC,MAAM,WAAW,QAAQ,CAAC,IAAI;gBAC9B,WAAW,SAAS,UAAU;oBAC5B,KAAK;oBACL,KAAK;oBACL,YAAY;gBACd;YACF,OAAO;gBACL,WAAW,SAAS,UAAU;oBAC5B,KAAK;oBACL,YAAY;gBACd;YACF;QACF;IACF;IACA,OAAO,IAAI,CAAC;AACd;AAEA;;CAEC,GACD,SAAS,UAEP,QAAqB,EACrB,EAAwB;IAExB,IAAI;IACJ,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;QACtC,UAAU,OAAO,OAAO;IAC1B,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;QACf,UAAU,IAAI,CAAC,CAAC;IAClB;IACA,OAAO,eAAe,GAAG;IACzB,IAAI,SAAS;AACf;AACA,iBAAiB,CAAC,GAAG;AAGrB,SAAS,qBACP,MAAc,EACd,OAAgB;IAEhB,IAAI,oBACF,mBAAmB,GAAG,CAAC;IAEzB,IAAI,CAAC,mBAAmB;QACtB,mBAAmB,GAAG,CAAC,QAAS,oBAAoB,EAAE;QACtD,OAAO,OAAO,GAAG,OAAO,eAAe,GAAG,IAAI,MAAM,SAAS;YAC3D,KAAI,MAAM,EAAE,IAAI;gBACd,IACE,eAAe,IAAI,CAAC,QAAQ,SAC5B,SAAS,aACT,SAAS,cACT;oBACA,OAAO,QAAQ,GAAG,CAAC,QAAQ;gBAC7B;gBACA,KAAK,MAAM,OAAO,kBAAoB;oBACpC,MAAM,QAAQ,QAAQ,GAAG,CAAC,KAAK;oBAC/B,IAAI,UAAU,WAAW,OAAO;gBAClC;gBACA,OAAO;YACT;YACA,SAAQ,MAAM;gBACZ,MAAM,OAAO,QAAQ,OAAO,CAAC;gBAC7B,KAAK,MAAM,OAAO,kBAAoB;oBACpC,KAAK,MAAM,OAAO,QAAQ,OAAO,CAAC,KAAM;wBACtC,IAAI,QAAQ,aAAa,CAAC,KAAK,QAAQ,CAAC,MAAM,KAAK,IAAI,CAAC;oBAC1D;gBACF;gBACA,OAAO;YACT;QACF;IACF;IACA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,cAEP,MAA2B,EAC3B,EAAwB;IAExB,IAAI;IACJ,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;QACtC,UAAU,OAAO,OAAO;IAC1B,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;QACf,UAAU,IAAI,CAAC,CAAC;IAClB;IACA,MAAM,oBAAoB,qBAAqB,QAAQ;IAEvD,IAAI,OAAO,WAAW,YAAY,WAAW,MAAM;QACjD,kBAAkB,IAAI,CAAC;IACzB;AACF;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,YAEP,KAAU,EACV,EAAwB;IAExB,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;IACxC,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;IACjB;IACA,OAAO,OAAO,GAAG;AACnB;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBAEP,SAAc,EACd,EAAwB;IAExB,IAAI;IACJ,IAAI,MAAM,MAAM;QACd,SAAS,qBAAqB,IAAI,CAAC,CAAC,EAAE;IACxC,OAAO;QACL,SAAS,IAAI,CAAC,CAAC;IACjB;IACA,OAAO,OAAO,GAAG,OAAO,eAAe,GAAG;AAC5C;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,aAAa,GAAiC,EAAE,GAAoB;IAC3E,OAAO,IAAM,GAAG,CAAC,IAAI;AACvB;AAEA;;CAEC,GACD,MAAM,WAA8B,OAAO,cAAc,GACrD,CAAC,MAAQ,OAAO,cAAc,CAAC,OAC/B,CAAC,MAAQ,IAAI,SAAS;AAE1B,iDAAiD,GACjD,MAAM,kBAAkB;IAAC;IAAM,SAAS,CAAC;IAAI,SAAS,EAAE;IAAG,SAAS;CAAU;AAE9E;;;;;;CAMC,GACD,SAAS,WACP,GAAY,EACZ,EAAsB,EACtB,kBAA4B;IAE5B,MAAM,WAAwB,EAAE;IAChC,IAAI,kBAAkB,CAAC;IACvB,IACE,IAAI,UAAU,KACd,CAAC,OAAO,YAAY,YAAY,OAAO,YAAY,UAAU,KAC7D,CAAC,gBAAgB,QAAQ,CAAC,UAC1B,UAAU,SAAS,SACnB;QACA,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,SAAU;YACrD,SAAS,IAAI,CAAC,KAAK,aAAa,KAAK;YACrC,IAAI,oBAAoB,CAAC,KAAK,QAAQ,WAAW;gBAC/C,kBAAkB,SAAS,MAAM,GAAG;YACtC;QACF;IACF;IAEA,6BAA6B;IAC7B,6EAA6E;IAC7E,IAAI,CAAC,CAAC,sBAAsB,mBAAmB,CAAC,GAAG;QACjD,8FAA8F;QAC9F,IAAI,mBAAmB,GAAG;YACxB,oCAAoC;YACpC,SAAS,MAAM,CAAC,iBAAiB,GAAG,kBAAkB;QACxD,OAAO;YACL,SAAS,IAAI,CAAC,WAAW,kBAAkB;QAC7C;IACF;IAEA,IAAI,IAAI;IACR,OAAO;AACT;AAEA,SAAS,SAAS,GAAsB;IACtC,IAAI,OAAO,QAAQ,YAAY;QAC7B,OAAO,SAAqB,GAAG,IAAW;YACxC,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE;QACzB;IACF,OAAO;QACL,OAAO,OAAO,MAAM,CAAC;IACvB;AACF;AAEA,SAAS,UAEP,EAAY;IAEZ,MAAM,SAAS,iCAAiC,IAAI,IAAI,CAAC,CAAC;IAE1D,8DAA8D;IAC9D,IAAI,OAAO,eAAe,EAAE,OAAO,OAAO,eAAe;IAEzD,iGAAiG;IACjG,MAAM,MAAM,OAAO,OAAO;IAC1B,OAAQ,OAAO,eAAe,GAAG,WAC/B,KACA,SAAS,MACT,OAAO,AAAC,IAAY,UAAU;AAElC;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,YAEP,QAAkB;IAElB,MAAM,SAAS,IAAI,CAAC,CAAC,CAAC;IAGtB,OAAO,OAAO,UAAU,IAAI,CAAC,IAAI;AACnC;AACA,iBAAiB,CAAC,GAAG;AAErB,+EAA+E;AAC/E,6EAA6E;AAC7E,MAAM,iBACJ,aAAa;AACb,OAAO,YAAY,aAEf,UACA,SAAS;IACP,MAAM,IAAI,MAAM;AAClB;AACN,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBAEP,EAAY;IAEZ,OAAO,iCAAiC,IAAI,IAAI,CAAC,CAAC,EAAE,OAAO;AAC7D;AACA,iBAAiB,CAAC,GAAG;AAErB;;;;;;CAMC,GACD,SAAS,aAAa,OAAe;IACnC,wFAAwF;IACxF,4DAA4D;IAC5D,MAAM,YAAY,QAAQ,OAAO,CAAC;IAClC,IAAI,cAAc,CAAC,GAAG;QACpB,UAAU,QAAQ,SAAS,CAAC,GAAG;IACjC;IAEA,MAAM,aAAa,QAAQ,OAAO,CAAC;IACnC,IAAI,eAAe,CAAC,GAAG;QACrB,UAAU,QAAQ,SAAS,CAAC,GAAG;IACjC;IAEA,OAAO;AACT;AACA;;CAEC,GACD,SAAS,cAAc,GAAqB;IAC1C,SAAS,cAAc,EAAU;QAC/B,KAAK,aAAa;QAClB,IAAI,eAAe,IAAI,CAAC,KAAK,KAAK;YAChC,OAAO,GAAG,CAAC,GAAG,CAAC,MAAM;QACvB;QAEA,MAAM,IAAI,IAAI,MAAM,CAAC,oBAAoB,EAAE,GAAG,CAAC,CAAC;QAC9C,EAAU,IAAI,GAAG;QACnB,MAAM;IACR;IAEA,cAAc,IAAI,GAAG;QACnB,OAAO,OAAO,IAAI,CAAC;IACrB;IAEA,cAAc,OAAO,GAAG,CAAC;QACvB,KAAK,aAAa;QAClB,IAAI,eAAe,IAAI,CAAC,KAAK,KAAK;YAChC,OAAO,GAAG,CAAC,GAAG,CAAC,EAAE;QACnB;QAEA,MAAM,IAAI,IAAI,MAAM,CAAC,oBAAoB,EAAE,GAAG,CAAC,CAAC;QAC9C,EAAU,IAAI,GAAG;QACnB,MAAM;IACR;IAEA,cAAc,MAAM,GAAG,OAAO;QAC5B,OAAO,MAAO,cAAc;IAC9B;IAEA,OAAO;AACT;AACA,iBAAiB,CAAC,GAAG;AAErB;;CAEC,GACD,SAAS,aAAa,SAAoB;IACxC,OAAO,OAAO,cAAc,WAAW,YAAY,UAAU,IAAI;AACnE;AAEA,SAAS,UAAmB,YAAiB;IAC3C,OACE,gBAAgB,QAChB,OAAO,iBAAiB,YACxB,UAAU,gBACV,OAAO,aAAa,IAAI,KAAK;AAEjC;AAEA,SAAS,iBAA+B,GAAM;IAC5C,OAAO,mBAAmB;AAC5B;AAEA,SAAS;IACP,IAAI;IACJ,IAAI;IAEJ,MAAM,UAAU,IAAI,QAAW,CAAC,KAAK;QACnC,SAAS;QACT,UAAU;IACZ;IAEA,OAAO;QACL;QACA,SAAS;QACT,QAAQ;IACV;AACF;AAEA,gFAAgF;AAChF,0CAA0C;AAC1C,yBAAyB;AACzB,8BAA8B;AAC9B,6EAA6E;AAC7E,wEAAwE;AACxE,SAAS,iCACP,YAAuC,EACvC,MAAc,EACd,eAAgC,EAChC,WAAoC;IAEpC,IAAI,IAAI;IACR,MAAO,IAAI,aAAa,MAAM,CAAE;QAC9B,IAAI,WAAW,YAAY,CAAC,EAAE;QAC9B,IAAI,MAAM,IAAI;QACd,4BAA4B;QAC5B,MACE,MAAM,aAAa,MAAM,IACzB,OAAO,YAAY,CAAC,IAAI,KAAK,WAC7B;YACA;QACF;QACA,IAAI,QAAQ,aAAa,MAAM,EAAE;YAC/B,MAAM,IAAI,MAAM;QAClB;QACA,+FAA+F;QAC/F,sFAAsF;QACtF,IAAI,CAAC,gBAAgB,GAAG,CAAC,WAAW;YAClC,MAAM,kBAAkB,YAAY,CAAC,IAAI;YACzC,uBAAuB;YACvB,cAAc;YACd,MAAO,IAAI,KAAK,IAAK;gBACnB,WAAW,YAAY,CAAC,EAAE;gBAC1B,gBAAgB,GAAG,CAAC,UAAU;YAChC;QACF;QACA,IAAI,MAAM,GAAE,sFAAsF;IACpG;AACF;AAEA,2CAA2C;AAC3C,+HAA+H;AAE/H,MAAM,kBAAkB,OAAO;AAC/B,MAAM,mBAAmB,OAAO;AAChC,MAAM,iBAAiB,OAAO;AAa9B,SAAS,aAAa,KAAkB;IACtC,IAAI,SAAS,MAAM,MAAM,QAA2B;QAClD,MAAM,MAAM;QACZ,MAAM,OAAO,CAAC,CAAC,KAAO,GAAG,UAAU;QACnC,MAAM,OAAO,CAAC,CAAC,KAAQ,GAAG,UAAU,KAAK,GAAG,UAAU,KAAK;IAC7D;AACF;AAYA,SAAS,SAAS,IAAW;IAC3B,OAAO,KAAK,GAAG,CAAC,CAAC;QACf,IAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;YAC3C,IAAI,iBAAiB,MAAM,OAAO;YAClC,IAAI,UAAU,MAAM;gBAClB,MAAM,QAAoB,OAAO,MAAM,CAAC,EAAE,EAAE;oBAC1C,MAAM;gBACR;gBAEA,MAAM,MAAsB;oBAC1B,CAAC,iBAAiB,EAAE,CAAC;oBACrB,CAAC,gBAAgB,EAAE,CAAC,KAAoC,GAAG;gBAC7D;gBAEA,IAAI,IAAI,CACN,CAAC;oBACC,GAAG,CAAC,iBAAiB,GAAG;oBACxB,aAAa;gBACf,GACA,CAAC;oBACC,GAAG,CAAC,eAAe,GAAG;oBACtB,aAAa;gBACf;gBAGF,OAAO;YACT;QACF;QAEA,OAAO;YACL,CAAC,iBAAiB,EAAE;YACpB,CAAC,gBAAgB,EAAE,KAAO;QAC5B;IACF;AACF;AAEA,SAAS,YAEP,IAKS,EACT,QAAiB;IAEjB,MAAM,SAAS,IAAI,CAAC,CAAC;IACrB,MAAM,QAAgC,WAClC,OAAO,MAAM,CAAC,EAAE,EAAE;QAAE,MAAM;IAAsB,KAChD;IAEJ,MAAM,YAA6B,IAAI;IAEvC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,UAAU,EAAE,GAAG;IAEjD,MAAM,UAA8B,OAAO,MAAM,CAAC,YAAY;QAC5D,CAAC,iBAAiB,EAAE,OAAO,OAAO;QAClC,CAAC,gBAAgB,EAAE,CAAC;YAClB,SAAS,GAAG;YACZ,UAAU,OAAO,CAAC;YAClB,OAAO,CAAC,QAAQ,CAAC,KAAO;QAC1B;IACF;IAEA,MAAM,aAAiC;QACrC;YACE,OAAO;QACT;QACA,KAAI,CAAM;YACR,qCAAqC;YACrC,IAAI,MAAM,SAAS;gBACjB,OAAO,CAAC,iBAAiB,GAAG;YAC9B;QACF;IACF;IAEA,OAAO,cAAc,CAAC,QAAQ,WAAW;IACzC,OAAO,cAAc,CAAC,QAAQ,mBAAmB;IAEjD,SAAS,wBAAwB,IAAW;QAC1C,MAAM,cAAc,SAAS;QAE7B,MAAM,YAAY,IAChB,YAAY,GAAG,CAAC,CAAC;gBACf,IAAI,CAAC,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC,eAAe;gBAC9C,OAAO,CAAC,CAAC,iBAAiB;YAC5B;QAEF,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG;QAE7B,MAAM,KAAmB,OAAO,MAAM,CAAC,IAAM,QAAQ,YAAY;YAC/D,YAAY;QACd;QAEA,SAAS,QAAQ,CAAa;YAC5B,IAAI,MAAM,SAAS,CAAC,UAAU,GAAG,CAAC,IAAI;gBACpC,UAAU,GAAG,CAAC;gBACd,IAAI,KAAK,EAAE,MAAM,QAA6B;oBAC5C,GAAG,UAAU;oBACb,EAAE,IAAI,CAAC;gBACT;YACF;QACF;QAEA,YAAY,GAAG,CAAC,CAAC,MAAQ,GAAG,CAAC,gBAAgB,CAAC;QAE9C,OAAO,GAAG,UAAU,GAAG,UAAU;IACnC;IAEA,SAAS,YAAY,GAAS;QAC5B,IAAI,KAAK;YACP,OAAQ,OAAO,CAAC,eAAe,GAAG;QACpC,OAAO;YACL,QAAQ,OAAO,CAAC,iBAAiB;QACnC;QAEA,aAAa;IACf;IAEA,KAAK,yBAAyB;IAE9B,IAAI,SAAS,MAAM,MAAM,SAA0B;QACjD,MAAM,MAAM;IACd;AACF;AACA,iBAAiB,CAAC,GAAG;AAErB;;;;;;;;;CASC,GACD,MAAM,cAAc,SAAS,YAAuB,QAAgB;IAClE,MAAM,UAAU,IAAI,IAAI,UAAU;IAClC,MAAM,SAA8B,CAAC;IACrC,IAAK,MAAM,OAAO,QAAS,MAAM,CAAC,IAAI,GAAG,AAAC,OAAe,CAAC,IAAI;IAC9D,OAAO,IAAI,GAAG;IACd,OAAO,QAAQ,GAAG,SAAS,OAAO,CAAC,UAAU;IAC7C,OAAO,MAAM,GAAG,OAAO,QAAQ,GAAG;IAClC,OAAO,QAAQ,GAAG,OAAO,MAAM,GAAG,CAAC,GAAG,QAAsB;IAC5D,IAAK,MAAM,OAAO,OAChB,OAAO,cAAc,CAAC,IAAI,EAAE,KAAK;QAC/B,YAAY;QACZ,cAAc;QACd,OAAO,MAAM,CAAC,IAAI;IACpB;AACJ;AACA,YAAY,SAAS,GAAG,IAAI,SAAS;AACrC,iBAAiB,CAAC,GAAG;AAErB;;CAEC,GACD,SAAS,UAAU,KAAY,EAAE,cAAoC;IACnE,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,eAAe,QAAQ;AACvD;AAEA;;CAEC,GACD,SAAS,YAAY,SAAmB;IACtC,MAAM,IAAI,MAAM;AAClB;AACA,iBAAiB,CAAC,GAAG;AAErB,kGAAkG;AAClG,iBAAiB,CAAC,GAAG;AAMrB,SAAS,uBAAuB,OAAiB;IAC/C,+DAA+D;IAC/D,OAAO,cAAc,CAAC,SAAS,QAAQ;QACrC,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 504, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/base-externals-utils.ts"],"sourcesContent":["/// <reference path=\"../shared/runtime-utils.ts\" />\r\n\r\n/// A 'base' utilities to support runtime can have externals.\r\n/// Currently this is for node.js / edge runtime both.\r\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\r\n\r\nasync function externalImport(id: DependencySpecifier) {\r\n  let raw\r\n  try {\r\n    raw = await import(id)\r\n  } catch (err) {\r\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\r\n    // an external module we don't provide a shim for (e.g. querystring, url).\r\n    // For now, we fail semi-silently, but in the future this should be a\r\n    // compilation error.\r\n    throw new Error(`Failed to load external module ${id}: ${err}`)\r\n  }\r\n\r\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\r\n    return interopEsm(raw.default, createNS(raw), true)\r\n  }\r\n\r\n  return raw\r\n}\r\ncontextPrototype.y = externalImport\r\n\r\nfunction externalRequire(\r\n  id: ModuleId,\r\n  thunk: () => any,\r\n  esm: boolean = false\r\n): Exports | EsmNamespaceObject {\r\n  let raw\r\n  try {\r\n    raw = thunk()\r\n  } catch (err) {\r\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\r\n    // an external module we don't provide a shim for (e.g. querystring, url).\r\n    // For now, we fail semi-silently, but in the future this should be a\r\n    // compilation error.\r\n    throw new Error(`Failed to load external module ${id}: ${err}`)\r\n  }\r\n\r\n  if (!esm || raw.__esModule) {\r\n    return raw\r\n  }\r\n\r\n  return interopEsm(raw, createNS(raw), true)\r\n}\r\n\r\nexternalRequire.resolve = (\r\n  id: string,\r\n  options?: {\r\n    paths?: string[]\r\n  }\r\n) => {\r\n  return require.resolve(id, options)\r\n}\r\ncontextPrototype.x = externalRequire\r\n"],"names":[],"mappings":"AAAA,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAuB;IACnD,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B;AACA,iBAAiB,CAAC,GAAG","ignoreList":[0]}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/node-externals-utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\ndeclare var RUNTIME_PUBLIC_PATH: string\r\ndeclare var RELATIVE_ROOT_PATH: string\r\ndeclare var ASSET_PREFIX: string\r\n\r\nconst path = require('path')\r\n\r\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.')\r\n// Compute the relative path to the `distDir`.\r\nconst relativePathToDistRoot = path.join(\r\n  relativePathToRuntimeRoot,\r\n  RELATIVE_ROOT_PATH\r\n)\r\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot)\r\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\r\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot)\r\n\r\n/**\r\n * Returns an absolute path to the given module path.\r\n * Module path should be relative, either path to a file or a directory.\r\n *\r\n * This fn allows to calculate an absolute path for some global static values, such as\r\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\r\n * See ImportMetaBinding::code_generation for the usage.\r\n */\r\nfunction resolveAbsolutePath(modulePath?: string): string {\r\n  if (modulePath) {\r\n    return path.join(ABSOLUTE_ROOT, modulePath)\r\n  }\r\n  return ABSOLUTE_ROOT\r\n}\r\nContext.prototype.P = resolveAbsolutePath\r\n"],"names":[],"mappings":"AAAA,oDAAoD,GAMpD,MAAM,OAAO,QAAQ;AAErB,MAAM,4BAA4B,KAAK,QAAQ,CAAC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAM,yBAAyB,KAAK,IAAI,CACtC,2BACA;AAEF,MAAM,eAAe,KAAK,OAAO,CAAC,YAAY;AAC9C,mGAAmG;AACnG,MAAM,gBAAgB,KAAK,OAAO,CAAC,YAAY;AAE/C;;;;;;;CAOC,GACD,SAAS,oBAAoB,UAAmB;IAC9C,IAAI,YAAY;QACd,OAAO,KAAK,IAAI,CAAC,eAAe;IAClC;IACA,OAAO;AACT;AACA,QAAQ,SAAS,CAAC,CAAC,GAAG","ignoreList":[0]}},
    {"offset": {"line": 566, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/node-wasm-utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"../shared/runtime-utils.ts\" />\r\n\r\nfunction readWebAssemblyAsResponse(path: string) {\r\n  const { createReadStream } = require('fs') as typeof import('fs')\r\n  const { Readable } = require('stream') as typeof import('stream')\r\n\r\n  const stream = createReadStream(path)\r\n\r\n  // @ts-ignore unfortunately there's a slight type mismatch with the stream.\r\n  return new Response(Readable.toWeb(stream), {\r\n    headers: {\r\n      'content-type': 'application/wasm',\r\n    },\r\n  })\r\n}\r\n\r\nasync function compileWebAssemblyFromPath(\r\n  path: string\r\n): Promise<WebAssembly.Module> {\r\n  const response = readWebAssemblyAsResponse(path)\r\n\r\n  return await WebAssembly.compileStreaming(response)\r\n}\r\n\r\nasync function instantiateWebAssemblyFromPath(\r\n  path: string,\r\n  importsObj: WebAssembly.Imports\r\n): Promise<Exports> {\r\n  const response = readWebAssemblyAsResponse(path)\r\n\r\n  const { instance } = await WebAssembly.instantiateStreaming(\r\n    response,\r\n    importsObj\r\n  )\r\n\r\n  return instance.exports\r\n}\r\n"],"names":[],"mappings":"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,SAAS,0BAA0B,IAAY;IAC7C,MAAM,EAAE,gBAAgB,EAAE,GAAG,QAAQ;IACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;IAE7B,MAAM,SAAS,iBAAiB;IAEhC,2EAA2E;IAC3E,OAAO,IAAI,SAAS,SAAS,KAAK,CAAC,SAAS;QAC1C,SAAS;YACP,gBAAgB;QAClB;IACF;AACF;AAEA,eAAe,2BACb,IAAY;IAEZ,MAAM,WAAW,0BAA0B;IAE3C,OAAO,MAAM,YAAY,gBAAgB,CAAC;AAC5C;AAEA,eAAe,+BACb,IAAY,EACZ,UAA+B;IAE/B,MAAM,WAAW,0BAA0B;IAE3C,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,oBAAoB,CACzD,UACA;IAGF,OAAO,SAAS,OAAO;AACzB","ignoreList":[0]}},
    {"offset": {"line": 587, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/nodejs/runtime.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n/// <reference path=\"../shared/runtime-utils.ts\" />\r\n/// <reference path=\"../shared-node/base-externals-utils.ts\" />\r\n/// <reference path=\"../shared-node/node-externals-utils.ts\" />\r\n/// <reference path=\"../shared-node/node-wasm-utils.ts\" />\r\n\r\nenum SourceType {\r\n  /**\r\n   * The module was instantiated because it was included in an evaluated chunk's\r\n   * runtime.\r\n   * SourceData is a ChunkPath.\r\n   */\r\n  Runtime = 0,\r\n  /**\r\n   * The module was instantiated because a parent module imported it.\r\n   * SourceData is a ModuleId.\r\n   */\r\n  Parent = 1,\r\n}\r\n\r\ntype SourceData = ChunkPath | ModuleId\r\n\r\nprocess.env.TURBOPACK = '1'\r\n\r\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\r\n  R: ResolvePathFromModule\r\n  x: ExternalRequire\r\n  y: ExternalImport\r\n}\r\n\r\nconst nodeContextPrototype = Context.prototype as TurbopackNodeBuildContext\r\n\r\ntype ModuleFactory = (\r\n  this: Module['exports'],\r\n  context: TurbopackNodeBuildContext\r\n) => unknown\r\n\r\nconst url = require('url') as typeof import('url')\r\n\r\nconst moduleFactories: ModuleFactories = new Map()\r\nnodeContextPrototype.M = moduleFactories\r\nconst moduleCache: ModuleCache<Module> = Object.create(null)\r\nnodeContextPrototype.c = moduleCache\r\n\r\n/**\r\n * Returns an absolute path to the given module's id.\r\n */\r\nfunction resolvePathFromModule(\r\n  this: TurbopackBaseContext<Module>,\r\n  moduleId: string\r\n): string {\r\n  const exported = this.r(moduleId)\r\n  const exportedPath = exported?.default ?? exported\r\n  if (typeof exportedPath !== 'string') {\r\n    return exported as any\r\n  }\r\n\r\n  const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\r\n  const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\r\n\r\n  return url.pathToFileURL(resolved).href\r\n}\r\nnodeContextPrototype.R = resolvePathFromModule\r\n\r\nfunction loadRuntimeChunk(sourcePath: ChunkPath, chunkData: ChunkData): void {\r\n  if (typeof chunkData === 'string') {\r\n    loadRuntimeChunkPath(sourcePath, chunkData)\r\n  } else {\r\n    loadRuntimeChunkPath(sourcePath, chunkData.path)\r\n  }\r\n}\r\n\r\nconst loadedChunks = new Set<ChunkPath>()\r\nconst unsupportedLoadChunk = Promise.resolve(undefined)\r\nconst loadedChunk: Promise<void> = Promise.resolve(undefined)\r\nconst chunkCache = new Map<ChunkPath, Promise<void>>()\r\n\r\nfunction clearChunkCache() {\r\n  chunkCache.clear()\r\n}\r\n\r\nfunction loadRuntimeChunkPath(\r\n  sourcePath: ChunkPath,\r\n  chunkPath: ChunkPath\r\n): void {\r\n  if (!isJs(chunkPath)) {\r\n    // We only support loading JS chunks in Node.js.\r\n    // This branch can be hit when trying to load a CSS chunk.\r\n    return\r\n  }\r\n\r\n  if (loadedChunks.has(chunkPath)) {\r\n    return\r\n  }\r\n\r\n  try {\r\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\r\n    const chunkModules: CompressedModuleFactories = require(resolved)\r\n    installCompressedModuleFactories(chunkModules, 0, moduleFactories)\r\n    loadedChunks.add(chunkPath)\r\n  } catch (cause) {\r\n    let errorMessage = `Failed to load chunk ${chunkPath}`\r\n\r\n    if (sourcePath) {\r\n      errorMessage += ` from runtime for chunk ${sourcePath}`\r\n    }\r\n\r\n    const error = new Error(errorMessage, { cause })\r\n    error.name = 'ChunkLoadError'\r\n    throw error\r\n  }\r\n}\r\n\r\nfunction loadChunkAsync(\r\n  this: TurbopackBaseContext<Module>,\r\n  chunkData: ChunkData\r\n): Promise<void> {\r\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\r\n  if (!isJs(chunkPath)) {\r\n    // We only support loading JS chunks in Node.js.\r\n    // This branch can be hit when trying to load a CSS chunk.\r\n    return unsupportedLoadChunk\r\n  }\r\n\r\n  let entry = chunkCache.get(chunkPath)\r\n  if (entry === undefined) {\r\n    try {\r\n      // resolve to an absolute path to simplify `require` handling\r\n      const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\r\n      // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\r\n      // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\r\n      const chunkModules: CompressedModuleFactories = require(resolved)\r\n      installCompressedModuleFactories(chunkModules, 0, moduleFactories)\r\n      entry = loadedChunk\r\n    } catch (cause) {\r\n      const errorMessage = `Failed to load chunk ${chunkPath} from module ${this.m.id}`\r\n      const error = new Error(errorMessage, { cause })\r\n      error.name = 'ChunkLoadError'\r\n\r\n      // Cache the failure promise, future requests will also get this same rejection\r\n      entry = Promise.reject(error)\r\n    }\r\n    chunkCache.set(chunkPath, entry)\r\n  }\r\n  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\r\n  return entry\r\n}\r\ncontextPrototype.l = loadChunkAsync\r\n\r\nfunction loadChunkAsyncByUrl(\r\n  this: TurbopackBaseContext<Module>,\r\n  chunkUrl: string\r\n) {\r\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\r\n  return loadChunkAsync.call(this, path)\r\n}\r\ncontextPrototype.L = loadChunkAsyncByUrl\r\n\r\nfunction loadWebAssembly(\r\n  chunkPath: ChunkPath,\r\n  _edgeModule: () => WebAssembly.Module,\r\n  imports: WebAssembly.Imports\r\n) {\r\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\r\n\r\n  return instantiateWebAssemblyFromPath(resolved, imports)\r\n}\r\ncontextPrototype.w = loadWebAssembly\r\n\r\nfunction loadWebAssemblyModule(\r\n  chunkPath: ChunkPath,\r\n  _edgeModule: () => WebAssembly.Module\r\n) {\r\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\r\n\r\n  return compileWebAssemblyFromPath(resolved)\r\n}\r\ncontextPrototype.u = loadWebAssemblyModule\r\n\r\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\r\n  throw new Error('Worker blobs are not implemented yet for Node.js')\r\n}\r\n\r\nnodeContextPrototype.b = getWorkerBlobURL\r\n\r\nfunction instantiateModule(\r\n  id: ModuleId,\r\n  sourceType: SourceType,\r\n  sourceData: SourceData\r\n): Module {\r\n  const moduleFactory = moduleFactories.get(id)\r\n  if (typeof moduleFactory !== 'function') {\r\n    // This can happen if modules incorrectly handle HMR disposes/updates,\r\n    // e.g. when they keep a `setTimeout` around which still executes old code\r\n    // and contains e.g. a `require(\"something\")` call.\r\n    let instantiationReason: string\r\n    switch (sourceType) {\r\n      case SourceType.Runtime:\r\n        instantiationReason = `as a runtime entry of chunk ${sourceData}`\r\n        break\r\n      case SourceType.Parent:\r\n        instantiationReason = `because it was required from module ${sourceData}`\r\n        break\r\n      default:\r\n        invariant(\r\n          sourceType,\r\n          (sourceType) => `Unknown source type: ${sourceType}`\r\n        )\r\n    }\r\n    throw new Error(\r\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available.`\r\n    )\r\n  }\r\n\r\n  const module: Module = createModuleObject(id)\r\n  const exports = module.exports\r\n  moduleCache[id] = module\r\n\r\n  const context = new (Context as any as ContextConstructor<Module>)(\r\n    module,\r\n    exports\r\n  )\r\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\r\n  try {\r\n    moduleFactory(context, module, exports)\r\n  } catch (error) {\r\n    module.error = error as any\r\n    throw error\r\n  }\r\n\r\n  module.loaded = true\r\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\r\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\r\n    interopEsm(module.exports, module.namespaceObject)\r\n  }\r\n\r\n  return module\r\n}\r\n\r\n/**\r\n * Retrieves a module from the cache, or instantiate it if it is not cached.\r\n */\r\n// @ts-ignore\r\nfunction getOrInstantiateModuleFromParent(\r\n  id: ModuleId,\r\n  sourceModule: Module\r\n): Module {\r\n  const module = moduleCache[id]\r\n\r\n  if (module) {\r\n    if (module.error) {\r\n      throw module.error\r\n    }\r\n\r\n    return module\r\n  }\r\n\r\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\r\n}\r\n\r\n/**\r\n * Instantiates a runtime module.\r\n */\r\nfunction instantiateRuntimeModule(\r\n  chunkPath: ChunkPath,\r\n  moduleId: ModuleId\r\n): Module {\r\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\r\n}\r\n\r\n/**\r\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\r\n */\r\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\r\nfunction getOrInstantiateRuntimeModule(\r\n  chunkPath: ChunkPath,\r\n  moduleId: ModuleId\r\n): Module {\r\n  const module = moduleCache[moduleId]\r\n  if (module) {\r\n    if (module.error) {\r\n      throw module.error\r\n    }\r\n    return module\r\n  }\r\n\r\n  return instantiateRuntimeModule(chunkPath, moduleId)\r\n}\r\n\r\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\r\n/**\r\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\r\n */\r\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\r\n  return regexJsUrl.test(chunkUrlOrPath)\r\n}\r\n\r\nmodule.exports = (sourcePath: ChunkPath) => ({\r\n  m: (id: ModuleId) => getOrInstantiateRuntimeModule(sourcePath, id),\r\n  c: (chunkData: ChunkData) => loadRuntimeChunk(sourcePath, chunkData),\r\n})\r\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}