module.exports = [
"[project]/node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CommunicationLayerPreference",
    ()=>jo,
    "ConnectionStatus",
    ()=>Eo,
    "DEFAULT_SERVER_URL",
    ()=>fo,
    "EventType",
    ()=>So,
    "MessageType",
    ()=>ko,
    "MetaMaskSDK",
    ()=>rf,
    "MetaMaskSDKEvent",
    ()=>zu,
    "PROVIDER_UPDATE_TYPE",
    ()=>hh,
    "PlatformType",
    ()=>Uo,
    "SDKProvider",
    ()=>Gu,
    "default",
    ()=>rf
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$node$2d$ponyfill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cross-fetch/dist/node-ponyfill.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/sdk/node_modules/debug/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/sdk-analytics/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter2$2f$lib$2f$eventemitter2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/eventemitter2/lib/eventemitter2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/validate.js [app-ssr] (ecmascript) <export default as validate>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/v4.js [app-ssr] (ecmascript) <export default as v4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
;
;
function c(e, t, n, r) {
    return new (n || (n = Promise))(function(i, o) {
        function s(e) {
            try {
                c(r.next(e));
            } catch (e) {
                o(e);
            }
        }
        function a(e) {
            try {
                c(r.throw(e));
            } catch (e) {
                o(e);
            }
        }
        function c(e) {
            var t;
            e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n(function(e) {
                e(t);
            })).then(s, a);
        }
        c((r = r.apply(e, t || [])).next());
    });
}
"function" == typeof SuppressedError && SuppressedError;
var l = ("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable", d = [], u = [], h = "undefined" != typeof Uint8Array ? Uint8Array : Array, f = !1;
function p() {
    f = !0;
    for(var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0; t < 64; ++t)d[t] = e[t], u[e.charCodeAt(t)] = t;
    u["-".charCodeAt(0)] = 62, u["_".charCodeAt(0)] = 63;
}
function g(e, t, n) {
    for(var r, i, o = [], s = t; s < n; s += 3)r = (e[s] << 16) + (e[s + 1] << 8) + e[s + 2], o.push(d[(i = r) >> 18 & 63] + d[i >> 12 & 63] + d[i >> 6 & 63] + d[63 & i]);
    return o.join("");
}
function m(e) {
    var t;
    f || p();
    for(var n = e.length, r = n % 3, i = "", o = [], s = 16383, a = 0, c = n - r; a < c; a += s)o.push(g(e, a, a + s > c ? c : a + s));
    return 1 === r ? (t = e[n - 1], i += d[t >> 2], i += d[t << 4 & 63], i += "==") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], i += d[t >> 10], i += d[t >> 4 & 63], i += d[t << 2 & 63], i += "="), o.push(i), o.join("");
}
function y(e, t, n, r, i) {
    var o, s, a = 8 * i - r - 1, c = (1 << a) - 1, l = c >> 1, d = -7, u = n ? i - 1 : 0, h = n ? -1 : 1, f = e[t + u];
    for(u += h, o = f & (1 << -d) - 1, f >>= -d, d += a; d > 0; o = 256 * o + e[t + u], u += h, d -= 8);
    for(s = o & (1 << -d) - 1, o >>= -d, d += r; d > 0; s = 256 * s + e[t + u], u += h, d -= 8);
    if (0 === o) o = 1 - l;
    else {
        if (o === c) return s ? NaN : 1 / 0 * (f ? -1 : 1);
        s += Math.pow(2, r), o -= l;
    }
    return (f ? -1 : 1) * s * Math.pow(2, o - r);
}
function v(e, t, n, r, i, o) {
    var s, a, c, l = 8 * o - i - 1, d = (1 << l) - 1, u = d >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : o - 1, p = r ? 1 : -1, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = d) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (t += s + u >= 1 ? h / c : h * Math.pow(2, 1 - u)) * c >= 2 && (s++, c /= 2), s + u >= d ? (a = 0, s = d) : s + u >= 1 ? (a = (t * c - 1) * Math.pow(2, i), s += u) : (a = t * Math.pow(2, u - 1) * Math.pow(2, i), s = 0)); i >= 8; e[n + f] = 255 & a, f += p, a /= 256, i -= 8);
    for(s = s << i | a, l += i; l > 0; e[n + f] = 255 & s, f += p, s /= 256, l -= 8);
    e[n + f - p] |= 128 * g;
}
var b = {}.toString, w = Array.isArray || function(e) {
    return "[object Array]" == b.call(e);
};
C.TYPED_ARRAY_SUPPORT = void 0 === l.TYPED_ARRAY_SUPPORT || l.TYPED_ARRAY_SUPPORT;
var E = S();
function S() {
    return C.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function _(e, t) {
    if (S() < t) throw new RangeError("Invalid typed array length");
    return C.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = C.prototype : (null === e && (e = new C(t)), e.length = t), e;
}
function C(e, t, n) {
    if (!(C.TYPED_ARRAY_SUPPORT || this instanceof C)) return new C(e, t, n);
    if ("number" == typeof e) {
        if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
        return x(this, e);
    }
    return k(this, e, t, n);
}
function k(e, t, n, r) {
    if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
    return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function(e, t, n, r) {
        if (t.byteLength, n < 0 || t.byteLength < n) throw new RangeError("'offset' is out of bounds");
        if (t.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds");
        t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r);
        C.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = C.prototype : e = M(e, t);
        return e;
    }(e, t, n, r) : "string" == typeof t ? function(e, t, n) {
        "string" == typeof n && "" !== n || (n = "utf8");
        if (!C.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding');
        var r = 0 | R(t, n);
        e = _(e, r);
        var i = e.write(t, n);
        i !== r && (e = e.slice(0, i));
        return e;
    }(e, t, n) : function(e, t) {
        if (T(t)) {
            var n = 0 | I(t.length);
            return 0 === (e = _(e, n)).length || t.copy(e, 0, 0, n), e;
        }
        if (t) {
            if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || (r = t.length) != r ? _(e, 0) : M(e, t);
            if ("Buffer" === t.type && w(t.data)) return M(e, t.data);
        }
        var r;
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }(e, t);
}
function A(e) {
    if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
    if (e < 0) throw new RangeError('"size" argument must not be negative');
}
function x(e, t) {
    if (A(t), e = _(e, t < 0 ? 0 : 0 | I(t)), !C.TYPED_ARRAY_SUPPORT) for(var n = 0; n < t; ++n)e[n] = 0;
    return e;
}
function M(e, t) {
    var n = t.length < 0 ? 0 : 0 | I(t.length);
    e = _(e, n);
    for(var r = 0; r < n; r += 1)e[r] = 255 & t[r];
    return e;
}
function I(e) {
    if (e >= S()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S().toString(16) + " bytes");
    return 0 | e;
}
function T(e) {
    return !(null == e || !e._isBuffer);
}
function R(e, t) {
    if (T(e)) return e.length;
    if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
    "string" != typeof e && (e = "" + e);
    var n = e.length;
    if (0 === n) return 0;
    for(var r = !1;;)switch(t){
        case "ascii":
        case "latin1":
        case "binary":
            return n;
        case "utf8":
        case "utf-8":
        case void 0:
            return ie(e).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return 2 * n;
        case "hex":
            return n >>> 1;
        case "base64":
            return oe(e).length;
        default:
            if (r) return ie(e).length;
            t = ("" + t).toLowerCase(), r = !0;
    }
}
function P(e, t, n) {
    var r = !1;
    if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
    if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
    if ((n >>>= 0) <= (t >>>= 0)) return "";
    for(e || (e = "utf8");;)switch(e){
        case "hex":
            return V(this, t, n);
        case "utf8":
        case "utf-8":
            return F(this, t, n);
        case "ascii":
            return q(this, t, n);
        case "latin1":
        case "binary":
            return W(this, t, n);
        case "base64":
            return H(this, t, n);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return G(this, t, n);
        default:
            if (r) throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), r = !0;
    }
}
function O(e, t, n) {
    var r = e[t];
    e[t] = e[n], e[n] = r;
}
function N(e, t, n, r, i) {
    if (0 === e.length) return -1;
    if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
        if (i) return -1;
        n = e.length - 1;
    } else if (n < 0) {
        if (!i) return -1;
        n = 0;
    }
    if ("string" == typeof t && (t = C.from(t, r)), T(t)) return 0 === t.length ? -1 : L(e, t, n, r, i);
    if ("number" == typeof t) return t &= 255, C.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : L(e, [
        t
    ], n, r, i);
    throw new TypeError("val must be string, number or Buffer");
}
function L(e, t, n, r, i) {
    var o, s = 1, a = e.length, c = t.length;
    if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
        if (e.length < 2 || t.length < 2) return -1;
        s = 2, a /= 2, c /= 2, n /= 2;
    }
    function l(e, t) {
        return 1 === s ? e[t] : e.readUInt16BE(t * s);
    }
    if (i) {
        var d = -1;
        for(o = n; o < a; o++)if (l(e, o) === l(t, -1 === d ? 0 : o - d)) {
            if (-1 === d && (d = o), o - d + 1 === c) return d * s;
        } else -1 !== d && (o -= o - d), d = -1;
    } else for(n + c > a && (n = a - c), o = n; o >= 0; o--){
        for(var u = !0, h = 0; h < c; h++)if (l(e, o + h) !== l(t, h)) {
            u = !1;
            break;
        }
        if (u) return o;
    }
    return -1;
}
function D(e, t, n, r) {
    n = Number(n) || 0;
    var i = e.length - n;
    r ? (r = Number(r)) > i && (r = i) : r = i;
    var o = t.length;
    if (o % 2 != 0) throw new TypeError("Invalid hex string");
    r > o / 2 && (r = o / 2);
    for(var s = 0; s < r; ++s){
        var a = parseInt(t.substr(2 * s, 2), 16);
        if (isNaN(a)) return s;
        e[n + s] = a;
    }
    return s;
}
function $(e, t, n, r) {
    return se(ie(t, e.length - n), e, n, r);
}
function B(e, t, n, r) {
    return se(function(e) {
        for(var t = [], n = 0; n < e.length; ++n)t.push(255 & e.charCodeAt(n));
        return t;
    }(t), e, n, r);
}
function K(e, t, n, r) {
    return B(e, t, n, r);
}
function j(e, t, n, r) {
    return se(oe(t), e, n, r);
}
function U(e, t, n, r) {
    return se(function(e, t) {
        for(var n, r, i, o = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)r = (n = e.charCodeAt(s)) >> 8, i = n % 256, o.push(i), o.push(r);
        return o;
    }(t, e.length - n), e, n, r);
}
function H(e, t, n) {
    return 0 === t && n === e.length ? m(e) : m(e.slice(t, n));
}
function F(e, t, n) {
    n = Math.min(e.length, n);
    for(var r = [], i = t; i < n;){
        var o, s, a, c, l = e[i], d = null, u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
        if (i + u <= n) switch(u){
            case 1:
                l < 128 && (d = l);
                break;
            case 2:
                128 == (192 & (o = e[i + 1])) && (c = (31 & l) << 6 | 63 & o) > 127 && (d = c);
                break;
            case 3:
                o = e[i + 1], s = e[i + 2], 128 == (192 & o) && 128 == (192 & s) && (c = (15 & l) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (c < 55296 || c > 57343) && (d = c);
                break;
            case 4:
                o = e[i + 1], s = e[i + 2], a = e[i + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (c = (15 & l) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && c < 1114112 && (d = c);
        }
        null === d ? (d = 65533, u = 1) : d > 65535 && (d -= 65536, r.push(d >>> 10 & 1023 | 55296), d = 56320 | 1023 & d), r.push(d), i += u;
    }
    return function(e) {
        var t = e.length;
        if (t <= z) return String.fromCharCode.apply(String, e);
        var n = "", r = 0;
        for(; r < t;)n += String.fromCharCode.apply(String, e.slice(r, r += z));
        return n;
    }(r);
}
C.poolSize = 8192, C._augment = function(e) {
    return e.__proto__ = C.prototype, e;
}, C.from = function(e, t, n) {
    return k(null, e, t, n);
}, C.TYPED_ARRAY_SUPPORT && (C.prototype.__proto__ = Uint8Array.prototype, C.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && C[Symbol.species]), C.alloc = function(e, t, n) {
    return function(e, t, n, r) {
        return A(t), t <= 0 ? _(e, t) : void 0 !== n ? "string" == typeof r ? _(e, t).fill(n, r) : _(e, t).fill(n) : _(e, t);
    }(null, e, t, n);
}, C.allocUnsafe = function(e) {
    return x(null, e);
}, C.allocUnsafeSlow = function(e) {
    return x(null, e);
}, C.isBuffer = ae, C.compare = function(e, t) {
    if (!T(e) || !T(t)) throw new TypeError("Arguments must be Buffers");
    if (e === t) return 0;
    for(var n = e.length, r = t.length, i = 0, o = Math.min(n, r); i < o; ++i)if (e[i] !== t[i]) {
        n = e[i], r = t[i];
        break;
    }
    return n < r ? -1 : r < n ? 1 : 0;
}, C.isEncoding = function(e) {
    switch(String(e).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1;
    }
}, C.concat = function(e, t) {
    if (!w(e)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === e.length) return C.alloc(0);
    var n;
    if (void 0 === t) for(t = 0, n = 0; n < e.length; ++n)t += e[n].length;
    var r = C.allocUnsafe(t), i = 0;
    for(n = 0; n < e.length; ++n){
        var o = e[n];
        if (!T(o)) throw new TypeError('"list" argument must be an Array of Buffers');
        o.copy(r, i), i += o.length;
    }
    return r;
}, C.byteLength = R, C.prototype._isBuffer = !0, C.prototype.swap16 = function() {
    var e = this.length;
    if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var t = 0; t < e; t += 2)O(this, t, t + 1);
    return this;
}, C.prototype.swap32 = function() {
    var e = this.length;
    if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var t = 0; t < e; t += 4)O(this, t, t + 3), O(this, t + 1, t + 2);
    return this;
}, C.prototype.swap64 = function() {
    var e = this.length;
    if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var t = 0; t < e; t += 8)O(this, t, t + 7), O(this, t + 1, t + 6), O(this, t + 2, t + 5), O(this, t + 3, t + 4);
    return this;
}, C.prototype.toString = function() {
    var e = 0 | this.length;
    return 0 === e ? "" : 0 === arguments.length ? F(this, 0, e) : P.apply(this, arguments);
}, C.prototype.equals = function(e) {
    if (!T(e)) throw new TypeError("Argument must be a Buffer");
    return this === e || 0 === C.compare(this, e);
}, C.prototype.inspect = function() {
    var e = "";
    return this.length > 0 && (e = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e += " ... ")), "<Buffer " + e + ">";
}, C.prototype.compare = function(e, t, n, r, i) {
    if (!T(e)) throw new TypeError("Argument must be a Buffer");
    if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length) throw new RangeError("out of range index");
    if (r >= i && t >= n) return 0;
    if (r >= i) return -1;
    if (t >= n) return 1;
    if (this === e) return 0;
    for(var o = (i >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0), a = Math.min(o, s), c = this.slice(r, i), l = e.slice(t, n), d = 0; d < a; ++d)if (c[d] !== l[d]) {
        o = c[d], s = l[d];
        break;
    }
    return o < s ? -1 : s < o ? 1 : 0;
}, C.prototype.includes = function(e, t, n) {
    return -1 !== this.indexOf(e, t, n);
}, C.prototype.indexOf = function(e, t, n) {
    return N(this, e, t, n, !0);
}, C.prototype.lastIndexOf = function(e, t, n) {
    return N(this, e, t, n, !1);
}, C.prototype.write = function(e, t, n, r) {
    if (void 0 === t) r = "utf8", n = this.length, t = 0;
    else if (void 0 === n && "string" == typeof t) r = t, n = this.length, t = 0;
    else {
        if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0);
    }
    var i = this.length - t;
    if ((void 0 === n || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    r || (r = "utf8");
    for(var o = !1;;)switch(r){
        case "hex":
            return D(this, e, t, n);
        case "utf8":
        case "utf-8":
            return $(this, e, t, n);
        case "ascii":
            return B(this, e, t, n);
        case "latin1":
        case "binary":
            return K(this, e, t, n);
        case "base64":
            return j(this, e, t, n);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return U(this, e, t, n);
        default:
            if (o) throw new TypeError("Unknown encoding: " + r);
            r = ("" + r).toLowerCase(), o = !0;
    }
}, C.prototype.toJSON = function() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
var z = 4096;
function q(e, t, n) {
    var r = "";
    n = Math.min(e.length, n);
    for(var i = t; i < n; ++i)r += String.fromCharCode(127 & e[i]);
    return r;
}
function W(e, t, n) {
    var r = "";
    n = Math.min(e.length, n);
    for(var i = t; i < n; ++i)r += String.fromCharCode(e[i]);
    return r;
}
function V(e, t, n) {
    var r = e.length;
    (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
    for(var i = "", o = t; o < n; ++o)i += re(e[o]);
    return i;
}
function G(e, t, n) {
    for(var r = e.slice(t, n), i = "", o = 0; o < r.length; o += 2)i += String.fromCharCode(r[o] + 256 * r[o + 1]);
    return i;
}
function Y(e, t, n) {
    if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
    if (e + t > n) throw new RangeError("Trying to access beyond buffer length");
}
function Z(e, t, n, r, i, o) {
    if (!T(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
    if (n + r > e.length) throw new RangeError("Index out of range");
}
function J(e, t, n, r) {
    t < 0 && (t = 65535 + t + 1);
    for(var i = 0, o = Math.min(e.length - n, 2); i < o; ++i)e[n + i] = (t & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i);
}
function Q(e, t, n, r) {
    t < 0 && (t = 4294967295 + t + 1);
    for(var i = 0, o = Math.min(e.length - n, 4); i < o; ++i)e[n + i] = t >>> 8 * (r ? i : 3 - i) & 255;
}
function X(e, t, n, r, i, o) {
    if (n + r > e.length) throw new RangeError("Index out of range");
    if (n < 0) throw new RangeError("Index out of range");
}
function ee(e, t, n, r, i) {
    return i || X(e, 0, n, 4), v(e, t, n, r, 23, 4), n + 4;
}
function te(e, t, n, r, i) {
    return i || X(e, 0, n, 8), v(e, t, n, r, 52, 8), n + 8;
}
C.prototype.slice = function(e, t) {
    var n, r = this.length;
    if ((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e), C.TYPED_ARRAY_SUPPORT) (n = this.subarray(e, t)).__proto__ = C.prototype;
    else {
        var i = t - e;
        n = new C(i, void 0);
        for(var o = 0; o < i; ++o)n[o] = this[o + e];
    }
    return n;
}, C.prototype.readUIntLE = function(e, t, n) {
    e |= 0, t |= 0, n || Y(e, t, this.length);
    for(var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i;
    return r;
}, C.prototype.readUIntBE = function(e, t, n) {
    e |= 0, t |= 0, n || Y(e, t, this.length);
    for(var r = this[e + --t], i = 1; t > 0 && (i *= 256);)r += this[e + --t] * i;
    return r;
}, C.prototype.readUInt8 = function(e, t) {
    return t || Y(e, 1, this.length), this[e];
}, C.prototype.readUInt16LE = function(e, t) {
    return t || Y(e, 2, this.length), this[e] | this[e + 1] << 8;
}, C.prototype.readUInt16BE = function(e, t) {
    return t || Y(e, 2, this.length), this[e] << 8 | this[e + 1];
}, C.prototype.readUInt32LE = function(e, t) {
    return t || Y(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];
}, C.prototype.readUInt32BE = function(e, t) {
    return t || Y(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
}, C.prototype.readIntLE = function(e, t, n) {
    e |= 0, t |= 0, n || Y(e, t, this.length);
    for(var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i;
    return r >= (i *= 128) && (r -= Math.pow(2, 8 * t)), r;
}, C.prototype.readIntBE = function(e, t, n) {
    e |= 0, t |= 0, n || Y(e, t, this.length);
    for(var r = t, i = 1, o = this[e + --r]; r > 0 && (i *= 256);)o += this[e + --r] * i;
    return o >= (i *= 128) && (o -= Math.pow(2, 8 * t)), o;
}, C.prototype.readInt8 = function(e, t) {
    return t || Y(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
}, C.prototype.readInt16LE = function(e, t) {
    t || Y(e, 2, this.length);
    var n = this[e] | this[e + 1] << 8;
    return 32768 & n ? 4294901760 | n : n;
}, C.prototype.readInt16BE = function(e, t) {
    t || Y(e, 2, this.length);
    var n = this[e + 1] | this[e] << 8;
    return 32768 & n ? 4294901760 | n : n;
}, C.prototype.readInt32LE = function(e, t) {
    return t || Y(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
}, C.prototype.readInt32BE = function(e, t) {
    return t || Y(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
}, C.prototype.readFloatLE = function(e, t) {
    return t || Y(e, 4, this.length), y(this, e, !0, 23, 4);
}, C.prototype.readFloatBE = function(e, t) {
    return t || Y(e, 4, this.length), y(this, e, !1, 23, 4);
}, C.prototype.readDoubleLE = function(e, t) {
    return t || Y(e, 8, this.length), y(this, e, !0, 52, 8);
}, C.prototype.readDoubleBE = function(e, t) {
    return t || Y(e, 8, this.length), y(this, e, !1, 52, 8);
}, C.prototype.writeUIntLE = function(e, t, n, r) {
    (e = +e, t |= 0, n |= 0, r) || Z(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
    var i = 1, o = 0;
    for(this[t] = 255 & e; ++o < n && (i *= 256);)this[t + o] = e / i & 255;
    return t + n;
}, C.prototype.writeUIntBE = function(e, t, n, r) {
    (e = +e, t |= 0, n |= 0, r) || Z(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
    var i = n - 1, o = 1;
    for(this[t + i] = 255 & e; --i >= 0 && (o *= 256);)this[t + i] = e / o & 255;
    return t + n;
}, C.prototype.writeUInt8 = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 1, 255, 0), C.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1;
}, C.prototype.writeUInt16LE = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 2, 65535, 0), C.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : J(this, e, t, !0), t + 2;
}, C.prototype.writeUInt16BE = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 2, 65535, 0), C.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : J(this, e, t, !1), t + 2;
}, C.prototype.writeUInt32LE = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 4, 4294967295, 0), C.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : Q(this, e, t, !0), t + 4;
}, C.prototype.writeUInt32BE = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 4, 4294967295, 0), C.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : Q(this, e, t, !1), t + 4;
}, C.prototype.writeIntLE = function(e, t, n, r) {
    if (e = +e, t |= 0, !r) {
        var i = Math.pow(2, 8 * n - 1);
        Z(this, e, t, n, i - 1, -i);
    }
    var o = 0, s = 1, a = 0;
    for(this[t] = 255 & e; ++o < n && (s *= 256);)e < 0 && 0 === a && 0 !== this[t + o - 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
    return t + n;
}, C.prototype.writeIntBE = function(e, t, n, r) {
    if (e = +e, t |= 0, !r) {
        var i = Math.pow(2, 8 * n - 1);
        Z(this, e, t, n, i - 1, -i);
    }
    var o = n - 1, s = 1, a = 0;
    for(this[t + o] = 255 & e; --o >= 0 && (s *= 256);)e < 0 && 0 === a && 0 !== this[t + o + 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
    return t + n;
}, C.prototype.writeInt8 = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 1, 127, -128), C.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1;
}, C.prototype.writeInt16LE = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 2, 32767, -32768), C.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : J(this, e, t, !0), t + 2;
}, C.prototype.writeInt16BE = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 2, 32767, -32768), C.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : J(this, e, t, !1), t + 2;
}, C.prototype.writeInt32LE = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 4, 2147483647, -2147483648), C.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : Q(this, e, t, !0), t + 4;
}, C.prototype.writeInt32BE = function(e, t, n) {
    return e = +e, t |= 0, n || Z(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), C.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : Q(this, e, t, !1), t + 4;
}, C.prototype.writeFloatLE = function(e, t, n) {
    return ee(this, e, t, !0, n);
}, C.prototype.writeFloatBE = function(e, t, n) {
    return ee(this, e, t, !1, n);
}, C.prototype.writeDoubleLE = function(e, t, n) {
    return te(this, e, t, !0, n);
}, C.prototype.writeDoubleBE = function(e, t, n) {
    return te(this, e, t, !1, n);
}, C.prototype.copy = function(e, t, n, r) {
    if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0;
    if (0 === e.length || 0 === this.length) return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
    if (r < 0) throw new RangeError("sourceEnd out of bounds");
    r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
    var i, o = r - n;
    if (this === e && n < t && t < r) for(i = o - 1; i >= 0; --i)e[i + t] = this[i + n];
    else if (o < 1e3 || !C.TYPED_ARRAY_SUPPORT) for(i = 0; i < o; ++i)e[i + t] = this[i + n];
    else Uint8Array.prototype.set.call(e, this.subarray(n, n + o), t);
    return o;
}, C.prototype.fill = function(e, t, n, r) {
    if ("string" == typeof e) {
        if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) {
            var i = e.charCodeAt(0);
            i < 256 && (e = i);
        }
        if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string");
        if ("string" == typeof r && !C.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
    } else "number" == typeof e && (e &= 255);
    if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
    if (n <= t) return this;
    var o;
    if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e) for(o = t; o < n; ++o)this[o] = e;
    else {
        var s = T(e) ? e : ie(new C(e, r).toString()), a = s.length;
        for(o = 0; o < n - t; ++o)this[o + t] = s[o % a];
    }
    return this;
};
var ne = /[^+\/0-9A-Za-z-_]/g;
function re(e) {
    return e < 16 ? "0" + e.toString(16) : e.toString(16);
}
function ie(e, t) {
    var n;
    t = t || 1 / 0;
    for(var r = e.length, i = null, o = [], s = 0; s < r; ++s){
        if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
            if (!i) {
                if (n > 56319) {
                    (t -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                }
                if (s + 1 === r) {
                    (t -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                }
                i = n;
                continue;
            }
            if (n < 56320) {
                (t -= 3) > -1 && o.push(239, 191, 189), i = n;
                continue;
            }
            n = 65536 + (i - 55296 << 10 | n - 56320);
        } else i && (t -= 3) > -1 && o.push(239, 191, 189);
        if (i = null, n < 128) {
            if ((t -= 1) < 0) break;
            o.push(n);
        } else if (n < 2048) {
            if ((t -= 2) < 0) break;
            o.push(n >> 6 | 192, 63 & n | 128);
        } else if (n < 65536) {
            if ((t -= 3) < 0) break;
            o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);
        } else {
            if (!(n < 1114112)) throw new Error("Invalid code point");
            if ((t -= 4) < 0) break;
            o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);
        }
    }
    return o;
}
function oe(e) {
    return function(e) {
        var t, n, r, i, o, s;
        f || p();
        var a = e.length;
        if (a % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        o = "=" === e[a - 2] ? 2 : "=" === e[a - 1] ? 1 : 0, s = new h(3 * a / 4 - o), r = o > 0 ? a - 4 : a;
        var c = 0;
        for(t = 0, n = 0; t < r; t += 4, n += 3)i = u[e.charCodeAt(t)] << 18 | u[e.charCodeAt(t + 1)] << 12 | u[e.charCodeAt(t + 2)] << 6 | u[e.charCodeAt(t + 3)], s[c++] = i >> 16 & 255, s[c++] = i >> 8 & 255, s[c++] = 255 & i;
        return 2 === o ? (i = u[e.charCodeAt(t)] << 2 | u[e.charCodeAt(t + 1)] >> 4, s[c++] = 255 & i) : 1 === o && (i = u[e.charCodeAt(t)] << 10 | u[e.charCodeAt(t + 1)] << 4 | u[e.charCodeAt(t + 2)] >> 2, s[c++] = i >> 8 & 255, s[c++] = 255 & i), s;
    }(function(e) {
        if ((e = (function(e) {
            return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
        })(e).replace(ne, "")).length < 2) return "";
        for(; e.length % 4 != 0;)e += "=";
        return e;
    }(e));
}
function se(e, t, n, r) {
    for(var i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i)t[i + n] = e[i];
    return i;
}
function ae(e) {
    return null != e && (!!e._isBuffer || ce(e) || function(e) {
        return "function" == typeof e.readFloatLE && "function" == typeof e.slice && ce(e.slice(0, 0));
    }(e));
}
function ce(e) {
    return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e);
}
var le = Object.freeze({
    __proto__: null,
    Buffer: C,
    INSPECT_MAX_BYTES: 50,
    SlowBuffer: function(e) {
        return +e != e && (e = 0), C.alloc(+e);
    },
    isBuffer: ae,
    kMaxLength: E
}), de = "undefined" != typeof globalThis ? globalThis : ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : ("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable";
function ue(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function he(e) {
    if (e.__esModule) return e;
    var t = e.default;
    if ("function" == typeof t) {
        var n = function e() {
            return this instanceof e ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
        };
        n.prototype = t.prototype;
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(e).forEach(function(t) {
        var r = Object.getOwnPropertyDescriptor(e, t);
        Object.defineProperty(n, t, r.get ? r : {
            enumerable: !0,
            get: function() {
                return e[t];
            }
        });
    }), n;
}
var fe = {}, pe = {}, ge = {};
function me(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`positive integer expected, not ${e}`);
}
function ye(e) {
    if ("boolean" != typeof e) throw new Error(`boolean expected, not ${e}`);
}
function ve(e) {
    return e instanceof Uint8Array || null != e && "object" == typeof e && "Uint8Array" === e.constructor.name;
}
function be(e, ...t) {
    if (!ve(e)) throw new Error("Uint8Array expected");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function we(e) {
    if ("function" != typeof e || "function" != typeof e.create) throw new Error("hash must be wrapped by utils.wrapConstructor");
    me(e.outputLen), me(e.blockLen);
}
function Ee(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function Se(e, t) {
    be(e);
    const n = t.outputLen;
    if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
Object.defineProperty(ge, "__esModule", {
    value: !0
}), ge.isBytes = ve, ge.number = me, ge.bool = ye, ge.bytes = be, ge.hash = we, ge.exists = Ee, ge.output = Se;
const _e = {
    number: me,
    bool: ye,
    bytes: be,
    hash: we,
    exists: Ee,
    output: Se
};
ge.default = _e, function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.wrapCipher = e.Hash = e.nextTick = e.isLE = e.createView = e.u32 = e.u16 = e.u8 = void 0, e.bytesToHex = r, e.hexToBytes = s, e.hexToNumber = a, e.bytesToNumberBE = function(e) {
        return a(r(e));
    }, e.numberToBytesBE = function(e, t) {
        return s(e.toString(16).padStart(2 * t, "0"));
    }, e.asyncLoop = async function(t, n, r) {
        let i = Date.now();
        for(let o = 0; o < t; o++){
            r(o);
            const t = Date.now() - i;
            t >= 0 && t < n || (await (0, e.nextTick)(), i += t);
        }
    }, e.utf8ToBytes = c, e.bytesToUtf8 = function(e) {
        return (new TextDecoder).decode(e);
    }, e.toBytes = function(e) {
        if ("string" == typeof e) e = c(e);
        else {
            if (!(0, t.isBytes)(e)) throw new Error("Uint8Array expected, got " + typeof e);
            e = d(e);
        }
        return e;
    }, e.concatBytes = function(...e) {
        let n = 0;
        for(let r = 0; r < e.length; r++){
            const i = e[r];
            (0, t.bytes)(i), n += i.length;
        }
        const r = new Uint8Array(n);
        for(let t = 0, n = 0; t < e.length; t++){
            const i = e[t];
            r.set(i, n), n += i.length;
        }
        return r;
    }, e.checkOpts = function(e, t) {
        if (null == t || "object" != typeof t) throw new Error("options must be defined");
        return Object.assign(e, t);
    }, e.equalBytes = function(e, t) {
        if (e.length !== t.length) return !1;
        let n = 0;
        for(let r = 0; r < e.length; r++)n |= e[r] ^ t[r];
        return 0 === n;
    }, e.setBigUint64 = l, e.u64Lengths = function(t, n) {
        const r = new Uint8Array(16), i = (0, e.createView)(r);
        return l(i, 0, BigInt(n ? n.length : 0), !0), l(i, 8, BigInt(t.length), !0), r;
    }, e.isAligned32 = function(e) {
        return e.byteOffset % 4 == 0;
    }, e.copyBytes = d, e.clean = function(...e) {
        for(let t = 0; t < e.length; t++)e[t].fill(0);
    };
    const t = ge;
    e.u8 = (e)=>new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    e.u16 = (e)=>new Uint16Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 2));
    e.u32 = (e)=>new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
    if (e.createView = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), e.isLE = 68 === new Uint8Array(new Uint32Array([
        287454020
    ]).buffer)[0], !e.isLE) throw new Error("Non little-endian hardware is not supported");
    const n = Array.from({
        length: 256
    }, (e, t)=>t.toString(16).padStart(2, "0"));
    function r(e) {
        (0, t.bytes)(e);
        let r = "";
        for(let t = 0; t < e.length; t++)r += n[e[t]];
        return r;
    }
    const i = {
        _0: 48,
        _9: 57,
        _A: 65,
        _F: 70,
        _a: 97,
        _f: 102
    };
    function o(e) {
        return e >= i._0 && e <= i._9 ? e - i._0 : e >= i._A && e <= i._F ? e - (i._A - 10) : e >= i._a && e <= i._f ? e - (i._a - 10) : void 0;
    }
    function s(e) {
        if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
        const t = e.length, n = t / 2;
        if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
        const r = new Uint8Array(n);
        for(let t = 0, i = 0; t < n; t++, i += 2){
            const n = o(e.charCodeAt(i)), s = o(e.charCodeAt(i + 1));
            if (void 0 === n || void 0 === s) {
                const t = e[i] + e[i + 1];
                throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + i);
            }
            r[t] = 16 * n + s;
        }
        return r;
    }
    function a(e) {
        if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
        return BigInt("" === e ? "0" : `0x${e}`);
    }
    function c(e) {
        if ("string" != typeof e) throw new Error("string expected, got " + typeof e);
        return new Uint8Array((new TextEncoder).encode(e));
    }
    e.nextTick = async ()=>{};
    e.Hash = class {
    };
    function l(e, t, n, r) {
        if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, n, r);
        const i = BigInt(32), o = BigInt(4294967295), s = Number(n >> i & o), a = Number(n & o), c = r ? 4 : 0, l = r ? 0 : 4;
        e.setUint32(t + c, s, r), e.setUint32(t + l, a, r);
    }
    function d(e) {
        return Uint8Array.from(e);
    }
    e.wrapCipher = (e, t)=>(Object.assign(t, e), t);
}(pe);
var Ce = {}, ke = {};
Object.defineProperty(ke, "__esModule", {
    value: !0
}), ke.AEAD_TAG_LENGTH = ke.XCHACHA20_NONCE_LENGTH = ke.CURVE25519_PUBLIC_KEY_SIZE = ke.ETH_PUBLIC_KEY_SIZE = ke.UNCOMPRESSED_PUBLIC_KEY_SIZE = ke.COMPRESSED_PUBLIC_KEY_SIZE = ke.SECRET_KEY_LENGTH = void 0, ke.SECRET_KEY_LENGTH = 32, ke.COMPRESSED_PUBLIC_KEY_SIZE = 33, ke.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65, ke.ETH_PUBLIC_KEY_SIZE = 64, ke.CURVE25519_PUBLIC_KEY_SIZE = 32, ke.XCHACHA20_NONCE_LENGTH = 24, ke.AEAD_TAG_LENGTH = 16, function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.ephemeralKeySize = e.symmetricNonceLength = e.symmetricAlgorithm = e.isHkdfKeyCompressed = e.isEphemeralKeyCompressed = e.ellipticCurve = e.ECIES_CONFIG = void 0;
    var t = ke, n = function() {
        this.ellipticCurve = "secp256k1", this.isEphemeralKeyCompressed = !1, this.isHkdfKeyCompressed = !1, this.symmetricAlgorithm = "aes-256-gcm", this.symmetricNonceLength = 16;
    };
    e.ECIES_CONFIG = new n;
    e.ellipticCurve = function() {
        return e.ECIES_CONFIG.ellipticCurve;
    };
    e.isEphemeralKeyCompressed = function() {
        return e.ECIES_CONFIG.isEphemeralKeyCompressed;
    };
    e.isHkdfKeyCompressed = function() {
        return e.ECIES_CONFIG.isHkdfKeyCompressed;
    };
    e.symmetricAlgorithm = function() {
        return e.ECIES_CONFIG.symmetricAlgorithm;
    };
    e.symmetricNonceLength = function() {
        return e.ECIES_CONFIG.symmetricNonceLength;
    };
    e.ephemeralKeySize = function() {
        var n = {
            secp256k1: e.ECIES_CONFIG.isEphemeralKeyCompressed ? t.COMPRESSED_PUBLIC_KEY_SIZE : t.UNCOMPRESSED_PUBLIC_KEY_SIZE,
            x25519: t.CURVE25519_PUBLIC_KEY_SIZE,
            ed25519: t.CURVE25519_PUBLIC_KEY_SIZE
        };
        if (e.ECIES_CONFIG.ellipticCurve in n) return n[e.ECIES_CONFIG.ellipticCurve];
        throw new Error("Not implemented");
    };
}(Ce);
var Ae = {}, xe = {}, Me = {}, Ie = {}, Te = {}, Re = {};
Object.defineProperty(Re, "__esModule", {
    value: !0
}), Re.crypto = void 0, Re.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.gcm = e.ctr = e.cbc = e.utils = void 0, e.randomBytes = i, e.getWebcryptoSubtle = o, e.managedNonce = function(e) {
        return (0, n.number)(e.nonceLength), (t, ...n)=>({
                encrypt (o, ...s) {
                    const { nonceLength: a } = e, c = i(a), l = e(t, c, ...n).encrypt(o, ...s), d = (0, r.concatBytes)(c, l);
                    return l.fill(0), d;
                },
                decrypt (r, ...i) {
                    const { nonceLength: o } = e, s = r.subarray(0, o), a = r.subarray(o);
                    return e(t, s, ...n).decrypt(a, ...i);
                }
            });
    };
    const t = Re, n = ge, r = pe;
    function i(e = 32) {
        if (t.crypto && "function" == typeof t.crypto.getRandomValues) return t.crypto.getRandomValues(new Uint8Array(e));
        if (t.crypto && "function" == typeof t.crypto.randomBytes) return t.crypto.randomBytes(e);
        throw new Error("crypto.getRandomValues must be defined");
    }
    function o() {
        if (t.crypto && "object" == typeof t.crypto.subtle && null != t.crypto.subtle) return t.crypto.subtle;
        throw new Error("crypto.subtle must be defined");
    }
    e.utils = {
        async encrypt (e, t, n, r) {
            const i = o(), s = await i.importKey("raw", e, t, !0, [
                "encrypt"
            ]), a = await i.encrypt(n, s, r);
            return new Uint8Array(a);
        },
        async decrypt (e, t, n, r) {
            const i = o(), s = await i.importKey("raw", e, t, !0, [
                "decrypt"
            ]), a = await i.decrypt(n, s, r);
            return new Uint8Array(a);
        }
    };
    const s = {
        CBC: "AES-CBC",
        CTR: "AES-CTR",
        GCM: "AES-GCM"
    };
    function a(t) {
        return (r, i, o)=>{
            (0, n.bytes)(r), (0, n.bytes)(i);
            const a = {
                name: t,
                length: 8 * r.length
            }, c = function(e, t, n) {
                if (e === s.CBC) return {
                    name: s.CBC,
                    iv: t
                };
                if (e === s.CTR) return {
                    name: s.CTR,
                    counter: t,
                    length: 64
                };
                if (e === s.GCM) return n ? {
                    name: s.GCM,
                    iv: t,
                    additionalData: n
                } : {
                    name: s.GCM,
                    iv: t
                };
                throw new Error("unknown aes block mode");
            }(t, i, o);
            return {
                encrypt: (t)=>((0, n.bytes)(t), e.utils.encrypt(r, a, c, t)),
                decrypt: (t)=>((0, n.bytes)(t), e.utils.decrypt(r, a, c, t))
            };
        };
    }
    e.cbc = a(s.CBC), e.ctr = a(s.CTR), e.gcm = a(s.GCM);
}(Te);
var Pe = {}, Oe = {}, Ne = {}, Le = {};
function De(e) {
    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`positive integer expected, not ${e}`);
}
function $e(e) {
    if ("boolean" != typeof e) throw new Error(`boolean expected, not ${e}`);
}
function Be(e) {
    return e instanceof Uint8Array || null != e && "object" == typeof e && "Uint8Array" === e.constructor.name;
}
function Ke(e, ...t) {
    if (!Be(e)) throw new Error("Uint8Array expected");
    if (t.length > 0 && !t.includes(e.length)) throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function je(e) {
    if ("function" != typeof e || "function" != typeof e.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
    De(e.outputLen), De(e.blockLen);
}
function Ue(e, t = !0) {
    if (e.destroyed) throw new Error("Hash instance has been destroyed");
    if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function He(e, t) {
    Ke(e);
    const n = t.outputLen;
    if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
Object.defineProperty(Le, "__esModule", {
    value: !0
}), Le.isBytes = Be, Le.number = De, Le.bool = $e, Le.bytes = Ke, Le.hash = je, Le.exists = Ue, Le.output = He;
const Fe = {
    number: De,
    bool: $e,
    bytes: Ke,
    hash: je,
    exists: Ue,
    output: He
};
Le.default = Fe;
var ze = {}, qe = {};
Object.defineProperty(qe, "__esModule", {
    value: !0
}), qe.crypto = void 0, qe.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.Hash = e.nextTick = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = void 0, e.isBytes = function(e) {
        return e instanceof Uint8Array || null != e && "object" == typeof e && "Uint8Array" === e.constructor.name;
    }, e.byteSwap32 = function(t) {
        for(let n = 0; n < t.length; n++)t[n] = (0, e.byteSwap)(t[n]);
    }, e.bytesToHex = function(e) {
        (0, n.bytes)(e);
        let t = "";
        for(let n = 0; n < e.length; n++)t += r[e[n]];
        return t;
    }, e.hexToBytes = function(e) {
        if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
        const t = e.length, n = t / 2;
        if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
        const r = new Uint8Array(n);
        for(let t = 0, i = 0; t < n; t++, i += 2){
            const n = o(e.charCodeAt(i)), s = o(e.charCodeAt(i + 1));
            if (void 0 === n || void 0 === s) {
                const t = e[i] + e[i + 1];
                throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + i);
            }
            r[t] = 16 * n + s;
        }
        return r;
    }, e.asyncLoop = async function(t, n, r) {
        let i = Date.now();
        for(let o = 0; o < t; o++){
            r(o);
            const t = Date.now() - i;
            t >= 0 && t < n || (await (0, e.nextTick)(), i += t);
        }
    }, e.utf8ToBytes = s, e.toBytes = a, e.concatBytes = function(...e) {
        let t = 0;
        for(let r = 0; r < e.length; r++){
            const i = e[r];
            (0, n.bytes)(i), t += i.length;
        }
        const r = new Uint8Array(t);
        for(let t = 0, n = 0; t < e.length; t++){
            const i = e[t];
            r.set(i, n), n += i.length;
        }
        return r;
    }, e.checkOpts = function(e, t) {
        if (void 0 !== t && "[object Object]" !== c.call(t)) throw new Error("Options should be object or undefined");
        return Object.assign(e, t);
    }, e.wrapConstructor = function(e) {
        const t = (t)=>e().update(a(t)).digest(), n = e();
        return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = ()=>e(), t;
    }, e.wrapConstructorWithOpts = function(e) {
        const t = (t, n)=>e(n).update(a(t)).digest(), n = e({});
        return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = (t)=>e(t), t;
    }, e.wrapXOFConstructorWithOpts = function(e) {
        const t = (t, n)=>e(n).update(a(t)).digest(), n = e({});
        return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = (t)=>e(t), t;
    }, e.randomBytes = function(e = 32) {
        if (t.crypto && "function" == typeof t.crypto.getRandomValues) return t.crypto.getRandomValues(new Uint8Array(e));
        if (t.crypto && "function" == typeof t.crypto.randomBytes) return t.crypto.randomBytes(e);
        throw new Error("crypto.getRandomValues must be defined");
    };
    const t = qe, n = Le;
    e.u8 = (e)=>new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    e.u32 = (e)=>new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
    e.createView = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength);
    e.rotr = (e, t)=>e << 32 - t | e >>> t;
    e.rotl = (e, t)=>e << t | e >>> 32 - t >>> 0, e.isLE = 68 === new Uint8Array(new Uint32Array([
        287454020
    ]).buffer)[0];
    e.byteSwap = (e)=>e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255, e.byteSwapIfBE = e.isLE ? (e)=>e : (t)=>(0, e.byteSwap)(t);
    const r = Array.from({
        length: 256
    }, (e, t)=>t.toString(16).padStart(2, "0"));
    const i = {
        _0: 48,
        _9: 57,
        _A: 65,
        _F: 70,
        _a: 97,
        _f: 102
    };
    function o(e) {
        return e >= i._0 && e <= i._9 ? e - i._0 : e >= i._A && e <= i._F ? e - (i._A - 10) : e >= i._a && e <= i._f ? e - (i._a - 10) : void 0;
    }
    function s(e) {
        if ("string" != typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
        return new Uint8Array((new TextEncoder).encode(e));
    }
    function a(e) {
        return "string" == typeof e && (e = s(e)), (0, n.bytes)(e), e;
    }
    e.nextTick = async ()=>{};
    e.Hash = class {
        clone() {
            return this._cloneInto();
        }
    };
    const c = {}.toString;
}(ze), Object.defineProperty(Ne, "__esModule", {
    value: !0
}), Ne.HashMD = Ne.Maj = Ne.Chi = void 0;
const We = Le, Ve = ze;
Ne.Chi = (e, t, n)=>e & t ^ ~e & n;
Ne.Maj = (e, t, n)=>e & t ^ e & n ^ t & n;
Ne.HashMD = class extends Ve.Hash {
    constructor(e, t, n, r){
        super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, Ve.createView)(this.buffer);
    }
    update(e) {
        (0, We.exists)(this);
        const { view: t, buffer: n, blockLen: r } = this, i = (e = (0, Ve.toBytes)(e)).length;
        for(let o = 0; o < i;){
            const s = Math.min(r - this.pos, i - o);
            if (s !== r) n.set(e.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === r && (this.process(t, 0), this.pos = 0);
            else {
                const t = (0, Ve.createView)(e);
                for(; r <= i - o; o += r)this.process(t, o);
            }
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        (0, We.exists)(this), (0, We.output)(e, this), this.finished = !0;
        const { buffer: t, view: n, blockLen: r, isLE: i } = this;
        let { pos: o } = this;
        t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0);
        for(let e = o; e < r; e++)t[e] = 0;
        !function(e, t, n, r) {
            if ("function" == typeof e.setBigUint64) return e.setBigUint64(t, n, r);
            const i = BigInt(32), o = BigInt(4294967295), s = Number(n >> i & o), a = Number(n & o), c = r ? 4 : 0, l = r ? 0 : 4;
            e.setUint32(t + c, s, r), e.setUint32(t + l, a, r);
        }(n, r - 8, BigInt(8 * this.length), i), this.process(n, 0);
        const s = (0, Ve.createView)(e), a = this.outputLen;
        if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const c = a / 4, l = this.get();
        if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
        for(let e = 0; e < c; e++)s.setUint32(4 * e, l[e], i);
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const n = e.slice(0, t);
        return this.destroy(), n;
    }
    _cloneInto(e) {
        e || (e = new this.constructor), e.set(...this.get());
        const { blockLen: t, buffer: n, length: r, finished: i, destroyed: o, pos: s } = this;
        return e.length = r, e.pos = s, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e;
    }
};
var Ge = {};
Object.defineProperty(Ge, "__esModule", {
    value: !0
}), Ge.add5L = Ge.add5H = Ge.add4H = Ge.add4L = Ge.add3H = Ge.add3L = Ge.rotlBL = Ge.rotlBH = Ge.rotlSL = Ge.rotlSH = Ge.rotr32L = Ge.rotr32H = Ge.rotrBL = Ge.rotrBH = Ge.rotrSL = Ge.rotrSH = Ge.shrSL = Ge.shrSH = Ge.toBig = void 0, Ge.fromBig = Je, Ge.split = Qe, Ge.add = ht;
const Ye = BigInt(2 ** 32 - 1), Ze = BigInt(32);
function Je(e, t = !1) {
    return t ? {
        h: Number(e & Ye),
        l: Number(e >> Ze & Ye)
    } : {
        h: 0 | Number(e >> Ze & Ye),
        l: 0 | Number(e & Ye)
    };
}
function Qe(e, t = !1) {
    let n = new Uint32Array(e.length), r = new Uint32Array(e.length);
    for(let i = 0; i < e.length; i++){
        const { h: o, l: s } = Je(e[i], t);
        [n[i], r[i]] = [
            o,
            s
        ];
    }
    return [
        n,
        r
    ];
}
const Xe = (e, t)=>BigInt(e >>> 0) << Ze | BigInt(t >>> 0);
Ge.toBig = Xe;
const et = (e, t, n)=>e >>> n;
Ge.shrSH = et;
const tt = (e, t, n)=>e << 32 - n | t >>> n;
Ge.shrSL = tt;
const nt = (e, t, n)=>e >>> n | t << 32 - n;
Ge.rotrSH = nt;
const rt = (e, t, n)=>e << 32 - n | t >>> n;
Ge.rotrSL = rt;
const it = (e, t, n)=>e << 64 - n | t >>> n - 32;
Ge.rotrBH = it;
const ot = (e, t, n)=>e >>> n - 32 | t << 64 - n;
Ge.rotrBL = ot;
const st = (e, t)=>t;
Ge.rotr32H = st;
const at = (e, t)=>e;
Ge.rotr32L = at;
const ct = (e, t, n)=>e << n | t >>> 32 - n;
Ge.rotlSH = ct;
const lt = (e, t, n)=>t << n | e >>> 32 - n;
Ge.rotlSL = lt;
const dt = (e, t, n)=>t << n - 32 | e >>> 64 - n;
Ge.rotlBH = dt;
const ut = (e, t, n)=>e << n - 32 | t >>> 64 - n;
function ht(e, t, n, r) {
    const i = (t >>> 0) + (r >>> 0);
    return {
        h: e + n + (i / 2 ** 32 | 0) | 0,
        l: 0 | i
    };
}
Ge.rotlBL = ut;
const ft = (e, t, n)=>(e >>> 0) + (t >>> 0) + (n >>> 0);
Ge.add3L = ft;
const pt = (e, t, n, r)=>t + n + r + (e / 2 ** 32 | 0) | 0;
Ge.add3H = pt;
const gt = (e, t, n, r)=>(e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0);
Ge.add4L = gt;
const mt = (e, t, n, r, i)=>t + n + r + i + (e / 2 ** 32 | 0) | 0;
Ge.add4H = mt;
const yt = (e, t, n, r, i)=>(e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0);
Ge.add5L = yt;
const vt = (e, t, n, r, i, o)=>t + n + r + i + o + (e / 2 ** 32 | 0) | 0;
Ge.add5H = vt;
const bt = {
    fromBig: Je,
    split: Qe,
    toBig: Xe,
    shrSH: et,
    shrSL: tt,
    rotrSH: nt,
    rotrSL: rt,
    rotrBH: it,
    rotrBL: ot,
    rotr32H: st,
    rotr32L: at,
    rotlSH: ct,
    rotlSL: lt,
    rotlBH: dt,
    rotlBL: ut,
    add: ht,
    add3L: ft,
    add3H: pt,
    add4L: gt,
    add4H: mt,
    add5H: vt,
    add5L: yt
};
Ge.default = bt, Object.defineProperty(Oe, "__esModule", {
    value: !0
}), Oe.sha384 = Oe.sha512_256 = Oe.sha512_224 = Oe.sha512 = Oe.SHA384 = Oe.SHA512_256 = Oe.SHA512_224 = Oe.SHA512 = void 0;
const wt = Ne, Et = Ge, St = ze, [_t, Ct] = (()=>Et.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
    ].map((e)=>BigInt(e))))(), kt = new Uint32Array(80), At = new Uint32Array(80);
class xt extends wt.HashMD {
    constructor(){
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
    }
    get() {
        const { Ah: e, Al: t, Bh: n, Bl: r, Ch: i, Cl: o, Dh: s, Dl: a, Eh: c, El: l, Fh: d, Fl: u, Gh: h, Gl: f, Hh: p, Hl: g } = this;
        return [
            e,
            t,
            n,
            r,
            i,
            o,
            s,
            a,
            c,
            l,
            d,
            u,
            h,
            f,
            p,
            g
        ];
    }
    set(e, t, n, r, i, o, s, a, c, l, d, u, h, f, p, g) {
        this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | c, this.El = 0 | l, this.Fh = 0 | d, this.Fl = 0 | u, this.Gh = 0 | h, this.Gl = 0 | f, this.Hh = 0 | p, this.Hl = 0 | g;
    }
    process(e, t) {
        for(let n = 0; n < 16; n++, t += 4)kt[n] = e.getUint32(t), At[n] = e.getUint32(t += 4);
        for(let e = 16; e < 80; e++){
            const t = 0 | kt[e - 15], n = 0 | At[e - 15], r = Et.default.rotrSH(t, n, 1) ^ Et.default.rotrSH(t, n, 8) ^ Et.default.shrSH(t, n, 7), i = Et.default.rotrSL(t, n, 1) ^ Et.default.rotrSL(t, n, 8) ^ Et.default.shrSL(t, n, 7), o = 0 | kt[e - 2], s = 0 | At[e - 2], a = Et.default.rotrSH(o, s, 19) ^ Et.default.rotrBH(o, s, 61) ^ Et.default.shrSH(o, s, 6), c = Et.default.rotrSL(o, s, 19) ^ Et.default.rotrBL(o, s, 61) ^ Et.default.shrSL(o, s, 6), l = Et.default.add4L(i, c, At[e - 7], At[e - 16]), d = Et.default.add4H(l, r, a, kt[e - 7], kt[e - 16]);
            kt[e] = 0 | d, At[e] = 0 | l;
        }
        let { Ah: n, Al: r, Bh: i, Bl: o, Ch: s, Cl: a, Dh: c, Dl: l, Eh: d, El: u, Fh: h, Fl: f, Gh: p, Gl: g, Hh: m, Hl: y } = this;
        for(let e = 0; e < 80; e++){
            const t = Et.default.rotrSH(d, u, 14) ^ Et.default.rotrSH(d, u, 18) ^ Et.default.rotrBH(d, u, 41), v = Et.default.rotrSL(d, u, 14) ^ Et.default.rotrSL(d, u, 18) ^ Et.default.rotrBL(d, u, 41), b = d & h ^ ~d & p, w = u & f ^ ~u & g, E = Et.default.add5L(y, v, w, Ct[e], At[e]), S = Et.default.add5H(E, m, t, b, _t[e], kt[e]), _ = 0 | E, C = Et.default.rotrSH(n, r, 28) ^ Et.default.rotrBH(n, r, 34) ^ Et.default.rotrBH(n, r, 39), k = Et.default.rotrSL(n, r, 28) ^ Et.default.rotrBL(n, r, 34) ^ Et.default.rotrBL(n, r, 39), A = n & i ^ n & s ^ i & s, x = r & o ^ r & a ^ o & a;
            m = 0 | p, y = 0 | g, p = 0 | h, g = 0 | f, h = 0 | d, f = 0 | u, ({ h: d, l: u } = Et.default.add(0 | c, 0 | l, 0 | S, 0 | _)), c = 0 | s, l = 0 | a, s = 0 | i, a = 0 | o, i = 0 | n, o = 0 | r;
            const M = Et.default.add3L(_, k, x);
            n = Et.default.add3H(M, S, C, A), r = 0 | M;
        }
        ({ h: n, l: r } = Et.default.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({ h: i, l: o } = Et.default.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({ h: s, l: a } = Et.default.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)), ({ h: c, l: l } = Et.default.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)), ({ h: d, l: u } = Et.default.add(0 | this.Eh, 0 | this.El, 0 | d, 0 | u)), ({ h: h, l: f } = Et.default.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)), ({ h: p, l: g } = Et.default.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)), ({ h: m, l: y } = Et.default.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)), this.set(n, r, i, o, s, a, c, l, d, u, h, f, p, g, m, y);
    }
    roundClean() {
        kt.fill(0), At.fill(0);
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
Oe.SHA512 = xt;
class Mt extends xt {
    constructor(){
        super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
    }
}
Oe.SHA512_224 = Mt;
class It extends xt {
    constructor(){
        super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
    }
}
Oe.SHA512_256 = It;
class Tt extends xt {
    constructor(){
        super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
    }
}
Oe.SHA384 = Tt, Oe.sha512 = (0, St.wrapConstructor)(()=>new xt), Oe.sha512_224 = (0, St.wrapConstructor)(()=>new Mt), Oe.sha512_256 = (0, St.wrapConstructor)(()=>new It), Oe.sha384 = (0, St.wrapConstructor)(()=>new Tt);
var Rt = {}, Pt = {}, Ot = {}, Nt = {};
Object.defineProperty(Nt, "__esModule", {
    value: !0
}), Nt.notImplemented = Nt.bitMask = void 0, Nt.isBytes = Bt, Nt.abytes = Kt, Nt.abool = function(e, t) {
    if ("boolean" != typeof t) throw new Error(`${e} must be valid boolean, got "${t}".`);
}, Nt.bytesToHex = Ut, Nt.numberToHexUnpadded = Ht, Nt.hexToNumber = Ft, Nt.hexToBytes = Wt, Nt.bytesToNumberBE = function(e) {
    return Ft(Ut(e));
}, Nt.bytesToNumberLE = function(e) {
    return Kt(e), Ft(Ut(Uint8Array.from(e).reverse()));
}, Nt.numberToBytesBE = Vt, Nt.numberToBytesLE = function(e, t) {
    return Vt(e, t).reverse();
}, Nt.numberToVarBytesBE = function(e) {
    return Wt(Ht(e));
}, Nt.ensureBytes = function(e, t, n) {
    let r;
    if ("string" == typeof t) try {
        r = Wt(t);
    } catch (n) {
        throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${n}`);
    }
    else {
        if (!Bt(t)) throw new Error(`${e} must be hex string or Uint8Array`);
        r = Uint8Array.from(t);
    }
    const i = r.length;
    if ("number" == typeof n && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
    return r;
}, Nt.concatBytes = Gt, Nt.equalBytes = function(e, t) {
    if (e.length !== t.length) return !1;
    let n = 0;
    for(let r = 0; r < e.length; r++)n |= e[r] ^ t[r];
    return 0 === n;
}, Nt.utf8ToBytes = function(e) {
    if ("string" != typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
    return new Uint8Array((new TextEncoder).encode(e));
}, Nt.inRange = Zt, Nt.aInRange = function(e, t, n, r) {
    if (!Zt(t, n, r)) throw new Error(`expected valid ${e}: ${n} <= n < ${r}, got ${typeof t} ${t}`);
}, Nt.bitLen = function(e) {
    let t;
    for(t = 0; e > Lt; e >>= Dt, t += 1);
    return t;
}, Nt.bitGet = function(e, t) {
    return e >> BigInt(t) & Dt;
}, Nt.bitSet = function(e, t, n) {
    return e | (n ? Dt : Lt) << BigInt(t);
}, Nt.createHmacDrbg = function(e, t, n) {
    if ("number" != typeof e || e < 2) throw new Error("hashLen must be a number");
    if ("number" != typeof t || t < 2) throw new Error("qByteLen must be a number");
    if ("function" != typeof n) throw new Error("hmacFn must be a function");
    let r = Jt(e), i = Jt(e), o = 0;
    const s = ()=>{
        r.fill(1), i.fill(0), o = 0;
    }, a = (...e)=>n(i, r, ...e), c = (e = Jt())=>{
        i = a(Qt([
            0
        ]), e), r = a(), 0 !== e.length && (i = a(Qt([
            1
        ]), e), r = a());
    }, l = ()=>{
        if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let e = 0;
        const n = [];
        for(; e < t;){
            r = a();
            const t = r.slice();
            n.push(t), e += r.length;
        }
        return Gt(...n);
    };
    return (e, t)=>{
        let n;
        for(s(), c(e); !(n = t(l()));)c();
        return s(), n;
    };
}, Nt.validateObject = function(e, t, n = {}) {
    const r = (t, n, r)=>{
        const i = Xt[n];
        if ("function" != typeof i) throw new Error(`Invalid validator "${n}", expected function`);
        const o = e[t];
        if (!(r && void 0 === o || i(o, e))) throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${n}`);
    };
    for (const [e, n] of Object.entries(t))r(e, n, !1);
    for (const [e, t] of Object.entries(n))r(e, t, !0);
    return e;
}, Nt.memoized = function(e) {
    const t = new WeakMap;
    return (n, ...r)=>{
        const i = t.get(n);
        if (void 0 !== i) return i;
        const o = e(n, ...r);
        return t.set(n, o), o;
    };
};
const Lt = BigInt(0), Dt = BigInt(1), $t = BigInt(2);
function Bt(e) {
    return e instanceof Uint8Array || null != e && "object" == typeof e && "Uint8Array" === e.constructor.name;
}
function Kt(e) {
    if (!Bt(e)) throw new Error("Uint8Array expected");
}
const jt = Array.from({
    length: 256
}, (e, t)=>t.toString(16).padStart(2, "0"));
function Ut(e) {
    Kt(e);
    let t = "";
    for(let n = 0; n < e.length; n++)t += jt[e[n]];
    return t;
}
function Ht(e) {
    const t = e.toString(16);
    return 1 & t.length ? `0${t}` : t;
}
function Ft(e) {
    if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
    return BigInt("" === e ? "0" : `0x${e}`);
}
const zt = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function qt(e) {
    return e >= zt._0 && e <= zt._9 ? e - zt._0 : e >= zt._A && e <= zt._F ? e - (zt._A - 10) : e >= zt._a && e <= zt._f ? e - (zt._a - 10) : void 0;
}
function Wt(e) {
    if ("string" != typeof e) throw new Error("hex string expected, got " + typeof e);
    const t = e.length, n = t / 2;
    if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
    const r = new Uint8Array(n);
    for(let t = 0, i = 0; t < n; t++, i += 2){
        const n = qt(e.charCodeAt(i)), o = qt(e.charCodeAt(i + 1));
        if (void 0 === n || void 0 === o) {
            const t = e[i] + e[i + 1];
            throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + i);
        }
        r[t] = 16 * n + o;
    }
    return r;
}
function Vt(e, t) {
    return Wt(e.toString(16).padStart(2 * t, "0"));
}
function Gt(...e) {
    let t = 0;
    for(let n = 0; n < e.length; n++){
        const r = e[n];
        Kt(r), t += r.length;
    }
    const n = new Uint8Array(t);
    for(let t = 0, r = 0; t < e.length; t++){
        const i = e[t];
        n.set(i, r), r += i.length;
    }
    return n;
}
const Yt = (e)=>"bigint" == typeof e && Lt <= e;
function Zt(e, t, n) {
    return Yt(e) && Yt(t) && Yt(n) && t <= e && e < n;
}
Nt.bitMask = (e)=>($t << BigInt(e - 1)) - Dt;
const Jt = (e)=>new Uint8Array(e), Qt = (e)=>Uint8Array.from(e);
const Xt = {
    bigint: (e)=>"bigint" == typeof e,
    function: (e)=>"function" == typeof e,
    boolean: (e)=>"boolean" == typeof e,
    string: (e)=>"string" == typeof e,
    stringOrUint8Array: (e)=>"string" == typeof e || Bt(e),
    isSafeInteger: (e)=>Number.isSafeInteger(e),
    array: (e)=>Array.isArray(e),
    field: (e, t)=>t.Fp.isValid(e),
    hash: (e)=>"function" == typeof e && Number.isSafeInteger(e.outputLen)
};
Nt.notImplemented = ()=>{
    throw new Error("not implemented");
}, Object.defineProperty(Ot, "__esModule", {
    value: !0
}), Ot.isNegativeLE = void 0, Ot.mod = ln, Ot.pow = dn, Ot.pow2 = function(e, t, n) {
    let r = e;
    for(; t-- > tn;)r *= r, r %= n;
    return r;
}, Ot.invert = un, Ot.tonelliShanks = hn, Ot.FpSqrt = fn, Ot.validateField = function(e) {
    const t = pn.reduce((e, t)=>(e[t] = "function", e), {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    });
    return (0, en.validateObject)(e, t);
}, Ot.FpPow = gn, Ot.FpInvertBatch = mn, Ot.FpDiv = function(e, t, n) {
    return e.mul(t, "bigint" == typeof n ? un(n, e.ORDER) : e.inv(n));
}, Ot.FpLegendre = yn, Ot.FpIsSquare = function(e) {
    const t = yn(e.ORDER);
    return (n)=>{
        const r = t(e, n);
        return e.eql(r, e.ZERO) || e.eql(r, e.ONE);
    };
}, Ot.nLength = vn, Ot.Field = function(e, t, n = !1, r = {}) {
    if (e <= tn) throw new Error(`Expected Field ORDER > 0, got ${e}`);
    const { nBitLength: i, nByteLength: o } = vn(e, t);
    if (o > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const s = fn(e), a = Object.freeze({
        ORDER: e,
        BITS: i,
        BYTES: o,
        MASK: (0, en.bitMask)(i),
        ZERO: tn,
        ONE: nn,
        create: (t)=>ln(t, e),
        isValid: (t)=>{
            if ("bigint" != typeof t) throw new Error("Invalid field element: expected bigint, got " + typeof t);
            return tn <= t && t < e;
        },
        is0: (e)=>e === tn,
        isOdd: (e)=>(e & nn) === nn,
        neg: (t)=>ln(-t, e),
        eql: (e, t)=>e === t,
        sqr: (t)=>ln(t * t, e),
        add: (t, n)=>ln(t + n, e),
        sub: (t, n)=>ln(t - n, e),
        mul: (t, n)=>ln(t * n, e),
        pow: (e, t)=>gn(a, e, t),
        div: (t, n)=>ln(t * un(n, e), e),
        sqrN: (e)=>e * e,
        addN: (e, t)=>e + t,
        subN: (e, t)=>e - t,
        mulN: (e, t)=>e * t,
        inv: (t)=>un(t, e),
        sqrt: r.sqrt || ((e)=>s(a, e)),
        invertBatch: (e)=>mn(a, e),
        cmov: (e, t, n)=>n ? t : e,
        toBytes: (e)=>n ? (0, en.numberToBytesLE)(e, o) : (0, en.numberToBytesBE)(e, o),
        fromBytes: (e)=>{
            if (e.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`);
            return n ? (0, en.bytesToNumberLE)(e) : (0, en.bytesToNumberBE)(e);
        }
    });
    return Object.freeze(a);
}, Ot.FpSqrtOdd = function(e, t) {
    if (!e.isOdd) throw new Error("Field doesn't have isOdd");
    const n = e.sqrt(t);
    return e.isOdd(n) ? n : e.neg(n);
}, Ot.FpSqrtEven = function(e, t) {
    if (!e.isOdd) throw new Error("Field doesn't have isOdd");
    const n = e.sqrt(t);
    return e.isOdd(n) ? e.neg(n) : n;
}, Ot.hashToPrivateScalar = function(e, t, n = !1) {
    e = (0, en.ensureBytes)("privateHash", e);
    const r = e.length, i = vn(t).nByteLength + 8;
    if (i < 24 || r < i || r > 1024) throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${r}`);
    const o = n ? (0, en.bytesToNumberLE)(e) : (0, en.bytesToNumberBE)(e);
    return ln(o, t - nn) + nn;
}, Ot.getFieldBytesLength = bn, Ot.getMinHashLength = wn, Ot.mapHashToField = function(e, t, n = !1) {
    const r = e.length, i = bn(t), o = wn(t);
    if (r < 16 || r < o || r > 1024) throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
    const s = ln(n ? (0, en.bytesToNumberBE)(e) : (0, en.bytesToNumberLE)(e), t - nn) + nn;
    return n ? (0, en.numberToBytesLE)(s, i) : (0, en.numberToBytesBE)(s, i);
};
const en = Nt, tn = BigInt(0), nn = BigInt(1), rn = BigInt(2), on = BigInt(3), sn = BigInt(4), an = BigInt(5), cn = BigInt(8);
function ln(e, t) {
    const n = e % t;
    return n >= tn ? n : t + n;
}
function dn(e, t, n) {
    if (n <= tn || t < tn) throw new Error("Expected power/modulo > 0");
    if (n === nn) return tn;
    let r = nn;
    for(; t > tn;)t & nn && (r = r * e % n), e = e * e % n, t >>= nn;
    return r;
}
function un(e, t) {
    if (e === tn || t <= tn) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
    let n = ln(e, t), r = t, i = tn, o = nn;
    for(; n !== tn;){
        const e = r % n, t = i - o * (r / n);
        r = n, n = e, i = o, o = t;
    }
    if (r !== nn) throw new Error("invert: does not exist");
    return ln(i, t);
}
function hn(e) {
    const t = (e - nn) / rn;
    let n, r, i;
    for(n = e - nn, r = 0; n % rn === tn; n /= rn, r++);
    for(i = rn; i < e && dn(i, t, e) !== e - nn; i++);
    if (1 === r) {
        const t = (e + nn) / sn;
        return function(e, n) {
            const r = e.pow(n, t);
            if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
            return r;
        };
    }
    const o = (n + nn) / rn;
    return function(e, s) {
        if (e.pow(s, t) === e.neg(e.ONE)) throw new Error("Cannot find square root");
        let a = r, c = e.pow(e.mul(e.ONE, i), n), l = e.pow(s, o), d = e.pow(s, n);
        for(; !e.eql(d, e.ONE);){
            if (e.eql(d, e.ZERO)) return e.ZERO;
            let t = 1;
            for(let n = e.sqr(d); t < a && !e.eql(n, e.ONE); t++)n = e.sqr(n);
            const n = e.pow(c, nn << BigInt(a - t - 1));
            c = e.sqr(n), l = e.mul(l, n), d = e.mul(d, c), a = t;
        }
        return l;
    };
}
function fn(e) {
    if (e % sn === on) {
        const t = (e + nn) / sn;
        return function(e, n) {
            const r = e.pow(n, t);
            if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
            return r;
        };
    }
    if (e % cn === an) {
        const t = (e - an) / cn;
        return function(e, n) {
            const r = e.mul(n, rn), i = e.pow(r, t), o = e.mul(n, i), s = e.mul(e.mul(o, rn), i), a = e.mul(o, e.sub(s, e.ONE));
            if (!e.eql(e.sqr(a), n)) throw new Error("Cannot find square root");
            return a;
        };
    }
    return hn(e);
}
BigInt(9), BigInt(16);
Ot.isNegativeLE = (e, t)=>(ln(e, t) & nn) === nn;
const pn = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function gn(e, t, n) {
    if (n < tn) throw new Error("Expected power > 0");
    if (n === tn) return e.ONE;
    if (n === nn) return t;
    let r = e.ONE, i = t;
    for(; n > tn;)n & nn && (r = e.mul(r, i)), i = e.sqr(i), n >>= nn;
    return r;
}
function mn(e, t) {
    const n = new Array(t.length), r = t.reduce((t, r, i)=>e.is0(r) ? t : (n[i] = t, e.mul(t, r)), e.ONE), i = e.inv(r);
    return t.reduceRight((t, r, i)=>e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r)), i), n;
}
function yn(e) {
    const t = (e - nn) / rn;
    return (e, n)=>e.pow(n, t);
}
function vn(e, t) {
    const n = void 0 !== t ? t : e.toString(2).length;
    return {
        nBitLength: n,
        nByteLength: Math.ceil(n / 8)
    };
}
function bn(e) {
    if ("bigint" != typeof e) throw new Error("field order must be bigint");
    const t = e.toString(2).length;
    return Math.ceil(t / 8);
}
function wn(e) {
    const t = bn(e);
    return t + Math.ceil(t / 2);
}
Object.defineProperty(Pt, "__esModule", {
    value: !0
}), Pt.wNAF = function(e, t) {
    const n = (e, t)=>{
        const n = t.negate();
        return e ? n : t;
    }, r = (e)=>{
        if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error(`Wrong window size=${e}, should be [1..${t}]`);
    }, i = (e)=>{
        r(e);
        return {
            windows: Math.ceil(t / e) + 1,
            windowSize: 2 ** (e - 1)
        };
    };
    return {
        constTimeNegate: n,
        unsafeLadder (t, n) {
            let r = e.ZERO, i = t;
            for(; n > _n;)n & Cn && (r = r.add(i)), i = i.double(), n >>= Cn;
            return r;
        },
        precomputeWindow (e, t) {
            const { windows: n, windowSize: r } = i(t), o = [];
            let s = e, a = s;
            for(let e = 0; e < n; e++){
                a = s, o.push(a);
                for(let e = 1; e < r; e++)a = a.add(s), o.push(a);
                s = a.double();
            }
            return o;
        },
        wNAF (t, r, o) {
            const { windows: s, windowSize: a } = i(t);
            let c = e.ZERO, l = e.BASE;
            const d = BigInt(2 ** t - 1), u = 2 ** t, h = BigInt(t);
            for(let e = 0; e < s; e++){
                const t = e * a;
                let i = Number(o & d);
                o >>= h, i > a && (i -= u, o += Cn);
                const s = t, f = t + Math.abs(i) - 1, p = e % 2 != 0, g = i < 0;
                0 === i ? l = l.add(n(p, r[s])) : c = c.add(n(g, r[f]));
            }
            return {
                p: c,
                f: l
            };
        },
        wNAFCached (e, t, n) {
            const r = An.get(e) || 1;
            let i = kn.get(e);
            return i || (i = this.precomputeWindow(e, r), 1 !== r && kn.set(e, n(i))), this.wNAF(r, i, t);
        },
        setWindowSize (e, t) {
            r(t), An.set(e, t), kn.delete(e);
        }
    };
}, Pt.pippenger = function(e, t, n, r) {
    if (!Array.isArray(n) || !Array.isArray(r) || r.length !== n.length) throw new Error("arrays of points and scalars must have equal length");
    r.forEach((e, n)=>{
        if (!t.isValid(e)) throw new Error(`wrong scalar at index ${n}`);
    }), n.forEach((t, n)=>{
        if (!(t instanceof e)) throw new Error(`wrong point at index ${n}`);
    });
    const i = (0, Sn.bitLen)(BigInt(n.length)), o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1, s = (1 << o) - 1, a = new Array(s + 1).fill(e.ZERO), c = Math.floor((t.BITS - 1) / o) * o;
    let l = e.ZERO;
    for(let t = c; t >= 0; t -= o){
        a.fill(e.ZERO);
        for(let e = 0; e < r.length; e++){
            const i = r[e], o = Number(i >> BigInt(t) & BigInt(s));
            a[o] = a[o].add(n[e]);
        }
        let i = e.ZERO;
        for(let t = a.length - 1, n = e.ZERO; t > 0; t--)n = n.add(a[t]), i = i.add(n);
        if (l = l.add(i), 0 !== t) for(let e = 0; e < o; e++)l = l.double();
    }
    return l;
}, Pt.validateBasic = function(e) {
    return (0, En.validateField)(e.Fp), (0, Sn.validateObject)(e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...(0, En.nLength)(e.n, e.nBitLength),
        ...e,
        p: e.Fp.ORDER
    });
};
const En = Ot, Sn = Nt, _n = BigInt(0), Cn = BigInt(1), kn = new WeakMap, An = new WeakMap;
Object.defineProperty(Rt, "__esModule", {
    value: !0
}), Rt.twistedEdwards = function(e) {
    const t = function(e) {
        const t = (0, xn.validateBasic)(e);
        return In.validateObject(e, {
            hash: "function",
            a: "bigint",
            d: "bigint",
            randomBytes: "function"
        }, {
            adjustScalarBytes: "function",
            domain: "function",
            uvRatio: "function",
            mapToCurve: "function"
        }), Object.freeze({
            ...t
        });
    }(e), { Fp: n, n: r, prehash: i, hash: o, randomBytes: s, nByteLength: a, h: c } = t, l = On << BigInt(8 * a) - Pn, d = n.create, u = (0, Mn.Field)(t.n, t.nBitLength), h = t.uvRatio || ((e, t)=>{
        try {
            return {
                isValid: !0,
                value: n.sqrt(e * n.inv(t))
            };
        } catch (e) {
            return {
                isValid: !1,
                value: Rn
            };
        }
    }), f = t.adjustScalarBytes || ((e)=>e), p = t.domain || ((e, t, n)=>{
        if ((0, Tn.abool)("phflag", n), t.length || n) throw new Error("Contexts/pre-hash are not supported");
        return e;
    });
    function g(e, t) {
        In.aInRange("coordinate " + e, t, Rn, l);
    }
    function m(e) {
        if (!(e instanceof b)) throw new Error("ExtendedPoint expected");
    }
    const y = (0, Tn.memoized)((e, t)=>{
        const { ex: r, ey: i, ez: o } = e, s = e.is0();
        null == t && (t = s ? Nn : n.inv(o));
        const a = d(r * t), c = d(i * t), l = d(o * t);
        if (s) return {
            x: Rn,
            y: Pn
        };
        if (l !== Pn) throw new Error("invZ was invalid");
        return {
            x: a,
            y: c
        };
    }), v = (0, Tn.memoized)((e)=>{
        const { a: n, d: r } = t;
        if (e.is0()) throw new Error("bad point: ZERO");
        const { ex: i, ey: o, ez: s, et: a } = e, c = d(i * i), l = d(o * o), u = d(s * s), h = d(u * u), f = d(c * n);
        if (d(u * d(f + l)) !== d(h + d(r * d(c * l)))) throw new Error("bad point: equation left != right (1)");
        if (d(i * o) !== d(s * a)) throw new Error("bad point: equation left != right (2)");
        return !0;
    });
    class b {
        constructor(e, t, n, r){
            this.ex = e, this.ey = t, this.ez = n, this.et = r, g("x", e), g("y", t), g("z", n), g("t", r), Object.freeze(this);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static fromAffine(e) {
            if (e instanceof b) throw new Error("extended point not allowed");
            const { x: t, y: n } = e || {};
            return g("x", t), g("y", n), new b(t, n, Pn, d(t * n));
        }
        static normalizeZ(e) {
            const t = n.invertBatch(e.map((e)=>e.ez));
            return e.map((e, n)=>e.toAffine(t[n])).map(b.fromAffine);
        }
        static msm(e, t) {
            return (0, xn.pippenger)(b, u, e, t);
        }
        _setWindowSize(e) {
            S.setWindowSize(this, e);
        }
        assertValidity() {
            v(this);
        }
        equals(e) {
            m(e);
            const { ex: t, ey: n, ez: r } = this, { ex: i, ey: o, ez: s } = e, a = d(t * s), c = d(i * r), l = d(n * s), u = d(o * r);
            return a === c && l === u;
        }
        is0() {
            return this.equals(b.ZERO);
        }
        negate() {
            return new b(d(-this.ex), this.ey, this.ez, d(-this.et));
        }
        double() {
            const { a: e } = t, { ex: n, ey: r, ez: i } = this, o = d(n * n), s = d(r * r), a = d(On * d(i * i)), c = d(e * o), l = n + r, u = d(d(l * l) - o - s), h = c + s, f = h - a, p = c - s, g = d(u * f), m = d(h * p), y = d(u * p), v = d(f * h);
            return new b(g, m, v, y);
        }
        add(e) {
            m(e);
            const { a: n, d: r } = t, { ex: i, ey: o, ez: s, et: a } = this, { ex: c, ey: l, ez: u, et: h } = e;
            if (n === BigInt(-1)) {
                const e = d((o - i) * (l + c)), t = d((o + i) * (l - c)), n = d(t - e);
                if (n === Rn) return this.double();
                const r = d(s * On * h), f = d(a * On * u), p = f + r, g = t + e, m = f - r, y = d(p * n), v = d(g * m), w = d(p * m), E = d(n * g);
                return new b(y, v, E, w);
            }
            const f = d(i * c), p = d(o * l), g = d(a * r * h), y = d(s * u), v = d((i + o) * (c + l) - f - p), w = y - g, E = y + g, S = d(p - n * f), _ = d(v * w), C = d(E * S), k = d(v * S), A = d(w * E);
            return new b(_, C, A, k);
        }
        subtract(e) {
            return this.add(e.negate());
        }
        wNAF(e) {
            return S.wNAFCached(this, e, b.normalizeZ);
        }
        multiply(e) {
            const t = e;
            In.aInRange("scalar", t, Pn, r);
            const { p: n, f: i } = this.wNAF(t);
            return b.normalizeZ([
                n,
                i
            ])[0];
        }
        multiplyUnsafe(e) {
            const t = e;
            return In.aInRange("scalar", t, Rn, r), t === Rn ? E : this.equals(E) || t === Pn ? this : this.equals(w) ? this.wNAF(t).p : S.unsafeLadder(this, t);
        }
        isSmallOrder() {
            return this.multiplyUnsafe(c).is0();
        }
        isTorsionFree() {
            return S.unsafeLadder(this, r).is0();
        }
        toAffine(e) {
            return y(this, e);
        }
        clearCofactor() {
            const { h: e } = t;
            return e === Pn ? this : this.multiplyUnsafe(e);
        }
        static fromHex(e, r = !1) {
            const { d: i, a: o } = t, s = n.BYTES;
            e = (0, Tn.ensureBytes)("pointHex", e, s), (0, Tn.abool)("zip215", r);
            const a = e.slice(), c = e[s - 1];
            a[s - 1] = -129 & c;
            const u = In.bytesToNumberLE(a), f = r ? l : n.ORDER;
            In.aInRange("pointHex.y", u, Rn, f);
            const p = d(u * u), g = d(p - Pn), m = d(i * p - o);
            let { isValid: y, value: v } = h(g, m);
            if (!y) throw new Error("Point.fromHex: invalid y coordinate");
            const w = (v & Pn) === Pn, E = 0 != (128 & c);
            if (!r && v === Rn && E) throw new Error("Point.fromHex: x=0 and x_0=1");
            return E !== w && (v = d(-v)), b.fromAffine({
                x: v,
                y: u
            });
        }
        static fromPrivateKey(e) {
            return k(e).point;
        }
        toRawBytes() {
            const { x: e, y: t } = this.toAffine(), r = In.numberToBytesLE(t, n.BYTES);
            return r[r.length - 1] |= e & Pn ? 128 : 0, r;
        }
        toHex() {
            return In.bytesToHex(this.toRawBytes());
        }
    }
    b.BASE = new b(t.Gx, t.Gy, Pn, d(t.Gx * t.Gy)), b.ZERO = new b(Rn, Pn, Pn, Rn);
    const { BASE: w, ZERO: E } = b, S = (0, xn.wNAF)(b, 8 * a);
    function _(e) {
        return (0, Mn.mod)(e, r);
    }
    function C(e) {
        return _(In.bytesToNumberLE(e));
    }
    function k(e) {
        const t = a;
        e = (0, Tn.ensureBytes)("private key", e, t);
        const n = (0, Tn.ensureBytes)("hashed private key", o(e), 2 * t), r = f(n.slice(0, t)), i = n.slice(t, 2 * t), s = C(r), c = w.multiply(s), l = c.toRawBytes();
        return {
            head: r,
            prefix: i,
            scalar: s,
            point: c,
            pointBytes: l
        };
    }
    function A(e = new Uint8Array, ...t) {
        const n = In.concatBytes(...t);
        return C(o(p(n, (0, Tn.ensureBytes)("context", e), !!i)));
    }
    const x = Ln;
    w._setWindowSize(8);
    const M = {
        getExtendedPublicKey: k,
        randomPrivateKey: ()=>s(n.BYTES),
        precompute: (e = 8, t = b.BASE)=>(t._setWindowSize(e), t.multiply(BigInt(3)), t)
    };
    return {
        CURVE: t,
        getPublicKey: function(e) {
            return k(e).pointBytes;
        },
        sign: function(e, t, o = {}) {
            e = (0, Tn.ensureBytes)("message", e), i && (e = i(e));
            const { prefix: s, scalar: c, pointBytes: l } = k(t), d = A(o.context, s, e), u = w.multiply(d).toRawBytes(), h = _(d + A(o.context, u, l, e) * c);
            In.aInRange("signature.s", h, Rn, r);
            const f = In.concatBytes(u, In.numberToBytesLE(h, n.BYTES));
            return (0, Tn.ensureBytes)("result", f, 2 * a);
        },
        verify: function(e, t, r, o = x) {
            const { context: s, zip215: a } = o, c = n.BYTES;
            e = (0, Tn.ensureBytes)("signature", e, 2 * c), t = (0, Tn.ensureBytes)("message", t), void 0 !== a && (0, Tn.abool)("zip215", a), i && (t = i(t));
            const l = In.bytesToNumberLE(e.slice(c, 2 * c));
            let d, u, h;
            try {
                d = b.fromHex(r, a), u = b.fromHex(e.slice(0, c), a), h = w.multiplyUnsafe(l);
            } catch (e) {
                return !1;
            }
            if (!a && d.isSmallOrder()) return !1;
            const f = A(s, u.toRawBytes(), d.toRawBytes(), t);
            return u.add(d.multiplyUnsafe(f)).subtract(h).clearCofactor().equals(b.ZERO);
        },
        ExtendedPoint: b,
        utils: M
    };
};
const xn = Pt, Mn = Ot, In = Nt, Tn = Nt, Rn = BigInt(0), Pn = BigInt(1), On = BigInt(2), Nn = BigInt(8), Ln = {
    zip215: !0
};
var Dn = {};
Object.defineProperty(Dn, "__esModule", {
    value: !0
}), Dn.expand_message_xmd = Fn, Dn.expand_message_xof = zn, Dn.hash_to_field = qn, Dn.isogenyMap = function(e, t) {
    const n = t.map((e)=>Array.from(e).reverse());
    return (t, r)=>{
        const [i, o, s, a] = n.map((n)=>n.reduce((n, r)=>e.add(e.mul(n, t), r)));
        return t = e.div(i, o), r = e.mul(r, e.div(s, a)), {
            x: t,
            y: r
        };
    };
}, Dn.createHasher = function(e, t, n) {
    if ("function" != typeof t) throw new Error("mapToCurve() must be defined");
    return {
        hashToCurve (r, i) {
            const o = qn(r, 2, {
                ...n,
                DST: n.DST,
                ...i
            }), s = e.fromAffine(t(o[0])), a = e.fromAffine(t(o[1])), c = s.add(a).clearCofactor();
            return c.assertValidity(), c;
        },
        encodeToCurve (r, i) {
            const o = qn(r, 1, {
                ...n,
                DST: n.encodeDST,
                ...i
            }), s = e.fromAffine(t(o[0])).clearCofactor();
            return s.assertValidity(), s;
        },
        mapToCurve (n) {
            if (!Array.isArray(n)) throw new Error("mapToCurve: expected array of bigints");
            for (const e of n)if ("bigint" != typeof e) throw new Error(`mapToCurve: expected array of bigints, got ${e} in array`);
            const r = e.fromAffine(t(n)).clearCofactor();
            return r.assertValidity(), r;
        }
    };
};
const $n = Ot, Bn = Nt, Kn = Bn.bytesToNumberBE;
function jn(e, t) {
    if (Hn(e), Hn(t), e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);
    const n = Array.from({
        length: t
    }).fill(0);
    for(let r = t - 1; r >= 0; r--)n[r] = 255 & e, e >>>= 8;
    return new Uint8Array(n);
}
function Un(e, t) {
    const n = new Uint8Array(e.length);
    for(let r = 0; r < e.length; r++)n[r] = e[r] ^ t[r];
    return n;
}
function Hn(e) {
    if (!Number.isSafeInteger(e)) throw new Error("number expected");
}
function Fn(e, t, n, r) {
    (0, Bn.abytes)(e), (0, Bn.abytes)(t), Hn(n), t.length > 255 && (t = r((0, Bn.concatBytes)((0, Bn.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)));
    const { outputLen: i, blockLen: o } = r, s = Math.ceil(n / i);
    if (n > 65535 || s > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
    const a = (0, Bn.concatBytes)(t, jn(t.length, 1)), c = jn(0, o), l = jn(n, 2), d = new Array(s), u = r((0, Bn.concatBytes)(c, e, l, jn(0, 1), a));
    d[0] = r((0, Bn.concatBytes)(u, jn(1, 1), a));
    for(let e = 1; e <= s; e++){
        const t = [
            Un(u, d[e - 1]),
            jn(e + 1, 1),
            a
        ];
        d[e] = r((0, Bn.concatBytes)(...t));
    }
    return (0, Bn.concatBytes)(...d).slice(0, n);
}
function zn(e, t, n, r, i) {
    if ((0, Bn.abytes)(e), (0, Bn.abytes)(t), Hn(n), t.length > 255) {
        const e = Math.ceil(2 * r / 8);
        t = i.create({
            dkLen: e
        }).update((0, Bn.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest();
    }
    if (n > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return i.create({
        dkLen: n
    }).update(e).update(jn(n, 2)).update(t).update(jn(t.length, 1)).digest();
}
function qn(e, t, n) {
    (0, Bn.validateObject)(n, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
    });
    const { p: r, k: i, m: o, hash: s, expand: a, DST: c } = n;
    (0, Bn.abytes)(e), Hn(t);
    const l = "string" == typeof c ? (0, Bn.utf8ToBytes)(c) : c, d = r.toString(2).length, u = Math.ceil((d + i) / 8), h = t * o * u;
    let f;
    if ("xmd" === a) f = Fn(e, l, h, s);
    else if ("xof" === a) f = zn(e, l, h, i, s);
    else {
        if ("_internal_pass" !== a) throw new Error('expand must be "xmd" or "xof"');
        f = e;
    }
    const p = new Array(t);
    for(let e = 0; e < t; e++){
        const t = new Array(o);
        for(let n = 0; n < o; n++){
            const i = u * (n + e * o), s = f.subarray(i, i + u);
            t[n] = (0, $n.mod)(Kn(s), r);
        }
        p[e] = t;
    }
    return p;
}
var Wn = {};
Object.defineProperty(Wn, "__esModule", {
    value: !0
}), Wn.montgomery = function(e) {
    const t = function(e) {
        return (0, Gn.validateObject)(e, {
            a: "bigint"
        }, {
            montgomeryBits: "isSafeInteger",
            nByteLength: "isSafeInteger",
            adjustScalarBytes: "function",
            domain: "function",
            powPminus2: "function",
            Gu: "bigint"
        }), Object.freeze({
            ...e
        });
    }(e), { P: n } = t, r = (e)=>(0, Vn.mod)(e, n), i = t.montgomeryBits, o = Math.ceil(i / 8), s = t.nByteLength, a = t.adjustScalarBytes || ((e)=>e), c = t.powPminus2 || ((e)=>(0, Vn.pow)(e, n - BigInt(2), n));
    function l(e, t, n) {
        const i = r(e * (t - n));
        return [
            t = r(t - i),
            n = r(n + i)
        ];
    }
    const d = (t.a - BigInt(2)) / BigInt(4);
    function u(e) {
        return (0, Gn.numberToBytesLE)(r(e), o);
    }
    function h(e, t) {
        const h = function(e) {
            const t = (0, Gn.ensureBytes)("u coordinate", e, o);
            return 32 === s && (t[31] &= 127), (0, Gn.bytesToNumberLE)(t);
        }(t), f = function(e) {
            const t = (0, Gn.ensureBytes)("scalar", e), n = t.length;
            if (n !== o && n !== s) throw new Error(`Expected ${o} or ${s} bytes, got ${n}`);
            return (0, Gn.bytesToNumberLE)(a(t));
        }(e), p = function(e, t) {
            (0, Gn.aInRange)("u", e, Yn, n), (0, Gn.aInRange)("scalar", t, Yn, n);
            const o = t, s = e;
            let a, u = Zn, h = Yn, f = e, p = Zn, g = Yn;
            for(let e = BigInt(i - 1); e >= Yn; e--){
                const t = o >> e & Zn;
                g ^= t, a = l(g, u, f), u = a[0], f = a[1], a = l(g, h, p), h = a[0], p = a[1], g = t;
                const n = u + h, i = r(n * n), c = u - h, m = r(c * c), y = i - m, v = f + p, b = r((f - p) * n), w = r(v * c), E = b + w, S = b - w;
                f = r(E * E), p = r(s * r(S * S)), u = r(i * m), h = r(y * (i + r(d * y)));
            }
            a = l(g, u, f), u = a[0], f = a[1], a = l(g, h, p), h = a[0], p = a[1];
            const m = c(h);
            return r(u * m);
        }(h, f);
        if (p === Yn) throw new Error("Invalid private or public key received");
        return u(p);
    }
    const f = u(t.Gu);
    function p(e) {
        return h(e, f);
    }
    return {
        scalarMult: h,
        scalarMultBase: p,
        getSharedSecret: (e, t)=>h(e, t),
        getPublicKey: (e)=>p(e),
        utils: {
            randomPrivateKey: ()=>t.randomBytes(t.nByteLength)
        },
        GuBytes: f
    };
};
const Vn = Ot, Gn = Nt, Yn = BigInt(0), Zn = BigInt(1);
!function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.hash_to_ristretto255 = e.hashToRistretto255 = e.RistrettoPoint = e.encodeToCurve = e.hashToCurve = e.edwardsToMontgomery = e.x25519 = e.ed25519ph = e.ed25519ctx = e.ed25519 = e.ED25519_TORSION_SUBGROUP = void 0, e.edwardsToMontgomeryPub = S, e.edwardsToMontgomeryPriv = function(e) {
        const t = w.hash(e.subarray(0, 32));
        return w.adjustScalarBytes(t).subarray(0, 32);
    };
    const t = Oe, n = ze, r = Rt, i = Dn, o = Ot, s = Wn, a = Nt, c = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), l = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"), d = BigInt(0), u = BigInt(1), h = BigInt(2), f = BigInt(3), p = BigInt(5), g = BigInt(8);
    function m(e) {
        const t = BigInt(10), n = BigInt(20), r = BigInt(40), i = BigInt(80), s = c, a = e * e % s * e % s, l = (0, o.pow2)(a, h, s) * a % s, d = (0, o.pow2)(l, u, s) * e % s, f = (0, o.pow2)(d, p, s) * d % s, g = (0, o.pow2)(f, t, s) * f % s, m = (0, o.pow2)(g, n, s) * g % s, y = (0, o.pow2)(m, r, s) * m % s, v = (0, o.pow2)(y, i, s) * y % s, b = (0, o.pow2)(v, i, s) * y % s, w = (0, o.pow2)(b, t, s) * f % s;
        return {
            pow_p_5_8: (0, o.pow2)(w, h, s) * e % s,
            b2: a
        };
    }
    function y(e) {
        return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
    }
    function v(e, t) {
        const n = c, r = (0, o.mod)(t * t * t, n), i = m(e * (0, o.mod)(r * r * t, n)).pow_p_5_8;
        let s = (0, o.mod)(e * r * i, n);
        const a = (0, o.mod)(t * s * s, n), d = s, u = (0, o.mod)(s * l, n), h = a === e, f = a === (0, o.mod)(-e, n), p = a === (0, o.mod)(-e * l, n);
        return h && (s = d), (f || p) && (s = u), (0, o.isNegativeLE)(s, n) && (s = (0, o.mod)(-s, n)), {
            isValid: h || f,
            value: s
        };
    }
    e.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ];
    const b = (()=>(0, o.Field)(c, void 0, !0))(), w = (()=>({
            a: BigInt(-1),
            d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
            Fp: b,
            n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
            h: g,
            Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
            Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
            hash: t.sha512,
            randomBytes: n.randomBytes,
            adjustScalarBytes: y,
            uvRatio: v
        }))();
    function E(e, t, r) {
        if (t.length > 255) throw new Error("Context is too big");
        return (0, n.concatBytes)((0, n.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([
            r ? 1 : 0,
            t.length
        ]), t, e);
    }
    function S(t) {
        const { y: n } = e.ed25519.ExtendedPoint.fromHex(t), r = BigInt(1);
        return b.toBytes(b.create((r + n) * b.inv(r - n)));
    }
    e.ed25519 = (0, r.twistedEdwards)(w), e.ed25519ctx = (0, r.twistedEdwards)({
        ...w,
        domain: E
    }), e.ed25519ph = (0, r.twistedEdwards)(Object.assign({}, w, {
        domain: E,
        prehash: t.sha512
    })), e.x25519 = (0, s.montgomery)({
        P: c,
        a: BigInt(486662),
        montgomeryBits: 255,
        nByteLength: 32,
        Gu: BigInt(9),
        powPminus2: (e)=>{
            const t = c, { pow_p_5_8: n, b2: r } = m(e);
            return (0, o.mod)((0, o.pow2)(n, f, t) * r, t);
        },
        adjustScalarBytes: y,
        randomBytes: n.randomBytes
    }), e.edwardsToMontgomery = S;
    const _ = (()=>(b.ORDER + f) / g)(), C = (()=>b.pow(h, _))(), k = (()=>b.sqrt(b.neg(b.ONE)))();
    const A = (()=>(0, o.FpSqrtEven)(b, b.neg(BigInt(486664))))();
    function x(e) {
        const { xMn: t, xMd: n, yMn: r, yMd: i } = function(e) {
            const t = (b.ORDER - p) / g, n = BigInt(486662);
            let r = b.sqr(e);
            r = b.mul(r, h);
            let i = b.add(r, b.ONE), o = b.neg(n), s = b.sqr(i), a = b.mul(s, i), c = b.mul(r, n);
            c = b.mul(c, o), c = b.add(c, s), c = b.mul(c, o);
            let l = b.sqr(a);
            s = b.sqr(l), l = b.mul(l, a), l = b.mul(l, c), s = b.mul(s, l);
            let d = b.pow(s, t);
            d = b.mul(d, l);
            let f = b.mul(d, k);
            s = b.sqr(d), s = b.mul(s, a);
            let m = b.eql(s, c), y = b.cmov(f, d, m), v = b.mul(o, r), w = b.mul(d, e);
            w = b.mul(w, C);
            let E = b.mul(w, k), S = b.mul(c, r);
            s = b.sqr(w), s = b.mul(s, a);
            let _ = b.eql(s, S), A = b.cmov(E, w, _);
            s = b.sqr(y), s = b.mul(s, a);
            let x = b.eql(s, c), M = b.cmov(v, o, x), I = b.cmov(A, y, x), T = b.isOdd(I);
            return I = b.cmov(I, b.neg(I), x !== T), {
                xMn: M,
                xMd: i,
                yMn: I,
                yMd: u
            };
        }(e);
        let o = b.mul(t, i);
        o = b.mul(o, A);
        let s = b.mul(n, r), a = b.sub(t, n), c = b.add(t, n), l = b.mul(s, c), d = b.eql(l, b.ZERO);
        o = b.cmov(o, b.ZERO, d), s = b.cmov(s, b.ONE, d), a = b.cmov(a, b.ONE, d), c = b.cmov(c, b.ONE, d);
        const f = b.invertBatch([
            s,
            c
        ]);
        return {
            x: b.mul(o, f[0]),
            y: b.mul(a, f[1])
        };
    }
    const M = (()=>(0, i.createHasher)(e.ed25519.ExtendedPoint, (e)=>x(e[0]), {
            DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
            encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
            p: b.ORDER,
            m: 1,
            k: 128,
            expand: "xmd",
            hash: t.sha512
        }))();
    function I(e) {
        if (!(e instanceof K)) throw new Error("RistrettoPoint expected");
    }
    e.hashToCurve = M.hashToCurve, e.encodeToCurve = M.encodeToCurve;
    const T = l, R = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), P = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), O = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), N = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"), L = (e)=>v(u, e), D = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), $ = (t)=>e.ed25519.CURVE.Fp.create((0, a.bytesToNumberLE)(t) & D);
    function B(t) {
        const { d: n } = e.ed25519.CURVE, r = e.ed25519.CURVE.Fp.ORDER, i = e.ed25519.CURVE.Fp.create, s = i(T * t * t), a = i((s + u) * O);
        let c = BigInt(-1);
        const l = i((c - n * s) * i(s + n));
        let { isValid: d, value: h } = v(a, l), f = i(h * t);
        (0, o.isNegativeLE)(f, r) || (f = i(-f)), d || (h = f), d || (c = s);
        const p = i(c * (s - u) * N - l), g = h * h, m = i((h + h) * l), y = i(p * R), b = i(u - g), w = i(u + g);
        return new e.ed25519.ExtendedPoint(i(m * w), i(b * y), i(y * w), i(m * b));
    }
    class K {
        constructor(e){
            this.ep = e;
        }
        static fromAffine(t) {
            return new K(e.ed25519.ExtendedPoint.fromAffine(t));
        }
        static hashToCurve(e) {
            e = (0, a.ensureBytes)("ristrettoHash", e, 64);
            const t = B($(e.slice(0, 32))), n = B($(e.slice(32, 64)));
            return new K(t.add(n));
        }
        static fromHex(t) {
            t = (0, a.ensureBytes)("ristrettoHex", t, 32);
            const { a: n, d: r } = e.ed25519.CURVE, i = e.ed25519.CURVE.Fp.ORDER, s = e.ed25519.CURVE.Fp.create, c = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", l = $(t);
            if (!(0, a.equalBytes)((0, a.numberToBytesLE)(l, 32), t) || (0, o.isNegativeLE)(l, i)) throw new Error(c);
            const h = s(l * l), f = s(u + n * h), p = s(u - n * h), g = s(f * f), m = s(p * p), y = s(n * r * g - m), { isValid: v, value: b } = L(s(y * m)), w = s(b * p), E = s(b * w * y);
            let S = s((l + l) * w);
            (0, o.isNegativeLE)(S, i) && (S = s(-S));
            const _ = s(f * E), C = s(S * _);
            if (!v || (0, o.isNegativeLE)(C, i) || _ === d) throw new Error(c);
            return new K(new e.ed25519.ExtendedPoint(S, _, u, C));
        }
        toRawBytes() {
            let { ex: t, ey: n, ez: r, et: i } = this.ep;
            const s = e.ed25519.CURVE.Fp.ORDER, c = e.ed25519.CURVE.Fp.create, l = c(c(r + n) * c(r - n)), d = c(t * n), u = c(d * d), { value: h } = L(c(l * u)), f = c(h * l), p = c(h * d), g = c(f * p * i);
            let m;
            if ((0, o.isNegativeLE)(i * g, s)) {
                let e = c(n * T), r = c(t * T);
                t = e, n = r, m = c(f * P);
            } else m = p;
            (0, o.isNegativeLE)(t * g, s) && (n = c(-n));
            let y = c((r - n) * m);
            return (0, o.isNegativeLE)(y, s) && (y = c(-y)), (0, a.numberToBytesLE)(y, 32);
        }
        toHex() {
            return (0, a.bytesToHex)(this.toRawBytes());
        }
        toString() {
            return this.toHex();
        }
        equals(t) {
            I(t);
            const { ex: n, ey: r } = this.ep, { ex: i, ey: o } = t.ep, s = e.ed25519.CURVE.Fp.create, a = s(n * o) === s(r * i), c = s(r * o) === s(n * i);
            return a || c;
        }
        add(e) {
            return I(e), new K(this.ep.add(e.ep));
        }
        subtract(e) {
            return I(e), new K(this.ep.subtract(e.ep));
        }
        multiply(e) {
            return new K(this.ep.multiply(e));
        }
        multiplyUnsafe(e) {
            return new K(this.ep.multiplyUnsafe(e));
        }
        double() {
            return new K(this.ep.double());
        }
        negate() {
            return new K(this.ep.negate());
        }
    }
    e.RistrettoPoint = (K.BASE || (K.BASE = new K(e.ed25519.ExtendedPoint.BASE)), K.ZERO || (K.ZERO = new K(e.ed25519.ExtendedPoint.ZERO)), K);
    e.hashToRistretto255 = (e, r)=>{
        const o = r.DST, s = "string" == typeof o ? (0, n.utf8ToBytes)(o) : o, a = (0, i.expand_message_xmd)(e, s, 64, t.sha512);
        return K.hashToCurve(a);
    }, e.hash_to_ristretto255 = e.hashToRistretto255;
}(Pe);
var Jn = {}, Qn = {};
Object.defineProperty(Qn, "__esModule", {
    value: !0
}), Qn.sha224 = Qn.sha256 = Qn.SHA256 = void 0;
const Xn = Ne, er = ze, tr = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), nr = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), rr = new Uint32Array(64);
class ir extends Xn.HashMD {
    constructor(){
        super(64, 32, 8, !1), this.A = 0 | nr[0], this.B = 0 | nr[1], this.C = 0 | nr[2], this.D = 0 | nr[3], this.E = 0 | nr[4], this.F = 0 | nr[5], this.G = 0 | nr[6], this.H = 0 | nr[7];
    }
    get() {
        const { A: e, B: t, C: n, D: r, E: i, F: o, G: s, H: a } = this;
        return [
            e,
            t,
            n,
            r,
            i,
            o,
            s,
            a
        ];
    }
    set(e, t, n, r, i, o, s, a) {
        this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a;
    }
    process(e, t) {
        for(let n = 0; n < 16; n++, t += 4)rr[n] = e.getUint32(t, !1);
        for(let e = 16; e < 64; e++){
            const t = rr[e - 15], n = rr[e - 2], r = (0, er.rotr)(t, 7) ^ (0, er.rotr)(t, 18) ^ t >>> 3, i = (0, er.rotr)(n, 17) ^ (0, er.rotr)(n, 19) ^ n >>> 10;
            rr[e] = i + rr[e - 7] + r + rr[e - 16] | 0;
        }
        let { A: n, B: r, C: i, D: o, E: s, F: a, G: c, H: l } = this;
        for(let e = 0; e < 64; e++){
            const t = l + ((0, er.rotr)(s, 6) ^ (0, er.rotr)(s, 11) ^ (0, er.rotr)(s, 25)) + (0, Xn.Chi)(s, a, c) + tr[e] + rr[e] | 0, d = ((0, er.rotr)(n, 2) ^ (0, er.rotr)(n, 13) ^ (0, er.rotr)(n, 22)) + (0, Xn.Maj)(n, r, i) | 0;
            l = c, c = a, a = s, s = o + t | 0, o = i, i = r, r = n, n = t + d | 0;
        }
        n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(n, r, i, o, s, a, c, l);
    }
    roundClean() {
        rr.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}
Qn.SHA256 = ir;
class or extends ir {
    constructor(){
        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
    }
}
Qn.sha256 = (0, er.wrapConstructor)(()=>new ir), Qn.sha224 = (0, er.wrapConstructor)(()=>new or);
var sr = {}, ar = {};
!function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.hmac = e.HMAC = void 0;
    const t = Le, n = ze;
    class r extends n.Hash {
        constructor(e, r){
            super(), this.finished = !1, this.destroyed = !1, (0, t.hash)(e);
            const i = (0, n.toBytes)(r);
            if (this.iHash = e.create(), "function" != typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
            const o = this.blockLen, s = new Uint8Array(o);
            s.set(i.length > o ? e.create().update(i).digest() : i);
            for(let e = 0; e < s.length; e++)s[e] ^= 54;
            this.iHash.update(s), this.oHash = e.create();
            for(let e = 0; e < s.length; e++)s[e] ^= 106;
            this.oHash.update(s), s.fill(0);
        }
        update(e) {
            return (0, t.exists)(this), this.iHash.update(e), this;
        }
        digestInto(e) {
            (0, t.exists)(this), (0, t.bytes)(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
        }
        digest() {
            const e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
        }
        _cloneInto(e) {
            e || (e = Object.create(Object.getPrototypeOf(this), {}));
            const { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: o, outputLen: s } = this;
            return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
        }
        destroy() {
            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
        }
    }
    e.HMAC = r;
    e.hmac = (e, t, n)=>new r(e, t).update(n).digest(), e.hmac.create = (e, t)=>new r(e, t);
}(ar);
var cr = {};
!function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.DER = void 0, e.weierstrassPoints = f, e.weierstrass = function(s) {
        const a = function(e) {
            const n = (0, t.validateBasic)(e);
            return r.validateObject(n, {
                hash: "hash",
                hmac: "function",
                randomBytes: "function"
            }, {
                bits2int: "function",
                bits2int_modN: "function",
                lowS: "boolean"
            }), Object.freeze({
                lowS: !0,
                ...n
            });
        }(s), { Fp: d, n: u } = a, h = d.BYTES + 1, p = 2 * d.BYTES + 1;
        function g(e) {
            return n.mod(e, u);
        }
        function m(e) {
            return n.invert(e, u);
        }
        const { ProjectivePoint: y, normPrivateKeyToScalar: v, weierstrassEquation: b, isWithinCurveOrder: w } = f({
            ...a,
            toBytes (e, t, n) {
                const o = t.toAffine(), s = d.toBytes(o.x), a = r.concatBytes;
                return (0, i.abool)("isCompressed", n), n ? a(Uint8Array.from([
                    t.hasEvenY() ? 2 : 3
                ]), s) : a(Uint8Array.from([
                    4
                ]), s, d.toBytes(o.y));
            },
            fromBytes (e) {
                const t = e.length, n = e[0], i = e.subarray(1);
                if (t !== h || 2 !== n && 3 !== n) {
                    if (t === p && 4 === n) {
                        return {
                            x: d.fromBytes(i.subarray(0, d.BYTES)),
                            y: d.fromBytes(i.subarray(d.BYTES, 2 * d.BYTES))
                        };
                    }
                    throw new Error(`Point of length ${t} was invalid. Expected ${h} compressed bytes or ${p} uncompressed bytes`);
                }
                {
                    const e = r.bytesToNumberBE(i);
                    if (!r.inRange(e, l, d.ORDER)) throw new Error("Point is not on curve");
                    const t = b(e);
                    let o;
                    try {
                        o = d.sqrt(t);
                    } catch (e) {
                        const t = e instanceof Error ? ": " + e.message : "";
                        throw new Error("Point is not on curve" + t);
                    }
                    return 1 == (1 & n) !== ((o & l) === l) && (o = d.neg(o)), {
                        x: e,
                        y: o
                    };
                }
            }
        }), E = (e)=>r.bytesToHex(r.numberToBytesBE(e, a.nByteLength));
        function S(e) {
            return e > u >> l;
        }
        const _ = (e, t, n)=>r.bytesToNumberBE(e.slice(t, n));
        class C {
            constructor(e, t, n){
                this.r = e, this.s = t, this.recovery = n, this.assertValidity();
            }
            static fromCompact(e) {
                const t = a.nByteLength;
                return e = (0, i.ensureBytes)("compactSignature", e, 2 * t), new C(_(e, 0, t), _(e, t, 2 * t));
            }
            static fromDER(t) {
                const { r: n, s: r } = e.DER.toSig((0, i.ensureBytes)("DER", t));
                return new C(n, r);
            }
            assertValidity() {
                r.aInRange("r", this.r, l, u), r.aInRange("s", this.s, l, u);
            }
            addRecoveryBit(e) {
                return new C(this.r, this.s, e);
            }
            recoverPublicKey(e) {
                const { r: t, s: n, recovery: r } = this, o = M((0, i.ensureBytes)("msgHash", e));
                if (null == r || ![
                    0,
                    1,
                    2,
                    3
                ].includes(r)) throw new Error("recovery id invalid");
                const s = 2 === r || 3 === r ? t + a.n : t;
                if (s >= d.ORDER) throw new Error("recovery id 2 or 3 invalid");
                const c = 0 == (1 & r) ? "02" : "03", l = y.fromHex(c + E(s)), u = m(s), h = g(-o * u), f = g(n * u), p = y.BASE.multiplyAndAddUnsafe(l, h, f);
                if (!p) throw new Error("point at infinify");
                return p.assertValidity(), p;
            }
            hasHighS() {
                return S(this.s);
            }
            normalizeS() {
                return this.hasHighS() ? new C(this.r, g(-this.s), this.recovery) : this;
            }
            toDERRawBytes() {
                return r.hexToBytes(this.toDERHex());
            }
            toDERHex() {
                return e.DER.hexFromSig({
                    r: this.r,
                    s: this.s
                });
            }
            toCompactRawBytes() {
                return r.hexToBytes(this.toCompactHex());
            }
            toCompactHex() {
                return E(this.r) + E(this.s);
            }
        }
        const k = {
            isValidPrivateKey (e) {
                try {
                    return v(e), !0;
                } catch (e) {
                    return !1;
                }
            },
            normPrivateKeyToScalar: v,
            randomPrivateKey: ()=>{
                const e = n.getMinHashLength(a.n);
                return n.mapHashToField(a.randomBytes(e), a.n);
            },
            precompute: (e = 8, t = y.BASE)=>(t._setWindowSize(e), t.multiply(BigInt(3)), t)
        };
        function A(e) {
            const t = r.isBytes(e), n = "string" == typeof e, i = (t || n) && e.length;
            return t ? i === h || i === p : n ? i === 2 * h || i === 2 * p : e instanceof y;
        }
        const x = a.bits2int || function(e) {
            const t = r.bytesToNumberBE(e), n = 8 * e.length - a.nBitLength;
            return n > 0 ? t >> BigInt(n) : t;
        }, M = a.bits2int_modN || function(e) {
            return g(x(e));
        }, I = r.bitMask(a.nBitLength);
        function T(e) {
            return r.aInRange(`num < 2^${a.nBitLength}`, e, c, I), r.numberToBytesBE(e, a.nByteLength);
        }
        function R(e, t, n = P) {
            if ([
                "recovered",
                "canonical"
            ].some((e)=>e in n)) throw new Error("sign() legacy options not supported");
            const { hash: s, randomBytes: u } = a;
            let { lowS: h, prehash: f, extraEntropy: p } = n;
            null == h && (h = !0), e = (0, i.ensureBytes)("msgHash", e), o(n), f && (e = (0, i.ensureBytes)("prehashed msgHash", s(e)));
            const b = M(e), E = v(t), _ = [
                T(E),
                T(b)
            ];
            if (null != p && !1 !== p) {
                const e = !0 === p ? u(d.BYTES) : p;
                _.push((0, i.ensureBytes)("extraEntropy", e));
            }
            const k = r.concatBytes(..._), A = b;
            return {
                seed: k,
                k2sig: function(e) {
                    const t = x(e);
                    if (!w(t)) return;
                    const n = m(t), r = y.BASE.multiply(t).toAffine(), i = g(r.x);
                    if (i === c) return;
                    const o = g(n * g(A + i * E));
                    if (o === c) return;
                    let s = (r.x === i ? 0 : 2) | Number(r.y & l), a = o;
                    return h && S(o) && (a = function(e) {
                        return S(e) ? g(-e) : e;
                    }(o), s ^= 1), new C(i, a, s);
                }
            };
        }
        const P = {
            lowS: a.lowS,
            prehash: !1
        }, O = {
            lowS: a.lowS,
            prehash: !1
        };
        return y.BASE._setWindowSize(8), {
            CURVE: a,
            getPublicKey: function(e, t = !0) {
                return y.fromPrivateKey(e).toRawBytes(t);
            },
            getSharedSecret: function(e, t, n = !0) {
                if (A(e)) throw new Error("first arg must be private key");
                if (!A(t)) throw new Error("second arg must be public key");
                const r = y.fromHex(t);
                return r.multiply(v(e)).toRawBytes(n);
            },
            sign: function(e, t, n = P) {
                const { seed: i, k2sig: o } = R(e, t, n), s = a, c = r.createHmacDrbg(s.hash.outputLen, s.nByteLength, s.hmac);
                return c(i, o);
            },
            verify: function(t, n, s, c = O) {
                const l = t;
                if (n = (0, i.ensureBytes)("msgHash", n), s = (0, i.ensureBytes)("publicKey", s), "strict" in c) throw new Error("options.strict was renamed to lowS");
                o(c);
                const { lowS: d, prehash: u } = c;
                let h, f;
                try {
                    if ("string" == typeof l || r.isBytes(l)) try {
                        h = C.fromDER(l);
                    } catch (t) {
                        if (!(t instanceof e.DER.Err)) throw t;
                        h = C.fromCompact(l);
                    }
                    else {
                        if ("object" != typeof l || "bigint" != typeof l.r || "bigint" != typeof l.s) throw new Error("PARSE");
                        {
                            const { r: e, s: t } = l;
                            h = new C(e, t);
                        }
                    }
                    f = y.fromHex(s);
                } catch (e) {
                    if ("PARSE" === e.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
                    return !1;
                }
                if (d && h.hasHighS()) return !1;
                u && (n = a.hash(n));
                const { r: p, s: v } = h, b = M(n), w = m(v), E = g(b * w), S = g(p * w), _ = y.BASE.multiplyAndAddUnsafe(f, E, S)?.toAffine();
                if (!_) return !1;
                const k = g(_.x);
                return k === p;
            },
            ProjectivePoint: y,
            Signature: C,
            utils: k
        };
    }, e.SWUFpSqrtRatio = p, e.mapToCurveSimpleSWU = function(e, t) {
        if (n.validateField(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
        const r = p(e, t.Z);
        if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
        return (n)=>{
            let i, o, s, a, c, l, d, u;
            i = e.sqr(n), i = e.mul(i, t.Z), o = e.sqr(i), o = e.add(o, i), s = e.add(o, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), a = e.mul(a, t.A), o = e.sqr(s), l = e.sqr(a), c = e.mul(l, t.A), o = e.add(o, c), o = e.mul(o, s), l = e.mul(l, a), c = e.mul(l, t.B), o = e.add(o, c), d = e.mul(i, s);
            const { isValid: h, value: f } = r(o, l);
            u = e.mul(i, n), u = e.mul(u, f), d = e.cmov(d, s, h), u = e.cmov(u, f, h);
            const p = e.isOdd(n) === e.isOdd(u);
            return u = e.cmov(e.neg(u), u, p), d = e.div(d, a), {
                x: d,
                y: u
            };
        };
    };
    const t = Pt, n = Ot, r = Nt, i = Nt;
    function o(e) {
        void 0 !== e.lowS && (0, i.abool)("lowS", e.lowS), void 0 !== e.prehash && (0, i.abool)("prehash", e.prehash);
    }
    const { bytesToNumberBE: s, hexToBytes: a } = r;
    e.DER = {
        Err: class extends Error {
            constructor(e = ""){
                super(e);
            }
        },
        _tlv: {
            encode: (t, n)=>{
                const { Err: i } = e.DER;
                if (t < 0 || t > 256) throw new i("tlv.encode: wrong tag");
                if (1 & n.length) throw new i("tlv.encode: unpadded data");
                const o = n.length / 2, s = r.numberToHexUnpadded(o);
                if (s.length / 2 & 128) throw new i("tlv.encode: long form length too big");
                const a = o > 127 ? r.numberToHexUnpadded(s.length / 2 | 128) : "";
                return `${r.numberToHexUnpadded(t)}${a}${s}${n}`;
            },
            decode (t, n) {
                const { Err: r } = e.DER;
                let i = 0;
                if (t < 0 || t > 256) throw new r("tlv.encode: wrong tag");
                if (n.length < 2 || n[i++] !== t) throw new r("tlv.decode: wrong tlv");
                const o = n[i++];
                let s = 0;
                if (!!(128 & o)) {
                    const e = 127 & o;
                    if (!e) throw new r("tlv.decode(long): indefinite length not supported");
                    if (e > 4) throw new r("tlv.decode(long): byte length is too big");
                    const t = n.subarray(i, i + e);
                    if (t.length !== e) throw new r("tlv.decode: length bytes not complete");
                    if (0 === t[0]) throw new r("tlv.decode(long): zero leftmost byte");
                    for (const e of t)s = s << 8 | e;
                    if (i += e, s < 128) throw new r("tlv.decode(long): not minimal encoding");
                } else s = o;
                const a = n.subarray(i, i + s);
                if (a.length !== s) throw new r("tlv.decode: wrong value length");
                return {
                    v: a,
                    l: n.subarray(i + s)
                };
            }
        },
        _int: {
            encode (t) {
                const { Err: n } = e.DER;
                if (t < c) throw new n("integer: negative integers are not allowed");
                let i = r.numberToHexUnpadded(t);
                if (8 & Number.parseInt(i[0], 16) && (i = "00" + i), 1 & i.length) throw new n("unexpected assertion");
                return i;
            },
            decode (t) {
                const { Err: n } = e.DER;
                if (128 & t[0]) throw new n("Invalid signature integer: negative");
                if (0 === t[0] && !(128 & t[1])) throw new n("Invalid signature integer: unnecessary leading zero");
                return s(t);
            }
        },
        toSig (t) {
            const { Err: n, _int: i, _tlv: o } = e.DER, s = "string" == typeof t ? a(t) : t;
            r.abytes(s);
            const { v: c, l: l } = o.decode(48, s);
            if (l.length) throw new n("Invalid signature: left bytes after parsing");
            const { v: d, l: u } = o.decode(2, c), { v: h, l: f } = o.decode(2, u);
            if (f.length) throw new n("Invalid signature: left bytes after parsing");
            return {
                r: i.decode(d),
                s: i.decode(h)
            };
        },
        hexFromSig (t) {
            const { _tlv: n, _int: r } = e.DER, i = `${n.encode(2, r.encode(t.r))}${n.encode(2, r.encode(t.s))}`;
            return n.encode(48, i);
        }
    };
    const c = BigInt(0), l = BigInt(1), d = BigInt(2), u = BigInt(3), h = BigInt(4);
    function f(e) {
        const o = function(e) {
            const n = (0, t.validateBasic)(e);
            r.validateObject(n, {
                a: "field",
                b: "field"
            }, {
                allowedPrivateKeyLengths: "array",
                wrapPrivateKey: "boolean",
                isTorsionFree: "function",
                clearCofactor: "function",
                allowInfinityPoint: "boolean",
                fromBytes: "function",
                toBytes: "function"
            });
            const { endo: i, Fp: o, a: s } = n;
            if (i) {
                if (!o.eql(s, o.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                if ("object" != typeof i || "bigint" != typeof i.beta || "function" != typeof i.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
            }
            return Object.freeze({
                ...n
            });
        }(e), { Fp: s } = o, a = n.Field(o.n, o.nBitLength), d = o.toBytes || ((e, t, n)=>{
            const i = t.toAffine();
            return r.concatBytes(Uint8Array.from([
                4
            ]), s.toBytes(i.x), s.toBytes(i.y));
        }), h = o.fromBytes || ((e)=>{
            const t = e.subarray(1);
            return {
                x: s.fromBytes(t.subarray(0, s.BYTES)),
                y: s.fromBytes(t.subarray(s.BYTES, 2 * s.BYTES))
            };
        });
        function f(e) {
            const { a: t, b: n } = o, r = s.sqr(e), i = s.mul(r, e);
            return s.add(s.add(i, s.mul(e, t)), n);
        }
        if (!s.eql(s.sqr(o.Gy), f(o.Gx))) throw new Error("bad generator point: equation left != right");
        function p(e) {
            const { allowedPrivateKeyLengths: t, nByteLength: s, wrapPrivateKey: a, n: c } = o;
            if (t && "bigint" != typeof e) {
                if (r.isBytes(e) && (e = r.bytesToHex(e)), "string" != typeof e || !t.includes(e.length)) throw new Error("Invalid key");
                e = e.padStart(2 * s, "0");
            }
            let d;
            try {
                d = "bigint" == typeof e ? e : r.bytesToNumberBE((0, i.ensureBytes)("private key", e, s));
            } catch (t) {
                throw new Error(`private key must be ${s} bytes, hex or bigint, not ${typeof e}`);
            }
            return a && (d = n.mod(d, c)), r.aInRange("private key", d, l, c), d;
        }
        function g(e) {
            if (!(e instanceof v)) throw new Error("ProjectivePoint expected");
        }
        const m = (0, i.memoized)((e, t)=>{
            const { px: n, py: r, pz: i } = e;
            if (s.eql(i, s.ONE)) return {
                x: n,
                y: r
            };
            const o = e.is0();
            null == t && (t = o ? s.ONE : s.inv(i));
            const a = s.mul(n, t), c = s.mul(r, t), l = s.mul(i, t);
            if (o) return {
                x: s.ZERO,
                y: s.ZERO
            };
            if (!s.eql(l, s.ONE)) throw new Error("invZ was invalid");
            return {
                x: a,
                y: c
            };
        }), y = (0, i.memoized)((e)=>{
            if (e.is0()) {
                if (o.allowInfinityPoint && !s.is0(e.py)) return;
                throw new Error("bad point: ZERO");
            }
            const { x: t, y: n } = e.toAffine();
            if (!s.isValid(t) || !s.isValid(n)) throw new Error("bad point: x or y not FE");
            const r = s.sqr(n), i = f(t);
            if (!s.eql(r, i)) throw new Error("bad point: equation left != right");
            if (!e.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
            return !0;
        });
        class v {
            constructor(e, t, n){
                if (this.px = e, this.py = t, this.pz = n, null == e || !s.isValid(e)) throw new Error("x required");
                if (null == t || !s.isValid(t)) throw new Error("y required");
                if (null == n || !s.isValid(n)) throw new Error("z required");
                Object.freeze(this);
            }
            static fromAffine(e) {
                const { x: t, y: n } = e || {};
                if (!e || !s.isValid(t) || !s.isValid(n)) throw new Error("invalid affine point");
                if (e instanceof v) throw new Error("projective point not allowed");
                const r = (e)=>s.eql(e, s.ZERO);
                return r(t) && r(n) ? v.ZERO : new v(t, n, s.ONE);
            }
            get x() {
                return this.toAffine().x;
            }
            get y() {
                return this.toAffine().y;
            }
            static normalizeZ(e) {
                const t = s.invertBatch(e.map((e)=>e.pz));
                return e.map((e, n)=>e.toAffine(t[n])).map(v.fromAffine);
            }
            static fromHex(e) {
                const t = v.fromAffine(h((0, i.ensureBytes)("pointHex", e)));
                return t.assertValidity(), t;
            }
            static fromPrivateKey(e) {
                return v.BASE.multiply(p(e));
            }
            static msm(e, n) {
                return (0, t.pippenger)(v, a, e, n);
            }
            _setWindowSize(e) {
                w.setWindowSize(this, e);
            }
            assertValidity() {
                y(this);
            }
            hasEvenY() {
                const { y: e } = this.toAffine();
                if (s.isOdd) return !s.isOdd(e);
                throw new Error("Field doesn't support isOdd");
            }
            equals(e) {
                g(e);
                const { px: t, py: n, pz: r } = this, { px: i, py: o, pz: a } = e, c = s.eql(s.mul(t, a), s.mul(i, r)), l = s.eql(s.mul(n, a), s.mul(o, r));
                return c && l;
            }
            negate() {
                return new v(this.px, s.neg(this.py), this.pz);
            }
            double() {
                const { a: e, b: t } = o, n = s.mul(t, u), { px: r, py: i, pz: a } = this;
                let c = s.ZERO, l = s.ZERO, d = s.ZERO, h = s.mul(r, r), f = s.mul(i, i), p = s.mul(a, a), g = s.mul(r, i);
                return g = s.add(g, g), d = s.mul(r, a), d = s.add(d, d), c = s.mul(e, d), l = s.mul(n, p), l = s.add(c, l), c = s.sub(f, l), l = s.add(f, l), l = s.mul(c, l), c = s.mul(g, c), d = s.mul(n, d), p = s.mul(e, p), g = s.sub(h, p), g = s.mul(e, g), g = s.add(g, d), d = s.add(h, h), h = s.add(d, h), h = s.add(h, p), h = s.mul(h, g), l = s.add(l, h), p = s.mul(i, a), p = s.add(p, p), h = s.mul(p, g), c = s.sub(c, h), d = s.mul(p, f), d = s.add(d, d), d = s.add(d, d), new v(c, l, d);
            }
            add(e) {
                g(e);
                const { px: t, py: n, pz: r } = this, { px: i, py: a, pz: c } = e;
                let l = s.ZERO, d = s.ZERO, h = s.ZERO;
                const f = o.a, p = s.mul(o.b, u);
                let m = s.mul(t, i), y = s.mul(n, a), b = s.mul(r, c), w = s.add(t, n), E = s.add(i, a);
                w = s.mul(w, E), E = s.add(m, y), w = s.sub(w, E), E = s.add(t, r);
                let S = s.add(i, c);
                return E = s.mul(E, S), S = s.add(m, b), E = s.sub(E, S), S = s.add(n, r), l = s.add(a, c), S = s.mul(S, l), l = s.add(y, b), S = s.sub(S, l), h = s.mul(f, E), l = s.mul(p, b), h = s.add(l, h), l = s.sub(y, h), h = s.add(y, h), d = s.mul(l, h), y = s.add(m, m), y = s.add(y, m), b = s.mul(f, b), E = s.mul(p, E), y = s.add(y, b), b = s.sub(m, b), b = s.mul(f, b), E = s.add(E, b), m = s.mul(y, E), d = s.add(d, m), m = s.mul(S, E), l = s.mul(w, l), l = s.sub(l, m), m = s.mul(w, y), h = s.mul(S, h), h = s.add(h, m), new v(l, d, h);
            }
            subtract(e) {
                return this.add(e.negate());
            }
            is0() {
                return this.equals(v.ZERO);
            }
            wNAF(e) {
                return w.wNAFCached(this, e, v.normalizeZ);
            }
            multiplyUnsafe(e) {
                r.aInRange("scalar", e, c, o.n);
                const t = v.ZERO;
                if (e === c) return t;
                if (e === l) return this;
                const { endo: n } = o;
                if (!n) return w.unsafeLadder(this, e);
                let { k1neg: i, k1: a, k2neg: d, k2: u } = n.splitScalar(e), h = t, f = t, p = this;
                for(; a > c || u > c;)a & l && (h = h.add(p)), u & l && (f = f.add(p)), p = p.double(), a >>= l, u >>= l;
                return i && (h = h.negate()), d && (f = f.negate()), f = new v(s.mul(f.px, n.beta), f.py, f.pz), h.add(f);
            }
            multiply(e) {
                const { endo: t, n: n } = o;
                let i, a;
                if (r.aInRange("scalar", e, l, n), t) {
                    const { k1neg: n, k1: r, k2neg: o, k2: c } = t.splitScalar(e);
                    let { p: l, f: d } = this.wNAF(r), { p: u, f: h } = this.wNAF(c);
                    l = w.constTimeNegate(n, l), u = w.constTimeNegate(o, u), u = new v(s.mul(u.px, t.beta), u.py, u.pz), i = l.add(u), a = d.add(h);
                } else {
                    const { p: t, f: n } = this.wNAF(e);
                    i = t, a = n;
                }
                return v.normalizeZ([
                    i,
                    a
                ])[0];
            }
            multiplyAndAddUnsafe(e, t, n) {
                const r = v.BASE, i = (e, t)=>t !== c && t !== l && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t), o = i(this, t).add(i(e, n));
                return o.is0() ? void 0 : o;
            }
            toAffine(e) {
                return m(this, e);
            }
            isTorsionFree() {
                const { h: e, isTorsionFree: t } = o;
                if (e === l) return !0;
                if (t) return t(v, this);
                throw new Error("isTorsionFree() has not been declared for the elliptic curve");
            }
            clearCofactor() {
                const { h: e, clearCofactor: t } = o;
                return e === l ? this : t ? t(v, this) : this.multiplyUnsafe(o.h);
            }
            toRawBytes(e = !0) {
                return (0, i.abool)("isCompressed", e), this.assertValidity(), d(v, this, e);
            }
            toHex(e = !0) {
                return (0, i.abool)("isCompressed", e), r.bytesToHex(this.toRawBytes(e));
            }
        }
        v.BASE = new v(o.Gx, o.Gy, s.ONE), v.ZERO = new v(s.ZERO, s.ONE, s.ZERO);
        const b = o.nBitLength, w = (0, t.wNAF)(v, o.endo ? Math.ceil(b / 2) : b);
        return {
            CURVE: o,
            ProjectivePoint: v,
            normPrivateKeyToScalar: p,
            weierstrassEquation: f,
            isWithinCurveOrder: function(e) {
                return r.inRange(e, l, o.n);
            }
        };
    }
    function p(e, t) {
        const n = e.ORDER;
        let r = c;
        for(let e = n - l; e % d === c; e /= d)r += l;
        const i = r, o = d << i - l - l, s = o * d, a = (n - l) / s, f = (a - l) / d, p = s - l, g = o, m = e.pow(t, a), y = e.pow(t, (a + l) / d);
        let v = (t, n)=>{
            let r = m, o = e.pow(n, p), s = e.sqr(o);
            s = e.mul(s, n);
            let a = e.mul(t, s);
            a = e.pow(a, f), a = e.mul(a, o), o = e.mul(a, n), s = e.mul(a, t);
            let c = e.mul(s, o);
            a = e.pow(c, g);
            let u = e.eql(a, e.ONE);
            o = e.mul(s, y), a = e.mul(c, r), s = e.cmov(o, s, u), c = e.cmov(a, c, u);
            for(let t = i; t > l; t--){
                let n = t - d;
                n = d << n - l;
                let i = e.pow(c, n);
                const a = e.eql(i, e.ONE);
                o = e.mul(s, r), r = e.mul(r, r), i = e.mul(c, r), s = e.cmov(o, s, a), c = e.cmov(i, c, a);
            }
            return {
                isValid: u,
                value: s
            };
        };
        if (e.ORDER % h === u) {
            const n = (e.ORDER - u) / h, r = e.sqrt(e.neg(t));
            v = (t, i)=>{
                let o = e.sqr(i);
                const s = e.mul(t, i);
                o = e.mul(o, s);
                let a = e.pow(o, n);
                a = e.mul(a, s);
                const c = e.mul(a, r), l = e.mul(e.sqr(a), i), d = e.eql(l, t);
                return {
                    isValid: d,
                    value: e.cmov(c, a, d)
                };
            };
        }
        return v;
    }
}(cr), Object.defineProperty(sr, "__esModule", {
    value: !0
}), sr.getHash = hr, sr.createCurve = function(e, t) {
    const n = (t)=>(0, ur.weierstrass)({
            ...e,
            ...hr(t)
        });
    return Object.freeze({
        ...n(t),
        create: n
    });
};
const lr = ar, dr = ze, ur = cr;
function hr(e) {
    return {
        hash: e,
        hmac: (t, ...n)=>(0, lr.hmac)(e, t, (0, dr.concatBytes)(...n)),
        randomBytes: dr.randomBytes
    };
}
!function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
    const t = Qn, n = ze, r = sr, i = Dn, o = Ot, s = Nt, a = cr, c = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), l = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), d = BigInt(1), u = BigInt(2), h = (e, t)=>(e + t / u) / t;
    function f(e) {
        const t = c, n = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), a = BigInt(23), l = BigInt(44), d = BigInt(88), h = e * e * e % t, f = h * h * e % t, g = (0, o.pow2)(f, n, t) * f % t, m = (0, o.pow2)(g, n, t) * f % t, y = (0, o.pow2)(m, u, t) * h % t, v = (0, o.pow2)(y, i, t) * y % t, b = (0, o.pow2)(v, s, t) * v % t, w = (0, o.pow2)(b, l, t) * b % t, E = (0, o.pow2)(w, d, t) * w % t, S = (0, o.pow2)(E, l, t) * b % t, _ = (0, o.pow2)(S, n, t) * f % t, C = (0, o.pow2)(_, a, t) * v % t, k = (0, o.pow2)(C, r, t) * h % t, A = (0, o.pow2)(k, u, t);
        if (!p.eql(p.sqr(A), e)) throw new Error("Cannot find square root");
        return A;
    }
    const p = (0, o.Field)(c, void 0, void 0, {
        sqrt: f
    });
    e.secp256k1 = (0, r.createCurve)({
        a: BigInt(0),
        b: BigInt(7),
        Fp: p,
        n: l,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: (e)=>{
                const t = l, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -d * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s = n, a = BigInt("0x100000000000000000000000000000000"), c = h(s * e, t), u = h(-r * e, t);
                let f = (0, o.mod)(e - c * n - u * i, t), p = (0, o.mod)(-c * r - u * s, t);
                const g = f > a, m = p > a;
                if (g && (f = t - f), m && (p = t - p), f > a || p > a) throw new Error("splitScalar: Endomorphism failed, k=" + e);
                return {
                    k1neg: g,
                    k1: f,
                    k2neg: m,
                    k2: p
                };
            }
        }
    }, t.sha256);
    const g = BigInt(0), m = {};
    function y(e, ...n) {
        let r = m[e];
        if (void 0 === r) {
            const n = (0, t.sha256)(Uint8Array.from(e, (e)=>e.charCodeAt(0)));
            r = (0, s.concatBytes)(n, n), m[e] = r;
        }
        return (0, t.sha256)((0, s.concatBytes)(r, ...n));
    }
    const v = (e)=>e.toRawBytes(!0).slice(1), b = (e)=>(0, s.numberToBytesBE)(e, 32), w = (e)=>(0, o.mod)(e, c), E = (e)=>(0, o.mod)(e, l), S = e.secp256k1.ProjectivePoint, _ = (e, t, n)=>S.BASE.multiplyAndAddUnsafe(e, t, n);
    function C(t) {
        let n = e.secp256k1.utils.normPrivateKeyToScalar(t), r = S.fromPrivateKey(n);
        return {
            scalar: r.hasEvenY() ? n : E(-n),
            bytes: v(r)
        };
    }
    function k(e) {
        (0, s.aInRange)("x", e, d, c);
        const t = w(e * e);
        let n = f(w(t * e + BigInt(7)));
        n % u !== g && (n = w(-n));
        const r = new S(e, n, d);
        return r.assertValidity(), r;
    }
    const A = s.bytesToNumberBE;
    function x(...e) {
        return E(A(y("BIP0340/challenge", ...e)));
    }
    function M(e) {
        return C(e).bytes;
    }
    function I(e, t, r = (0, n.randomBytes)(32)) {
        const i = (0, s.ensureBytes)("message", e), { bytes: o, scalar: a } = C(t), c = (0, s.ensureBytes)("auxRand", r, 32), l = b(a ^ A(y("BIP0340/aux", c))), d = y("BIP0340/nonce", l, o, i), u = E(A(d));
        if (u === g) throw new Error("sign failed: k is zero");
        const { bytes: h, scalar: f } = C(u), p = x(h, o, i), m = new Uint8Array(64);
        if (m.set(h, 0), m.set(b(E(f + p * a)), 32), !T(m, i, o)) throw new Error("sign: Invalid signature produced");
        return m;
    }
    function T(e, t, n) {
        const r = (0, s.ensureBytes)("signature", e, 64), i = (0, s.ensureBytes)("message", t), o = (0, s.ensureBytes)("publicKey", n, 32);
        try {
            const e = k(A(o)), t = A(r.subarray(0, 32));
            if (!(0, s.inRange)(t, d, c)) return !1;
            const n = A(r.subarray(32, 64));
            if (!(0, s.inRange)(n, d, l)) return !1;
            const a = x(b(t), v(e), i), u = _(e, n, E(-a));
            return !(!u || !u.hasEvenY() || u.toAffine().x !== t);
        } catch (e) {
            return !1;
        }
    }
    e.schnorr = {
        getPublicKey: M,
        sign: I,
        verify: T,
        utils: {
            randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
            lift_x: k,
            pointToBytes: v,
            numberToBytesBE: s.numberToBytesBE,
            bytesToNumberBE: s.bytesToNumberBE,
            taggedHash: y,
            mod: o.mod
        }
    };
    const R = (()=>(0, i.isogenyMap)(p, [
            [
                "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
                "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
                "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
                "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
            ],
            [
                "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
                "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ],
            [
                "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
                "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
                "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
                "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
            ],
            [
                "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
                "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
                "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ]
        ].map((e)=>e.map((e)=>BigInt(e)))))(), P = (()=>(0, a.mapToCurveSimpleSWU)(p, {
            A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
            B: BigInt("1771"),
            Z: p.create(BigInt("-11"))
        }))(), O = (()=>(0, i.createHasher)(e.secp256k1.ProjectivePoint, (e)=>{
            const { x: t, y: n } = P(p.create(e[0]));
            return R(t, n);
        }, {
            DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
            encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
            p: p.ORDER,
            m: 1,
            k: 128,
            expand: "xmd",
            hash: t.sha256
        }))();
    e.hashToCurve = O.hashToCurve, e.encodeToCurve = O.encodeToCurve;
}(Jn);
var fr = {};
!function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.decodeHex = e.remove0x = void 0;
    var t = pe;
    e.remove0x = function(e) {
        return e.startsWith("0x") || e.startsWith("0X") ? e.slice(2) : e;
    };
    e.decodeHex = function(n) {
        return (0, t.hexToBytes)((0, e.remove0x)(n));
    };
}(fr), function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.hexToPublicKey = e.convertPublicKeyFormat = e.getSharedPoint = e.getPublicKey = e.isValidPrivateKey = e.getValidSecret = void 0;
    var t = Te, n = Pe, r = Jn, i = Ce, o = ke, s = fr;
    e.getValidSecret = function() {
        var n;
        do {
            n = (0, t.randomBytes)(o.SECRET_KEY_LENGTH);
        }while (!(0, e.isValidPrivateKey)(n))
        return n;
    };
    e.isValidPrivateKey = function(e) {
        return a((0, i.ellipticCurve)(), function(t) {
            return t.utils.isValidPrivateKey(e);
        }, function() {
            return !0;
        }, function() {
            return !0;
        });
    };
    e.getPublicKey = function(e) {
        return a((0, i.ellipticCurve)(), function(t) {
            return t.getPublicKey(e);
        }, function(t) {
            return t.getPublicKey(e);
        }, function(t) {
            return t.getPublicKey(e);
        });
    };
    e.getSharedPoint = function(e, t, n) {
        return a((0, i.ellipticCurve)(), function(r) {
            return r.getSharedSecret(e, t, n);
        }, function(n) {
            return n.getSharedSecret(e, t);
        }, function(n) {
            return l(n, e, t);
        });
    };
    e.convertPublicKeyFormat = function(e, t) {
        return a((0, i.ellipticCurve)(), function(n) {
            return n.getSharedSecret(BigInt(1), e, t);
        }, function() {
            return e;
        }, function() {
            return e;
        });
    };
    function a(e, t, i, o) {
        if ("secp256k1" === e) return t(r.secp256k1);
        if ("x25519" === e) return i(n.x25519);
        if ("ed25519" === e) return o(n.ed25519);
        throw new Error("Not implemented");
    }
    e.hexToPublicKey = function(e) {
        var t = (0, s.decodeHex)(e);
        return a((0, i.ellipticCurve)(), function() {
            return c(t);
        }, function() {
            return t;
        }, function() {
            return t;
        });
    };
    var c = function(e) {
        if (e.length === o.ETH_PUBLIC_KEY_SIZE) {
            var t = new Uint8Array(1 + e.length);
            return t.set([
                4
            ]), t.set(e, 1), t;
        }
        return e;
    }, l = function(e, t, n) {
        var r = e.utils.getExtendedPublicKey(t).scalar;
        return e.ExtendedPoint.fromHex(n).multiply(r).toRawBytes();
    };
}(Ie);
var pr = {}, gr = {};
Object.defineProperty(gr, "__esModule", {
    value: !0
}), gr.hkdf = void 0, gr.extract = br, gr.expand = Sr;
const mr = Le, yr = ze, vr = ar;
function br(e, t, n) {
    return (0, mr.hash)(e), void 0 === n && (n = new Uint8Array(e.outputLen)), (0, vr.hmac)(e, (0, yr.toBytes)(n), (0, yr.toBytes)(t));
}
const wr = new Uint8Array([
    0
]), Er = new Uint8Array;
function Sr(e, t, n, r = 32) {
    if ((0, mr.hash)(e), (0, mr.number)(r), r > 255 * e.outputLen) throw new Error("Length should be <= 255*HashLen");
    const i = Math.ceil(r / e.outputLen);
    void 0 === n && (n = Er);
    const o = new Uint8Array(i * e.outputLen), s = vr.hmac.create(e, t), a = s._cloneInto(), c = new Uint8Array(s.outputLen);
    for(let t = 0; t < i; t++)wr[0] = t + 1, a.update(0 === t ? Er : c).update(n).update(wr).digestInto(c), o.set(c, e.outputLen * t), s._cloneInto(a);
    return s.destroy(), a.destroy(), c.fill(0), wr.fill(0), o.slice(0, r);
}
gr.hkdf = (e, t, n, r, i)=>Sr(e, br(e, t, n), r, i), function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getSharedKey = e.deriveKey = void 0;
    var t = pe, n = gr, r = Qn;
    e.deriveKey = function(e, t, i) {
        return (0, n.hkdf)(r.sha256, e, t, i, 32);
    };
    e.getSharedKey = function() {
        for(var n = [], r = 0; r < arguments.length; r++)n[r] = arguments[r];
        return (0, e.deriveKey)(t.concatBytes.apply(void 0, n));
    };
}(pr);
var _r = {}, Cr = {}, kr = {}, Ar = {};
Object.defineProperty(Ar, "__esModule", {
    value: !0
}), Ar.polyval = Ar.ghash = void 0, Ar._toGHASHKey = Or;
const xr = ge, Mr = pe, Ir = 16, Tr = new Uint8Array(16), Rr = (0, Mr.u32)(Tr), Pr = (e)=>(e >>> 0 & 255) << 24 | (e >>> 8 & 255) << 16 | (e >>> 16 & 255) << 8 | e >>> 24 & 255 | 0;
function Or(e) {
    e.reverse();
    const t = 1 & e[15];
    let n = 0;
    for(let t = 0; t < e.length; t++){
        const r = e[t];
        e[t] = r >>> 1 | n, n = (1 & r) << 7;
    }
    return e[0] ^= 225 & -t, e;
}
class Nr {
    constructor(e, t){
        this.blockLen = Ir, this.outputLen = Ir, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = !1, e = (0, Mr.toBytes)(e), (0, xr.bytes)(e, 16);
        const n = (0, Mr.createView)(e);
        let r = n.getUint32(0, !1), i = n.getUint32(4, !1), o = n.getUint32(8, !1), s = n.getUint32(12, !1);
        const a = [];
        for(let e = 0; e < 128; e++)a.push({
            s0: Pr(r),
            s1: Pr(i),
            s2: Pr(o),
            s3: Pr(s)
        }), { s0: r, s1: i, s2: o, s3: s } = {
            s3: (d = o) << 31 | (u = s) >>> 1,
            s2: (l = i) << 31 | d >>> 1,
            s1: (c = r) << 31 | l >>> 1,
            s0: c >>> 1 ^ 225 << 24 & -(1 & u)
        };
        var c, l, d, u;
        const h = ((e)=>e > 65536 ? 8 : e > 1024 ? 4 : 2)(t || 1024);
        if (![
            1,
            2,
            4,
            8
        ].includes(h)) throw new Error(`ghash: wrong window size=${h}, should be 2, 4 or 8`);
        this.W = h;
        const f = 128 / h, p = this.windowSize = 2 ** h, g = [];
        for(let e = 0; e < f; e++)for(let t = 0; t < p; t++){
            let n = 0, r = 0, i = 0, o = 0;
            for(let s = 0; s < h; s++){
                if (!(t >>> h - s - 1 & 1)) continue;
                const { s0: c, s1: l, s2: d, s3: u } = a[h * e + s];
                n ^= c, r ^= l, i ^= d, o ^= u;
            }
            g.push({
                s0: n,
                s1: r,
                s2: i,
                s3: o
            });
        }
        this.t = g;
    }
    _updateBlock(e, t, n, r) {
        e ^= this.s0, t ^= this.s1, n ^= this.s2, r ^= this.s3;
        const { W: i, t: o, windowSize: s } = this;
        let a = 0, c = 0, l = 0, d = 0;
        const u = (1 << i) - 1;
        let h = 0;
        for (const f of [
            e,
            t,
            n,
            r
        ])for(let e = 0; e < 4; e++){
            const t = f >>> 8 * e & 255;
            for(let e = 8 / i - 1; e >= 0; e--){
                const n = t >>> i * e & u, { s0: r, s1: f, s2: p, s3: g } = o[h * s + n];
                a ^= r, c ^= f, l ^= p, d ^= g, h += 1;
            }
        }
        this.s0 = a, this.s1 = c, this.s2 = l, this.s3 = d;
    }
    update(e) {
        e = (0, Mr.toBytes)(e), (0, xr.exists)(this);
        const t = (0, Mr.u32)(e), n = Math.floor(e.length / Ir), r = e.length % Ir;
        for(let e = 0; e < n; e++)this._updateBlock(t[4 * e + 0], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]);
        return r && (Tr.set(e.subarray(n * Ir)), this._updateBlock(Rr[0], Rr[1], Rr[2], Rr[3]), (0, Mr.clean)(Rr)), this;
    }
    destroy() {
        const { t: e } = this;
        for (const t of e)t.s0 = 0, t.s1 = 0, t.s2 = 0, t.s3 = 0;
    }
    digestInto(e) {
        (0, xr.exists)(this), (0, xr.output)(e, this), this.finished = !0;
        const { s0: t, s1: n, s2: r, s3: i } = this, o = (0, Mr.u32)(e);
        return o[0] = t, o[1] = n, o[2] = r, o[3] = i, e;
    }
    digest() {
        const e = new Uint8Array(Ir);
        return this.digestInto(e), this.destroy(), e;
    }
}
class Lr extends Nr {
    constructor(e, t){
        e = (0, Mr.toBytes)(e);
        const n = Or((0, Mr.copyBytes)(e));
        super(n, t), (0, Mr.clean)(n);
    }
    update(e) {
        e = (0, Mr.toBytes)(e), (0, xr.exists)(this);
        const t = (0, Mr.u32)(e), n = e.length % Ir, r = Math.floor(e.length / Ir);
        for(let e = 0; e < r; e++)this._updateBlock(Pr(t[4 * e + 3]), Pr(t[4 * e + 2]), Pr(t[4 * e + 1]), Pr(t[4 * e + 0]));
        return n && (Tr.set(e.subarray(r * Ir)), this._updateBlock(Pr(Rr[3]), Pr(Rr[2]), Pr(Rr[1]), Pr(Rr[0])), (0, Mr.clean)(Rr)), this;
    }
    digestInto(e) {
        (0, xr.exists)(this), (0, xr.output)(e, this), this.finished = !0;
        const { s0: t, s1: n, s2: r, s3: i } = this, o = (0, Mr.u32)(e);
        return o[0] = t, o[1] = n, o[2] = r, o[3] = i, e.reverse();
    }
}
function Dr(e) {
    const t = (t, n)=>e(n, t.length).update((0, Mr.toBytes)(t)).digest(), n = e(new Uint8Array(16), 0);
    return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = (t, n)=>e(t, n), t;
}
Ar.ghash = Dr((e, t)=>new Nr(e, t)), Ar.polyval = Dr((e, t)=>new Lr(e, t)), Object.defineProperty(kr, "__esModule", {
    value: !0
}), kr.unsafe = kr.aeskwp = kr.aeskw = kr.siv = kr.gcm = kr.cfb = kr.cbc = kr.ecb = kr.ctr = void 0, kr.expandKeyLE = ei, kr.expandKeyDecLE = ti;
const $r = ge, Br = Ar, Kr = pe, jr = 16, Ur = new Uint8Array(jr), Hr = 283;
function Fr(e) {
    return e << 1 ^ Hr & -(e >> 7);
}
function zr(e, t) {
    let n = 0;
    for(; t > 0; t >>= 1)n ^= e & -(1 & t), e = Fr(e);
    return n;
}
const qr = (()=>{
    const e = new Uint8Array(256);
    for(let t = 0, n = 1; t < 256; t++, n ^= Fr(n))e[t] = n;
    const t = new Uint8Array(256);
    t[0] = 99;
    for(let n = 0; n < 255; n++){
        let r = e[255 - n];
        r |= r << 8, t[e[n]] = 255 & (r ^ r >> 4 ^ r >> 5 ^ r >> 6 ^ r >> 7 ^ 99);
    }
    return (0, Kr.clean)(e), t;
})(), Wr = qr.map((e, t)=>qr.indexOf(t)), Vr = (e)=>e << 24 | e >>> 8, Gr = (e)=>e << 8 | e >>> 24, Yr = (e)=>e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
function Zr(e, t) {
    if (256 !== e.length) throw new Error("Wrong sbox length");
    const n = new Uint32Array(256).map((n, r)=>t(e[r])), r = n.map(Gr), i = r.map(Gr), o = i.map(Gr), s = new Uint32Array(65536), a = new Uint32Array(65536), c = new Uint16Array(65536);
    for(let t = 0; t < 256; t++)for(let l = 0; l < 256; l++){
        const d = 256 * t + l;
        s[d] = n[t] ^ r[l], a[d] = i[t] ^ o[l], c[d] = e[t] << 8 | e[l];
    }
    return {
        sbox: e,
        sbox2: c,
        T0: n,
        T1: r,
        T2: i,
        T3: o,
        T01: s,
        T23: a
    };
}
const Jr = Zr(qr, (e)=>zr(e, 3) << 24 | e << 16 | e << 8 | zr(e, 2)), Qr = Zr(Wr, (e)=>zr(e, 11) << 24 | zr(e, 13) << 16 | zr(e, 9) << 8 | zr(e, 14)), Xr = (()=>{
    const e = new Uint8Array(16);
    for(let t = 0, n = 1; t < 16; t++, n = Fr(n))e[t] = n;
    return e;
})();
function ei(e) {
    (0, $r.bytes)(e);
    const t = e.length;
    if (![
        16,
        24,
        32
    ].includes(t)) throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t}`);
    const { sbox2: n } = Jr, r = [];
    (0, Kr.isAligned32)(e) || r.push(e = (0, Kr.copyBytes)(e));
    const i = (0, Kr.u32)(e), o = i.length, s = (e)=>ri(n, e, e, e, e), a = new Uint32Array(t + 28);
    a.set(i);
    for(let e = o; e < a.length; e++){
        let t = a[e - 1];
        e % o == 0 ? t = s(Vr(t)) ^ Xr[e / o - 1] : o > 6 && e % o == 4 && (t = s(t)), a[e] = a[e - o] ^ t;
    }
    return (0, Kr.clean)(...r), a;
}
function ti(e) {
    const t = ei(e), n = t.slice(), r = t.length, { sbox2: i } = Jr, { T0: o, T1: s, T2: a, T3: c } = Qr;
    for(let e = 0; e < r; e += 4)for(let i = 0; i < 4; i++)n[e + i] = t[r - e - 4 + i];
    (0, Kr.clean)(t);
    for(let e = 4; e < r - 4; e++){
        const t = n[e], r = ri(i, t, t, t, t);
        n[e] = o[255 & r] ^ s[r >>> 8 & 255] ^ a[r >>> 16 & 255] ^ c[r >>> 24];
    }
    return n;
}
function ni(e, t, n, r, i, o) {
    return e[n << 8 & 65280 | r >>> 8 & 255] ^ t[i >>> 8 & 65280 | o >>> 24 & 255];
}
function ri(e, t, n, r, i) {
    return e[255 & t | 65280 & n] | e[r >>> 16 & 255 | i >>> 16 & 65280] << 16;
}
function ii(e, t, n, r, i) {
    const { sbox2: o, T01: s, T23: a } = Jr;
    let c = 0;
    t ^= e[c++], n ^= e[c++], r ^= e[c++], i ^= e[c++];
    const l = e.length / 4 - 2;
    for(let o = 0; o < l; o++){
        const o = e[c++] ^ ni(s, a, t, n, r, i), l = e[c++] ^ ni(s, a, n, r, i, t), d = e[c++] ^ ni(s, a, r, i, t, n), u = e[c++] ^ ni(s, a, i, t, n, r);
        t = o, n = l, r = d, i = u;
    }
    return {
        s0: e[c++] ^ ri(o, t, n, r, i),
        s1: e[c++] ^ ri(o, n, r, i, t),
        s2: e[c++] ^ ri(o, r, i, t, n),
        s3: e[c++] ^ ri(o, i, t, n, r)
    };
}
function oi(e, t, n, r, i) {
    const { sbox2: o, T01: s, T23: a } = Qr;
    let c = 0;
    t ^= e[c++], n ^= e[c++], r ^= e[c++], i ^= e[c++];
    const l = e.length / 4 - 2;
    for(let o = 0; o < l; o++){
        const o = e[c++] ^ ni(s, a, t, i, r, n), l = e[c++] ^ ni(s, a, n, t, i, r), d = e[c++] ^ ni(s, a, r, n, t, i), u = e[c++] ^ ni(s, a, i, r, n, t);
        t = o, n = l, r = d, i = u;
    }
    return {
        s0: e[c++] ^ ri(o, t, i, r, n),
        s1: e[c++] ^ ri(o, n, t, i, r),
        s2: e[c++] ^ ri(o, r, n, t, i),
        s3: e[c++] ^ ri(o, i, r, n, t)
    };
}
function si(e, t) {
    if (void 0 === t) return new Uint8Array(e);
    if ((0, $r.bytes)(t), t.length < e) throw new Error(`aes: wrong destination length, expected at least ${e}, got: ${t.length}`);
    if (!(0, Kr.isAligned32)(t)) throw new Error("unaligned dst");
    return t;
}
function ai(e, t, n, r) {
    (0, $r.bytes)(t, jr), (0, $r.bytes)(n);
    const i = n.length;
    r = si(i, r);
    const o = t, s = (0, Kr.u32)(o);
    let { s0: a, s1: c, s2: l, s3: d } = ii(e, s[0], s[1], s[2], s[3]);
    const u = (0, Kr.u32)(n), h = (0, Kr.u32)(r);
    for(let t = 0; t + 4 <= u.length; t += 4){
        h[t + 0] = u[t + 0] ^ a, h[t + 1] = u[t + 1] ^ c, h[t + 2] = u[t + 2] ^ l, h[t + 3] = u[t + 3] ^ d;
        let n = 1;
        for(let e = o.length - 1; e >= 0; e--)n = n + (255 & o[e]) | 0, o[e] = 255 & n, n >>>= 8;
        ({ s0: a, s1: c, s2: l, s3: d } = ii(e, s[0], s[1], s[2], s[3]));
    }
    const f = jr * Math.floor(u.length / 4);
    if (f < i) {
        const e = new Uint32Array([
            a,
            c,
            l,
            d
        ]), t = (0, Kr.u8)(e);
        for(let e = f, o = 0; e < i; e++, o++)r[e] = n[e] ^ t[o];
        (0, Kr.clean)(e);
    }
    return r;
}
function ci(e, t, n, r, i) {
    (0, $r.bytes)(n, jr), (0, $r.bytes)(r), i = si(r.length, i);
    const o = n, s = (0, Kr.u32)(o), a = (0, Kr.createView)(o), c = (0, Kr.u32)(r), l = (0, Kr.u32)(i), d = t ? 0 : 12, u = r.length;
    let h = a.getUint32(d, t), { s0: f, s1: p, s2: g, s3: m } = ii(e, s[0], s[1], s[2], s[3]);
    for(let n = 0; n + 4 <= c.length; n += 4)l[n + 0] = c[n + 0] ^ f, l[n + 1] = c[n + 1] ^ p, l[n + 2] = c[n + 2] ^ g, l[n + 3] = c[n + 3] ^ m, h = h + 1 >>> 0, a.setUint32(d, h, t), { s0: f, s1: p, s2: g, s3: m } = ii(e, s[0], s[1], s[2], s[3]);
    const y = jr * Math.floor(c.length / 4);
    if (y < u) {
        const e = new Uint32Array([
            f,
            p,
            g,
            m
        ]), t = (0, Kr.u8)(e);
        for(let e = y, n = 0; e < u; e++, n++)i[e] = r[e] ^ t[n];
        (0, Kr.clean)(e);
    }
    return i;
}
function li(e) {
    if ((0, $r.bytes)(e), e.length % jr != 0) throw new Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16");
}
function di(e, t, n) {
    (0, $r.bytes)(e);
    let r = e.length;
    const i = r % jr;
    if (!t && 0 !== i) throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
    (0, Kr.isAligned32)(e) || (e = (0, Kr.copyBytes)(e));
    const o = (0, Kr.u32)(e);
    if (t) {
        let e = jr - i;
        e || (e = jr), r += e;
    }
    const s = si(r, n);
    return {
        b: o,
        o: (0, Kr.u32)(s),
        out: s
    };
}
function ui(e, t) {
    if (!t) return e;
    const n = e.length;
    if (!n) throw new Error("aes/pcks5: empty ciphertext not allowed");
    const r = e[n - 1];
    if (r <= 0 || r > 16) throw new Error("aes/pcks5: wrong padding");
    const i = e.subarray(0, -r);
    for(let t = 0; t < r; t++)if (e[n - t - 1] !== r) throw new Error("aes/pcks5: wrong padding");
    return i;
}
function hi(e) {
    const t = new Uint8Array(16), n = (0, Kr.u32)(t);
    t.set(e);
    const r = jr - e.length;
    for(let e = jr - r; e < jr; e++)t[e] = r;
    return n;
}
function fi(e, t, n, r, i) {
    const o = null == i ? 0 : i.length, s = e.create(n, r.length + o);
    i && s.update(i), s.update(r);
    const a = new Uint8Array(16), c = (0, Kr.createView)(a);
    i && (0, Kr.setBigUint64)(c, 0, BigInt(8 * o), t), (0, Kr.setBigUint64)(c, 8, BigInt(8 * r.length), t), s.update(a);
    const l = s.digest();
    return (0, Kr.clean)(a), l;
}
kr.ctr = (0, Kr.wrapCipher)({
    blockSize: 16,
    nonceLength: 16
}, function(e, t) {
    function n(n, r) {
        if ((0, $r.bytes)(n), void 0 !== r && ((0, $r.bytes)(r), !(0, Kr.isAligned32)(r))) throw new Error("unaligned destination");
        const i = ei(e), o = (0, Kr.copyBytes)(t), s = [
            i,
            o
        ];
        (0, Kr.isAligned32)(n) || s.push(n = (0, Kr.copyBytes)(n));
        const a = ai(i, o, n, r);
        return (0, Kr.clean)(...s), a;
    }
    return (0, $r.bytes)(e), (0, $r.bytes)(t, jr), {
        encrypt: (e, t)=>n(e, t),
        decrypt: (e, t)=>n(e, t)
    };
}), kr.ecb = (0, Kr.wrapCipher)({
    blockSize: 16
}, function(e, t = {}) {
    (0, $r.bytes)(e);
    const n = !t.disablePadding;
    return {
        encrypt (t, r) {
            const { b: i, o: o, out: s } = di(t, n, r), a = ei(e);
            let c = 0;
            for(; c + 4 <= i.length;){
                const { s0: e, s1: t, s2: n, s3: r } = ii(a, i[c + 0], i[c + 1], i[c + 2], i[c + 3]);
                o[c++] = e, o[c++] = t, o[c++] = n, o[c++] = r;
            }
            if (n) {
                const e = hi(t.subarray(4 * c)), { s0: n, s1: r, s2: i, s3: s } = ii(a, e[0], e[1], e[2], e[3]);
                o[c++] = n, o[c++] = r, o[c++] = i, o[c++] = s;
            }
            return (0, Kr.clean)(a), s;
        },
        decrypt (t, r) {
            li(t);
            const i = ti(e), o = si(t.length, r), s = [
                i
            ];
            (0, Kr.isAligned32)(t) || s.push(t = (0, Kr.copyBytes)(t));
            const a = (0, Kr.u32)(t), c = (0, Kr.u32)(o);
            for(let e = 0; e + 4 <= a.length;){
                const { s0: t, s1: n, s2: r, s3: o } = oi(i, a[e + 0], a[e + 1], a[e + 2], a[e + 3]);
                c[e++] = t, c[e++] = n, c[e++] = r, c[e++] = o;
            }
            return (0, Kr.clean)(...s), ui(o, n);
        }
    };
}), kr.cbc = (0, Kr.wrapCipher)({
    blockSize: 16,
    nonceLength: 16
}, function(e, t, n = {}) {
    (0, $r.bytes)(e), (0, $r.bytes)(t, 16);
    const r = !n.disablePadding;
    return {
        encrypt (n, i) {
            const o = ei(e), { b: s, o: a, out: c } = di(n, r, i);
            let l = t;
            const d = [
                o
            ];
            (0, Kr.isAligned32)(l) || d.push(l = (0, Kr.copyBytes)(l));
            const u = (0, Kr.u32)(l);
            let h = u[0], f = u[1], p = u[2], g = u[3], m = 0;
            for(; m + 4 <= s.length;)h ^= s[m + 0], f ^= s[m + 1], p ^= s[m + 2], g ^= s[m + 3], ({ s0: h, s1: f, s2: p, s3: g } = ii(o, h, f, p, g)), a[m++] = h, a[m++] = f, a[m++] = p, a[m++] = g;
            if (r) {
                const e = hi(n.subarray(4 * m));
                h ^= e[0], f ^= e[1], p ^= e[2], g ^= e[3], ({ s0: h, s1: f, s2: p, s3: g } = ii(o, h, f, p, g)), a[m++] = h, a[m++] = f, a[m++] = p, a[m++] = g;
            }
            return (0, Kr.clean)(...d), c;
        },
        decrypt (n, i) {
            li(n);
            const o = ti(e);
            let s = t;
            const a = [
                o
            ];
            (0, Kr.isAligned32)(s) || a.push(s = (0, Kr.copyBytes)(s));
            const c = (0, Kr.u32)(s), l = si(n.length, i);
            (0, Kr.isAligned32)(n) || a.push(n = (0, Kr.copyBytes)(n));
            const d = (0, Kr.u32)(n), u = (0, Kr.u32)(l);
            let h = c[0], f = c[1], p = c[2], g = c[3];
            for(let e = 0; e + 4 <= d.length;){
                const t = h, n = f, r = p, i = g;
                h = d[e + 0], f = d[e + 1], p = d[e + 2], g = d[e + 3];
                const { s0: s, s1: a, s2: c, s3: l } = oi(o, h, f, p, g);
                u[e++] = s ^ t, u[e++] = a ^ n, u[e++] = c ^ r, u[e++] = l ^ i;
            }
            return (0, Kr.clean)(...a), ui(l, r);
        }
    };
}), kr.cfb = (0, Kr.wrapCipher)({
    blockSize: 16,
    nonceLength: 16
}, function(e, t) {
    function n(n, r, i) {
        (0, $r.bytes)(n);
        const o = n.length;
        i = si(o, i);
        const s = ei(e);
        let a = t;
        const c = [
            s
        ];
        (0, Kr.isAligned32)(a) || c.push(a = (0, Kr.copyBytes)(a)), (0, Kr.isAligned32)(n) || c.push(n = (0, Kr.copyBytes)(n));
        const l = (0, Kr.u32)(n), d = (0, Kr.u32)(i), u = r ? d : l, h = (0, Kr.u32)(a);
        let f = h[0], p = h[1], g = h[2], m = h[3];
        for(let e = 0; e + 4 <= l.length;){
            const { s0: t, s1: n, s2: r, s3: i } = ii(s, f, p, g, m);
            d[e + 0] = l[e + 0] ^ t, d[e + 1] = l[e + 1] ^ n, d[e + 2] = l[e + 2] ^ r, d[e + 3] = l[e + 3] ^ i, f = u[e++], p = u[e++], g = u[e++], m = u[e++];
        }
        const y = jr * Math.floor(l.length / 4);
        if (y < o) {
            ({ s0: f, s1: p, s2: g, s3: m } = ii(s, f, p, g, m));
            const e = (0, Kr.u8)(new Uint32Array([
                f,
                p,
                g,
                m
            ]));
            for(let t = y, r = 0; t < o; t++, r++)i[t] = n[t] ^ e[r];
            (0, Kr.clean)(e);
        }
        return (0, Kr.clean)(...c), i;
    }
    return (0, $r.bytes)(e), (0, $r.bytes)(t, 16), {
        encrypt: (e, t)=>n(e, !0, t),
        decrypt: (e, t)=>n(e, !1, t)
    };
}), kr.gcm = (0, Kr.wrapCipher)({
    blockSize: 16,
    nonceLength: 12,
    tagLength: 16
}, function(e, t, n) {
    if ((0, $r.bytes)(e), (0, $r.bytes)(t), void 0 !== n && (0, $r.bytes)(n), t.length < 8) throw new Error("aes/gcm: invalid nonce length");
    const r = 16;
    function i(e, t, r) {
        const i = fi(Br.ghash, !1, e, r, n);
        for(let e = 0; e < t.length; e++)i[e] ^= t[e];
        return i;
    }
    function o() {
        const n = ei(e), r = Ur.slice(), i = Ur.slice();
        if (ci(n, !1, i, i, r), 12 === t.length) i.set(t);
        else {
            const e = Ur.slice(), n = (0, Kr.createView)(e);
            (0, Kr.setBigUint64)(n, 8, BigInt(8 * t.length), !1);
            const o = Br.ghash.create(r).update(t).update(e);
            o.digestInto(i), o.destroy();
        }
        return {
            xk: n,
            authKey: r,
            counter: i,
            tagMask: ci(n, !1, i, Ur)
        };
    }
    return {
        encrypt (e) {
            (0, $r.bytes)(e);
            const { xk: t, authKey: n, counter: s, tagMask: a } = o(), c = new Uint8Array(e.length + r), l = [
                t,
                n,
                s,
                a
            ];
            (0, Kr.isAligned32)(e) || l.push(e = (0, Kr.copyBytes)(e)), ci(t, !1, s, e, c);
            const d = i(n, a, c.subarray(0, c.length - r));
            return l.push(d), c.set(d, e.length), (0, Kr.clean)(...l), c;
        },
        decrypt (e) {
            if ((0, $r.bytes)(e), e.length < r) throw new Error("aes/gcm: ciphertext less than tagLen (16)");
            const { xk: t, authKey: n, counter: s, tagMask: a } = o(), c = [
                t,
                n,
                a,
                s
            ];
            (0, Kr.isAligned32)(e) || c.push(e = (0, Kr.copyBytes)(e));
            const l = e.subarray(0, -16), d = e.subarray(-16), u = i(n, a, l);
            if (c.push(u), !(0, Kr.equalBytes)(u, d)) throw new Error("aes/gcm: invalid ghash tag");
            const h = ci(t, !1, s, l);
            return (0, Kr.clean)(...c), h;
        }
    };
});
const pi = (e, t, n)=>(r)=>{
        if (!Number.isSafeInteger(r) || t > r || r > n) throw new Error(`${e}: invalid value=${r}, must be [${t}..${n}]`);
    };
function gi(e) {
    return null != e && "object" == typeof e && (e instanceof Uint32Array || "Uint32Array" === e.constructor.name);
}
function mi(e, t) {
    if ((0, $r.bytes)(t, 16), !gi(e)) throw new Error("_encryptBlock accepts result of expandKeyLE");
    const n = (0, Kr.u32)(t);
    let { s0: r, s1: i, s2: o, s3: s } = ii(e, n[0], n[1], n[2], n[3]);
    return n[0] = r, n[1] = i, n[2] = o, n[3] = s, t;
}
function yi(e, t) {
    if ((0, $r.bytes)(t, 16), !gi(e)) throw new Error("_decryptBlock accepts result of expandKeyLE");
    const n = (0, Kr.u32)(t);
    let { s0: r, s1: i, s2: o, s3: s } = oi(e, n[0], n[1], n[2], n[3]);
    return n[0] = r, n[1] = i, n[2] = o, n[3] = s, t;
}
kr.siv = (0, Kr.wrapCipher)({
    blockSize: 16,
    nonceLength: 12,
    tagLength: 16
}, function(e, t, n) {
    const r = pi("AAD", 0, 2 ** 36), i = pi("plaintext", 0, 2 ** 36), o = pi("nonce", 12, 12), s = pi("ciphertext", 16, 2 ** 36 + 16);
    function a() {
        const n = ei(e), r = new Uint8Array(e.length), i = new Uint8Array(16), o = [
            n,
            r
        ];
        let s = t;
        (0, Kr.isAligned32)(s) || o.push(s = (0, Kr.copyBytes)(s));
        const a = (0, Kr.u32)(s);
        let c = 0, l = a[0], d = a[1], u = a[2], h = 0;
        for (const e of [
            i,
            r
        ].map(Kr.u32)){
            const t = (0, Kr.u32)(e);
            for(let e = 0; e < t.length; e += 2){
                const { s0: r, s1: i } = ii(n, c, l, d, u);
                t[e + 0] = r, t[e + 1] = i, c = ++h;
            }
        }
        const f = {
            authKey: i,
            encKey: ei(r)
        };
        return (0, Kr.clean)(...o), f;
    }
    function c(e, r, i) {
        const o = fi(Br.polyval, !0, r, i, n);
        for(let e = 0; e < 12; e++)o[e] ^= t[e];
        o[15] &= 127;
        const s = (0, Kr.u32)(o);
        let a = s[0], c = s[1], l = s[2], d = s[3];
        return { s0: a, s1: c, s2: l, s3: d } = ii(e, a, c, l, d), s[0] = a, s[1] = c, s[2] = l, s[3] = d, o;
    }
    function l(e, t, n) {
        let r = (0, Kr.copyBytes)(t);
        r[15] |= 128;
        const i = ci(e, !0, r, n);
        return (0, Kr.clean)(r), i;
    }
    return (0, $r.bytes)(e, 16, 24, 32), (0, $r.bytes)(t), o(t.length), void 0 !== n && ((0, $r.bytes)(n), r(n.length)), {
        encrypt (e) {
            (0, $r.bytes)(e), i(e.length);
            const { encKey: t, authKey: n } = a(), r = c(t, n, e), o = [
                t,
                n,
                r
            ];
            (0, Kr.isAligned32)(e) || o.push(e = (0, Kr.copyBytes)(e));
            const s = new Uint8Array(e.length + 16);
            return s.set(r, e.length), s.set(l(t, r, e)), (0, Kr.clean)(...o), s;
        },
        decrypt (e) {
            (0, $r.bytes)(e), s(e.length);
            const t = e.subarray(-16), { encKey: n, authKey: r } = a(), i = [
                n,
                r
            ];
            (0, Kr.isAligned32)(e) || i.push(e = (0, Kr.copyBytes)(e));
            const o = l(n, t, e.subarray(0, -16)), d = c(n, r, o);
            if (i.push(d), !(0, Kr.equalBytes)(t, d)) throw (0, Kr.clean)(...i), new Error("invalid polyval tag");
            return (0, Kr.clean)(...i), o;
        }
    };
});
const vi = {
    encrypt (e, t) {
        if (t.length >= 2 ** 32) throw new Error("plaintext should be less than 4gb");
        const n = ei(e);
        if (16 === t.length) mi(n, t);
        else {
            const e = (0, Kr.u32)(t);
            let r = e[0], i = e[1];
            for(let t = 0, o = 1; t < 6; t++)for(let t = 2; t < e.length; t += 2, o++){
                const { s0: s, s1: a, s2: c, s3: l } = ii(n, r, i, e[t], e[t + 1]);
                r = s, i = a ^ Yr(o), e[t] = c, e[t + 1] = l;
            }
            e[0] = r, e[1] = i;
        }
        n.fill(0);
    },
    decrypt (e, t) {
        if (t.length - 8 >= 2 ** 32) throw new Error("ciphertext should be less than 4gb");
        const n = ti(e), r = t.length / 8 - 1;
        if (1 === r) yi(n, t);
        else {
            const e = (0, Kr.u32)(t);
            let i = e[0], o = e[1];
            for(let t = 0, s = 6 * r; t < 6; t++)for(let t = 2 * r; t >= 1; t -= 2, s--){
                o ^= Yr(s);
                const { s0: r, s1: a, s2: c, s3: l } = oi(n, i, o, e[t], e[t + 1]);
                i = r, o = a, e[t] = c, e[t + 1] = l;
            }
            e[0] = i, e[1] = o;
        }
        n.fill(0);
    }
}, bi = new Uint8Array(8).fill(166);
kr.aeskw = (0, Kr.wrapCipher)({
    blockSize: 8
}, (e)=>({
        encrypt (t) {
            if ((0, $r.bytes)(t), !t.length || t.length % 8 != 0) throw new Error("invalid plaintext length");
            if (8 === t.length) throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
            const n = (0, Kr.concatBytes)(bi, t);
            return vi.encrypt(e, n), n;
        },
        decrypt (t) {
            if ((0, $r.bytes)(t), t.length % 8 != 0 || t.length < 24) throw new Error("invalid ciphertext length");
            const n = (0, Kr.copyBytes)(t);
            if (vi.decrypt(e, n), !(0, Kr.equalBytes)(n.subarray(0, 8), bi)) throw new Error("integrity check failed");
            return n.subarray(0, 8).fill(0), n.subarray(8);
        }
    }));
const wi = 2790873510;
kr.aeskwp = (0, Kr.wrapCipher)({
    blockSize: 8
}, (e)=>({
        encrypt (t) {
            if ((0, $r.bytes)(t), !t.length) throw new Error("invalid plaintext length");
            const n = 8 * Math.ceil(t.length / 8), r = new Uint8Array(8 + n);
            r.set(t, 8);
            const i = (0, Kr.u32)(r);
            return i[0] = wi, i[1] = Yr(t.length), vi.encrypt(e, r), r;
        },
        decrypt (t) {
            if ((0, $r.bytes)(t), t.length < 16) throw new Error("invalid ciphertext length");
            const n = (0, Kr.copyBytes)(t), r = (0, Kr.u32)(n);
            vi.decrypt(e, n);
            const i = Yr(r[1]) >>> 0, o = 8 * Math.ceil(i / 8);
            if (r[0] !== wi || n.length - 8 !== o) throw new Error("integrity check failed");
            for(let e = i; e < o; e++)if (0 !== n[8 + e]) throw new Error("integrity check failed");
            return n.subarray(0, 8).fill(0), n.subarray(8, 8 + i);
        }
    })), kr.unsafe = {
    expandKeyLE: ei,
    expandKeyDecLE: ti,
    encrypt: ii,
    decrypt: oi,
    encryptBlock: mi,
    decryptBlock: yi,
    ctrCounter: ai,
    ctr32: ci
}, Object.defineProperty(Cr, "__esModule", {
    value: !0
}), Cr.aes256cbc = Cr.aes256gcm = void 0;
var Ei = kr;
Cr.aes256gcm = function(e, t, n) {
    return (0, Ei.gcm)(e, t, n);
};
Cr.aes256cbc = function(e, t, n) {
    return (0, Ei.cbc)(e, t);
};
var Si = {}, _i = {}, Ci = {};
Object.defineProperty(Ci, "__esModule", {
    value: !0
}), Ci.sigma = void 0, Ci.rotl = function(e, t) {
    return e << t | e >>> 32 - t;
}, Ci.createCipher = function(e, t) {
    const { allowShortKeys: n, extendNonceFn: r, counterLength: i, counterRight: o, rounds: s } = (0, Ai.checkOpts)({
        allowShortKeys: !1,
        counterLength: 8,
        counterRight: !1,
        rounds: 20
    }, t);
    if ("function" != typeof e) throw new Error("core must be a function");
    return (0, ki.number)(i), (0, ki.number)(s), (0, ki.bool)(o), (0, ki.bool)(n), (t, a, c, l, d = 0)=>{
        (0, ki.bytes)(t), (0, ki.bytes)(a), (0, ki.bytes)(c);
        const u = c.length;
        if (void 0 === l && (l = new Uint8Array(u)), (0, ki.bytes)(l), (0, ki.number)(d), d < 0 || d >= Li) throw new Error("arx: counter overflow");
        if (l.length < u) throw new Error(`arx: output (${l.length}) is shorter than data (${u})`);
        const h = [];
        let f, p, g = t.length;
        if (32 === g) h.push(f = (0, Ai.copyBytes)(t)), p = Ri;
        else {
            if (16 !== g || !n) throw new Error(`arx: invalid 32-byte key, got length=${g}`);
            f = new Uint8Array(32), f.set(t), f.set(t, 16), p = Ti, h.push(f);
        }
        Pi(a) || h.push(a = (0, Ai.copyBytes)(a));
        const m = (0, Ai.u32)(f);
        if (r) {
            if (24 !== a.length) throw new Error("arx: extended nonce must be 24 bytes");
            r(p, m, (0, Ai.u32)(a.subarray(0, 16)), m), a = a.subarray(16);
        }
        const y = 16 - i;
        if (y !== a.length) throw new Error(`arx: nonce must be ${y} or 16 bytes`);
        if (12 !== y) {
            const e = new Uint8Array(12);
            e.set(a, o ? 0 : 12 - a.length), a = e, h.push(a);
        }
        const v = (0, Ai.u32)(a);
        return function(e, t, n, r, i, o, s, a) {
            const c = i.length, l = new Uint8Array(Oi), d = (0, Ai.u32)(l), u = Pi(i) && Pi(o), h = u ? (0, Ai.u32)(i) : Di, f = u ? (0, Ai.u32)(o) : Di;
            for(let p = 0; p < c; s++){
                if (e(t, n, r, d, s, a), s >= Li) throw new Error("arx: counter overflow");
                const g = Math.min(Oi, c - p);
                if (u && g === Oi) {
                    const e = p / 4;
                    if (p % 4 != 0) throw new Error("arx: invalid block position");
                    for(let t, n = 0; n < Ni; n++)t = e + n, f[t] = h[t] ^ d[n];
                    p += Oi;
                } else {
                    for(let e, t = 0; t < g; t++)e = p + t, o[e] = i[e] ^ l[t];
                    p += g;
                }
            }
        }(e, p, m, v, c, l, d, s), (0, Ai.clean)(...h), l;
    };
};
const ki = ge, Ai = pe, xi = (e)=>Uint8Array.from(e.split("").map((e)=>e.charCodeAt(0))), Mi = xi("expand 16-byte k"), Ii = xi("expand 32-byte k"), Ti = (0, Ai.u32)(Mi), Ri = (0, Ai.u32)(Ii);
function Pi(e) {
    return e.byteOffset % 4 == 0;
}
Ci.sigma = Ri.slice();
const Oi = 64, Ni = 16, Li = 2 ** 32 - 1, Di = new Uint32Array;
var $i = {};
Object.defineProperty($i, "__esModule", {
    value: !0
}), $i.poly1305 = void 0, $i.wrapConstructorWithKey = Hi;
const Bi = ge, Ki = pe, ji = (e, t)=>255 & e[t++] | (255 & e[t++]) << 8;
class Ui {
    constructor(e){
        this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = (0, Ki.toBytes)(e), (0, Bi.bytes)(e, 32);
        const t = ji(e, 0), n = ji(e, 2), r = ji(e, 4), i = ji(e, 6), o = ji(e, 8), s = ji(e, 10), a = ji(e, 12), c = ji(e, 14);
        this.r[0] = 8191 & t, this.r[1] = 8191 & (t >>> 13 | n << 3), this.r[2] = 7939 & (n >>> 10 | r << 6), this.r[3] = 8191 & (r >>> 7 | i << 9), this.r[4] = 255 & (i >>> 4 | o << 12), this.r[5] = o >>> 1 & 8190, this.r[6] = 8191 & (o >>> 14 | s << 2), this.r[7] = 8065 & (s >>> 11 | a << 5), this.r[8] = 8191 & (a >>> 8 | c << 8), this.r[9] = c >>> 5 & 127;
        for(let t = 0; t < 8; t++)this.pad[t] = ji(e, 16 + 2 * t);
    }
    process(e, t, n = !1) {
        const r = n ? 0 : 2048, { h: i, r: o } = this, s = o[0], a = o[1], c = o[2], l = o[3], d = o[4], u = o[5], h = o[6], f = o[7], p = o[8], g = o[9], m = ji(e, t + 0), y = ji(e, t + 2), v = ji(e, t + 4), b = ji(e, t + 6), w = ji(e, t + 8), E = ji(e, t + 10), S = ji(e, t + 12), _ = ji(e, t + 14);
        let C = i[0] + (8191 & m), k = i[1] + (8191 & (m >>> 13 | y << 3)), A = i[2] + (8191 & (y >>> 10 | v << 6)), x = i[3] + (8191 & (v >>> 7 | b << 9)), M = i[4] + (8191 & (b >>> 4 | w << 12)), I = i[5] + (w >>> 1 & 8191), T = i[6] + (8191 & (w >>> 14 | E << 2)), R = i[7] + (8191 & (E >>> 11 | S << 5)), P = i[8] + (8191 & (S >>> 8 | _ << 8)), O = i[9] + (_ >>> 5 | r), N = 0, L = N + C * s + k * (5 * g) + A * (5 * p) + x * (5 * f) + M * (5 * h);
        N = L >>> 13, L &= 8191, L += I * (5 * u) + T * (5 * d) + R * (5 * l) + P * (5 * c) + O * (5 * a), N += L >>> 13, L &= 8191;
        let D = N + C * a + k * s + A * (5 * g) + x * (5 * p) + M * (5 * f);
        N = D >>> 13, D &= 8191, D += I * (5 * h) + T * (5 * u) + R * (5 * d) + P * (5 * l) + O * (5 * c), N += D >>> 13, D &= 8191;
        let $ = N + C * c + k * a + A * s + x * (5 * g) + M * (5 * p);
        N = $ >>> 13, $ &= 8191, $ += I * (5 * f) + T * (5 * h) + R * (5 * u) + P * (5 * d) + O * (5 * l), N += $ >>> 13, $ &= 8191;
        let B = N + C * l + k * c + A * a + x * s + M * (5 * g);
        N = B >>> 13, B &= 8191, B += I * (5 * p) + T * (5 * f) + R * (5 * h) + P * (5 * u) + O * (5 * d), N += B >>> 13, B &= 8191;
        let K = N + C * d + k * l + A * c + x * a + M * s;
        N = K >>> 13, K &= 8191, K += I * (5 * g) + T * (5 * p) + R * (5 * f) + P * (5 * h) + O * (5 * u), N += K >>> 13, K &= 8191;
        let j = N + C * u + k * d + A * l + x * c + M * a;
        N = j >>> 13, j &= 8191, j += I * s + T * (5 * g) + R * (5 * p) + P * (5 * f) + O * (5 * h), N += j >>> 13, j &= 8191;
        let U = N + C * h + k * u + A * d + x * l + M * c;
        N = U >>> 13, U &= 8191, U += I * a + T * s + R * (5 * g) + P * (5 * p) + O * (5 * f), N += U >>> 13, U &= 8191;
        let H = N + C * f + k * h + A * u + x * d + M * l;
        N = H >>> 13, H &= 8191, H += I * c + T * a + R * s + P * (5 * g) + O * (5 * p), N += H >>> 13, H &= 8191;
        let F = N + C * p + k * f + A * h + x * u + M * d;
        N = F >>> 13, F &= 8191, F += I * l + T * c + R * a + P * s + O * (5 * g), N += F >>> 13, F &= 8191;
        let z = N + C * g + k * p + A * f + x * h + M * u;
        N = z >>> 13, z &= 8191, z += I * d + T * l + R * c + P * a + O * s, N += z >>> 13, z &= 8191, N = (N << 2) + N | 0, N = N + L | 0, L = 8191 & N, N >>>= 13, D += N, i[0] = L, i[1] = D, i[2] = $, i[3] = B, i[4] = K, i[5] = j, i[6] = U, i[7] = H, i[8] = F, i[9] = z;
    }
    finalize() {
        const { h: e, pad: t } = this, n = new Uint16Array(10);
        let r = e[1] >>> 13;
        e[1] &= 8191;
        for(let t = 2; t < 10; t++)e[t] += r, r = e[t] >>> 13, e[t] &= 8191;
        e[0] += 5 * r, r = e[0] >>> 13, e[0] &= 8191, e[1] += r, r = e[1] >>> 13, e[1] &= 8191, e[2] += r, n[0] = e[0] + 5, r = n[0] >>> 13, n[0] &= 8191;
        for(let t = 1; t < 10; t++)n[t] = e[t] + r, r = n[t] >>> 13, n[t] &= 8191;
        n[9] -= 8192;
        let i = (1 ^ r) - 1;
        for(let e = 0; e < 10; e++)n[e] &= i;
        i = ~i;
        for(let t = 0; t < 10; t++)e[t] = e[t] & i | n[t];
        e[0] = 65535 & (e[0] | e[1] << 13), e[1] = 65535 & (e[1] >>> 3 | e[2] << 10), e[2] = 65535 & (e[2] >>> 6 | e[3] << 7), e[3] = 65535 & (e[3] >>> 9 | e[4] << 4), e[4] = 65535 & (e[4] >>> 12 | e[5] << 1 | e[6] << 14), e[5] = 65535 & (e[6] >>> 2 | e[7] << 11), e[6] = 65535 & (e[7] >>> 5 | e[8] << 8), e[7] = 65535 & (e[8] >>> 8 | e[9] << 5);
        let o = e[0] + t[0];
        e[0] = 65535 & o;
        for(let n = 1; n < 8; n++)o = (e[n] + t[n] | 0) + (o >>> 16) | 0, e[n] = 65535 & o;
        (0, Ki.clean)(n);
    }
    update(e) {
        (0, Bi.exists)(this);
        const { buffer: t, blockLen: n } = this, r = (e = (0, Ki.toBytes)(e)).length;
        for(let i = 0; i < r;){
            const o = Math.min(n - this.pos, r - i);
            if (o !== n) t.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === n && (this.process(t, 0, !1), this.pos = 0);
            else for(; n <= r - i; i += n)this.process(e, i);
        }
        return this;
    }
    destroy() {
        (0, Ki.clean)(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(e) {
        (0, Bi.exists)(this), (0, Bi.output)(e, this), this.finished = !0;
        const { buffer: t, h: n } = this;
        let { pos: r } = this;
        if (r) {
            for(t[r++] = 1; r < 16; r++)t[r] = 0;
            this.process(t, 0, !0);
        }
        this.finalize();
        let i = 0;
        for(let t = 0; t < 8; t++)e[i++] = n[t] >>> 0, e[i++] = n[t] >>> 8;
        return e;
    }
    digest() {
        const { buffer: e, outputLen: t } = this;
        this.digestInto(e);
        const n = e.slice(0, t);
        return this.destroy(), n;
    }
}
function Hi(e) {
    const t = (t, n)=>e(n).update((0, Ki.toBytes)(t)).digest(), n = e(new Uint8Array(32));
    return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = (t)=>e(t), t;
}
$i.poly1305 = Hi((e)=>new Ui(e)), function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.xchacha20poly1305 = e.chacha20poly1305 = e._poly1305_aead = e.chacha12 = e.chacha8 = e.xchacha20 = e.chacha20 = e.chacha20orig = void 0, e.hchacha = s;
    const t = Ci, n = ge, r = $i, i = pe;
    function o(e, n, r, i, o1, s = 20) {
        let a = e[0], c = e[1], l = e[2], d = e[3], u = n[0], h = n[1], f = n[2], p = n[3], g = n[4], m = n[5], y = n[6], v = n[7], b = o1, w = r[0], E = r[1], S = r[2], _ = a, C = c, k = l, A = d, x = u, M = h, I = f, T = p, R = g, P = m, O = y, N = v, L = b, D = w, $ = E, B = S;
        for(let e = 0; e < s; e += 2)_ = _ + x | 0, L = (0, t.rotl)(L ^ _, 16), R = R + L | 0, x = (0, t.rotl)(x ^ R, 12), _ = _ + x | 0, L = (0, t.rotl)(L ^ _, 8), R = R + L | 0, x = (0, t.rotl)(x ^ R, 7), C = C + M | 0, D = (0, t.rotl)(D ^ C, 16), P = P + D | 0, M = (0, t.rotl)(M ^ P, 12), C = C + M | 0, D = (0, t.rotl)(D ^ C, 8), P = P + D | 0, M = (0, t.rotl)(M ^ P, 7), k = k + I | 0, $ = (0, t.rotl)($ ^ k, 16), O = O + $ | 0, I = (0, t.rotl)(I ^ O, 12), k = k + I | 0, $ = (0, t.rotl)($ ^ k, 8), O = O + $ | 0, I = (0, t.rotl)(I ^ O, 7), A = A + T | 0, B = (0, t.rotl)(B ^ A, 16), N = N + B | 0, T = (0, t.rotl)(T ^ N, 12), A = A + T | 0, B = (0, t.rotl)(B ^ A, 8), N = N + B | 0, T = (0, t.rotl)(T ^ N, 7), _ = _ + M | 0, B = (0, t.rotl)(B ^ _, 16), O = O + B | 0, M = (0, t.rotl)(M ^ O, 12), _ = _ + M | 0, B = (0, t.rotl)(B ^ _, 8), O = O + B | 0, M = (0, t.rotl)(M ^ O, 7), C = C + I | 0, L = (0, t.rotl)(L ^ C, 16), N = N + L | 0, I = (0, t.rotl)(I ^ N, 12), C = C + I | 0, L = (0, t.rotl)(L ^ C, 8), N = N + L | 0, I = (0, t.rotl)(I ^ N, 7), k = k + T | 0, D = (0, t.rotl)(D ^ k, 16), R = R + D | 0, T = (0, t.rotl)(T ^ R, 12), k = k + T | 0, D = (0, t.rotl)(D ^ k, 8), R = R + D | 0, T = (0, t.rotl)(T ^ R, 7), A = A + x | 0, $ = (0, t.rotl)($ ^ A, 16), P = P + $ | 0, x = (0, t.rotl)(x ^ P, 12), A = A + x | 0, $ = (0, t.rotl)($ ^ A, 8), P = P + $ | 0, x = (0, t.rotl)(x ^ P, 7);
        let K = 0;
        i[K++] = a + _ | 0, i[K++] = c + C | 0, i[K++] = l + k | 0, i[K++] = d + A | 0, i[K++] = u + x | 0, i[K++] = h + M | 0, i[K++] = f + I | 0, i[K++] = p + T | 0, i[K++] = g + R | 0, i[K++] = m + P | 0, i[K++] = y + O | 0, i[K++] = v + N | 0, i[K++] = b + L | 0, i[K++] = w + D | 0, i[K++] = E + $ | 0, i[K++] = S + B | 0;
    }
    function s(e, n, r, i) {
        let o = e[0], s = e[1], a = e[2], c = e[3], l = n[0], d = n[1], u = n[2], h = n[3], f = n[4], p = n[5], g = n[6], m = n[7], y = r[0], v = r[1], b = r[2], w = r[3];
        for(let e = 0; e < 20; e += 2)o = o + l | 0, y = (0, t.rotl)(y ^ o, 16), f = f + y | 0, l = (0, t.rotl)(l ^ f, 12), o = o + l | 0, y = (0, t.rotl)(y ^ o, 8), f = f + y | 0, l = (0, t.rotl)(l ^ f, 7), s = s + d | 0, v = (0, t.rotl)(v ^ s, 16), p = p + v | 0, d = (0, t.rotl)(d ^ p, 12), s = s + d | 0, v = (0, t.rotl)(v ^ s, 8), p = p + v | 0, d = (0, t.rotl)(d ^ p, 7), a = a + u | 0, b = (0, t.rotl)(b ^ a, 16), g = g + b | 0, u = (0, t.rotl)(u ^ g, 12), a = a + u | 0, b = (0, t.rotl)(b ^ a, 8), g = g + b | 0, u = (0, t.rotl)(u ^ g, 7), c = c + h | 0, w = (0, t.rotl)(w ^ c, 16), m = m + w | 0, h = (0, t.rotl)(h ^ m, 12), c = c + h | 0, w = (0, t.rotl)(w ^ c, 8), m = m + w | 0, h = (0, t.rotl)(h ^ m, 7), o = o + d | 0, w = (0, t.rotl)(w ^ o, 16), g = g + w | 0, d = (0, t.rotl)(d ^ g, 12), o = o + d | 0, w = (0, t.rotl)(w ^ o, 8), g = g + w | 0, d = (0, t.rotl)(d ^ g, 7), s = s + u | 0, y = (0, t.rotl)(y ^ s, 16), m = m + y | 0, u = (0, t.rotl)(u ^ m, 12), s = s + u | 0, y = (0, t.rotl)(y ^ s, 8), m = m + y | 0, u = (0, t.rotl)(u ^ m, 7), a = a + h | 0, v = (0, t.rotl)(v ^ a, 16), f = f + v | 0, h = (0, t.rotl)(h ^ f, 12), a = a + h | 0, v = (0, t.rotl)(v ^ a, 8), f = f + v | 0, h = (0, t.rotl)(h ^ f, 7), c = c + l | 0, b = (0, t.rotl)(b ^ c, 16), p = p + b | 0, l = (0, t.rotl)(l ^ p, 12), c = c + l | 0, b = (0, t.rotl)(b ^ c, 8), p = p + b | 0, l = (0, t.rotl)(l ^ p, 7);
        let E = 0;
        i[E++] = o, i[E++] = s, i[E++] = a, i[E++] = c, i[E++] = y, i[E++] = v, i[E++] = b, i[E++] = w;
    }
    e.chacha20orig = (0, t.createCipher)(o, {
        counterRight: !1,
        counterLength: 8,
        allowShortKeys: !0
    }), e.chacha20 = (0, t.createCipher)(o, {
        counterRight: !1,
        counterLength: 4,
        allowShortKeys: !1
    }), e.xchacha20 = (0, t.createCipher)(o, {
        counterRight: !1,
        counterLength: 8,
        extendNonceFn: s,
        allowShortKeys: !1
    }), e.chacha8 = (0, t.createCipher)(o, {
        counterRight: !1,
        counterLength: 4,
        rounds: 8
    }), e.chacha12 = (0, t.createCipher)(o, {
        counterRight: !1,
        counterLength: 4,
        rounds: 12
    });
    const a = new Uint8Array(16), c = (e, t)=>{
        e.update(t);
        const n = t.length % 16;
        n && e.update(a.subarray(n));
    }, l = new Uint8Array(32);
    function d(e, t, n, o, s) {
        const a = e(t, n, l), d = r.poly1305.create(a);
        s && c(d, s), c(d, o);
        const u = new Uint8Array(16), h = (0, i.createView)(u);
        (0, i.setBigUint64)(h, 0, BigInt(s ? s.length : 0), !0), (0, i.setBigUint64)(h, 8, BigInt(o.length), !0), d.update(u);
        const f = d.digest();
        return (0, i.clean)(a, u), f;
    }
    e._poly1305_aead = (e)=>(t, r, o)=>{
            const s = 16;
            return (0, n.bytes)(t, 32), (0, n.bytes)(r), {
                encrypt (a, c) {
                    const l = a.length, u = l + s;
                    c ? (0, n.bytes)(c, u) : c = new Uint8Array(u), e(t, r, a, c, 1);
                    const h = d(e, t, r, c.subarray(0, -16), o);
                    return c.set(h, l), (0, i.clean)(h), c;
                },
                decrypt (a, c) {
                    const l = a.length, u = l - s;
                    if (l < s) throw new Error("encrypted data must be at least 16 bytes");
                    c ? (0, n.bytes)(c, u) : c = new Uint8Array(u);
                    const h = a.subarray(0, -16), f = a.subarray(-16), p = d(e, t, r, h, o);
                    if (!(0, i.equalBytes)(f, p)) throw new Error("invalid tag");
                    return e(t, r, h, c, 1), (0, i.clean)(p), c;
                }
            };
        }, e.chacha20poly1305 = (0, i.wrapCipher)({
        blockSize: 64,
        nonceLength: 12,
        tagLength: 16
    }, (0, e._poly1305_aead)(e.chacha20)), e.xchacha20poly1305 = (0, i.wrapCipher)({
        blockSize: 64,
        nonceLength: 24,
        tagLength: 16
    }, (0, e._poly1305_aead)(e.xchacha20));
}(_i), Object.defineProperty(Si, "__esModule", {
    value: !0
}), Si.xchacha20 = void 0;
var Fi, zi, qi, Wi = _i;
Si.xchacha20 = function(e, t, n) {
    return (0, Wi.xchacha20poly1305)(e, t, n);
}, function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.aesDecrypt = e.aesEncrypt = e.symDecrypt = e.symEncrypt = void 0;
    var t = pe, n = Te, r = Cr, i = Si, o = Ce, s = ke;
    e.symEncrypt = function(e, t, n) {
        return a(c, e, t, n);
    };
    function a(e, t, n, a) {
        var c = (0, o.symmetricAlgorithm)();
        if ("aes-256-gcm" === c) return e(r.aes256gcm, t, n, (0, o.symmetricNonceLength)(), s.AEAD_TAG_LENGTH, a);
        if ("xchacha20" === c) return e(i.xchacha20, t, n, s.XCHACHA20_NONCE_LENGTH, s.AEAD_TAG_LENGTH, a);
        if ("aes-256-cbc" === c) return e(r.aes256cbc, t, n, 16, 0);
        throw new Error("Not implemented");
    }
    function c(e, r, i, o, s, a) {
        var c = (0, n.randomBytes)(o), l = e(r, c, a).encrypt(i);
        if (0 === s) return (0, t.concatBytes)(c, l);
        var d = l.length - s, u = l.subarray(0, d), h = l.subarray(d);
        return (0, t.concatBytes)(c, h, u);
    }
    function l(e, n, r, i, o, s) {
        var a = r.subarray(0, i), c = e(n, Uint8Array.from(a), s), l = r.subarray(i);
        if (0 === o) return c.decrypt(l);
        var d = l.subarray(0, o), u = l.subarray(o);
        return c.decrypt((0, t.concatBytes)(u, d));
    }
    e.symDecrypt = function(e, t, n) {
        return a(l, e, t, n);
    }, e.aesEncrypt = e.symEncrypt, e.aesDecrypt = e.symDecrypt;
}(_r), Fi = Me, zi = de && de.__createBinding || (Object.create ? function(e, t, n, r) {
    void 0 === r && (r = n);
    var i = Object.getOwnPropertyDescriptor(t, n);
    i && !("get" in i ? !t.__esModule : i.writable || i.configurable) || (i = {
        enumerable: !0,
        get: function() {
            return t[n];
        }
    }), Object.defineProperty(e, r, i);
} : function(e, t, n, r) {
    void 0 === r && (r = n), e[r] = t[n];
}), qi = de && de.__exportStar || function(e, t) {
    for(var n in e)"default" === n || Object.prototype.hasOwnProperty.call(t, n) || zi(t, e, n);
}, Object.defineProperty(Fi, "__esModule", {
    value: !0
}), qi(Ie, Fi), qi(pr, Fi), qi(fr, Fi), qi(_r, Fi);
var Vi = {};
Object.defineProperty(Vi, "__esModule", {
    value: !0
}), Vi.PublicKey = void 0;
var Gi = pe, Yi = Me, Zi = function() {
    function e(e) {
        this.data = (0, Yi.convertPublicKeyFormat)(e, !0);
    }
    return e.fromHex = function(t) {
        return new e((0, Yi.hexToPublicKey)(t));
    }, Object.defineProperty(e.prototype, "uncompressed", {
        get: function() {
            return C.from((0, Yi.convertPublicKeyFormat)(this.data, !1));
        },
        enumerable: !1,
        configurable: !0
    }), Object.defineProperty(e.prototype, "compressed", {
        get: function() {
            return C.from(this.data);
        },
        enumerable: !1,
        configurable: !0
    }), e.prototype.toHex = function(e) {
        return void 0 === e && (e = !0), (0, Gi.bytesToHex)(e ? this.data : this.uncompressed);
    }, e.prototype.decapsulate = function(e, t) {
        void 0 === t && (t = !1);
        var n = t ? this.data : this.uncompressed, r = e.multiply(this, t);
        return (0, Yi.getSharedKey)(n, r);
    }, e.prototype.equals = function(e) {
        return (0, Gi.equalBytes)(this.data, e.data);
    }, e;
}();
Vi.PublicKey = Zi, Object.defineProperty(xe, "__esModule", {
    value: !0
}), xe.PrivateKey = void 0;
var Ji = pe, Qi = Me, Xi = Vi, eo = function() {
    function e(e) {
        if (void 0 === e) this.data = (0, Qi.getValidSecret)();
        else {
            if (!(0, Qi.isValidPrivateKey)(e)) throw new Error("Invalid private key");
            this.data = e;
        }
        this.publicKey = new Xi.PublicKey((0, Qi.getPublicKey)(this.data));
    }
    return e.fromHex = function(t) {
        return new e((0, Qi.decodeHex)(t));
    }, Object.defineProperty(e.prototype, "secret", {
        get: function() {
            return C.from(this.data);
        },
        enumerable: !1,
        configurable: !0
    }), e.prototype.toHex = function() {
        return (0, Ji.bytesToHex)(this.data);
    }, e.prototype.encapsulate = function(e, t) {
        void 0 === t && (t = !1);
        var n = t ? this.publicKey.compressed : this.publicKey.uncompressed, r = this.multiply(e, t);
        return (0, Qi.getSharedKey)(n, r);
    }, e.prototype.multiply = function(e, t) {
        return void 0 === t && (t = !1), (0, Qi.getSharedPoint)(this.data, e.compressed, t);
    }, e.prototype.equals = function(e) {
        return (0, Ji.equalBytes)(this.data, e.data);
    }, e;
}();
xe.PrivateKey = eo, function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.PublicKey = e.PrivateKey = void 0;
    var t = xe;
    Object.defineProperty(e, "PrivateKey", {
        enumerable: !0,
        get: function() {
            return t.PrivateKey;
        }
    });
    var n = Vi;
    Object.defineProperty(e, "PublicKey", {
        enumerable: !0,
        get: function() {
            return n.PublicKey;
        }
    });
}(Ae), function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.utils = e.PublicKey = e.PrivateKey = e.ECIES_CONFIG = void 0, e.encrypt = function(e, o) {
        var s = new r.PrivateKey, a = e instanceof Uint8Array ? new r.PublicKey(e) : r.PublicKey.fromHex(e), c = s.encapsulate(a, (0, n.isHkdfKeyCompressed)()), l = (0, n.isEphemeralKeyCompressed)() ? s.publicKey.compressed : s.publicKey.uncompressed, d = (0, i.symEncrypt)(c, o);
        return C.from((0, t.concatBytes)(l, d));
    }, e.decrypt = function(e, t) {
        var o = e instanceof Uint8Array ? new r.PrivateKey(e) : r.PrivateKey.fromHex(e), s = (0, n.ephemeralKeySize)(), a = new r.PublicKey(t.subarray(0, s)), c = t.subarray(s), l = a.decapsulate(o, (0, n.isHkdfKeyCompressed)());
        return C.from((0, i.symDecrypt)(l, c));
    };
    var t = pe, n = Ce, r = Ae, i = Me;
    var o = Ce;
    Object.defineProperty(e, "ECIES_CONFIG", {
        enumerable: !0,
        get: function() {
            return o.ECIES_CONFIG;
        }
    });
    var s = Ae;
    Object.defineProperty(e, "PrivateKey", {
        enumerable: !0,
        get: function() {
            return s.PrivateKey;
        }
    }), Object.defineProperty(e, "PublicKey", {
        enumerable: !0,
        get: function() {
            return s.PublicKey;
        }
    }), e.utils = {
        aesEncrypt: i.aesEncrypt,
        aesDecrypt: i.aesDecrypt,
        symEncrypt: i.symEncrypt,
        symDecrypt: i.symDecrypt,
        decodeHex: i.decodeHex,
        getValidSecret: i.getValidSecret,
        remove0x: i.remove0x
    };
}(fe);
const to = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("KeyExchange:Layer"), no = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("SocketService:Layer"), ro = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("Ecies:Layer"), io = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("RemoteCommunication:Layer");
to.color = "##95c44e", no.color = "#f638d7", ro.color = "#465b9c", io.color = "#47a2be";
const oo = {
    KeyExchange: to,
    SocketService: no,
    Ecies: ro,
    RemoteCommunication: io
};
let so, ao = [], co = [];
const lo = (t, n)=>c(void 0, void 0, void 0, function*() {
        so = n, co.push(t), (function(t) {
            return c(this, void 0, void 0, function*() {
                if (!so || !t) return;
                !function() {
                    const e = co;
                    co = ao, ao = e;
                }();
                const n = so.endsWith("/") ? `${so}evt` : `${so}/evt`, r = Object.assign({}, t);
                if (delete r.params, t.params) for (const [e, n] of Object.entries(t.params))r[e] = n;
                const i = JSON.stringify(r);
                oo.RemoteCommunication(`[sendBufferedEvents] Sending ${ao.length} analytics events to ${n}`);
                try {
                    const t = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$node$2d$ponyfill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(n, {
                        method: "POST",
                        headers: {
                            Accept: "application/json",
                            "Content-Type": "application/json"
                        },
                        body: i
                    }), r = yield t.text();
                    oo.RemoteCommunication(`[sendBufferedEvents] Response: ${r}`), ao.length = 0;
                } catch (n) {}
            });
        })(t).catch(()=>{});
    });
class uo {
    constructor(e){
        this.enabled = !0, (null == e ? void 0 : e.debug) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].enable("Ecies:Layer"), this.ecies = (null == e ? void 0 : e.privateKey) ? fe.PrivateKey.fromHex(e.privateKey) : new fe.PrivateKey, oo.Ecies("[ECIES constructor()] initialized secret: ", this.ecies.toHex()), oo.Ecies("[ECIES constructor()] initialized public: ", this.ecies.publicKey.toHex()), oo.Ecies("[ECIES constructor()] init with", this);
    }
    generateECIES() {
        this.ecies = new fe.PrivateKey;
    }
    getPublicKey() {
        return this.ecies.publicKey.toHex();
    }
    encrypt(e, t) {
        let n = e;
        if (this.enabled) try {
            oo.Ecies("[ECIES: encrypt()] using otherPublicKey", t);
            const r = C.from(e), i = fe.encrypt(t, r);
            n = C.from(i).toString("base64");
        } catch (n) {
            throw oo.Ecies("[ECIES: encrypt()] error encrypt:", n), oo.Ecies("[ECIES: encrypt()] private: ", this.ecies.toHex()), oo.Ecies("[ECIES: encrypt()] data: ", e), oo.Ecies("[ECIES: encrypt()] otherkey: ", t), n;
        }
        return n;
    }
    decrypt(e) {
        let t = e;
        if (this.enabled) try {
            oo.Ecies("[ECIES: decrypt()] using privateKey", this.ecies.toHex());
            const n = C.from(e.toString(), "base64");
            t = fe.decrypt(this.ecies.toHex(), n).toString();
        } catch (t) {
            throw oo.Ecies("[ECIES: decrypt()] error decrypt", t), oo.Ecies("[ECIES: decrypt()] private: ", this.ecies.toHex()), oo.Ecies("[ECIES: decrypt()] encryptedData: ", e), t;
        }
        return t;
    }
    getKeyInfo() {
        return {
            private: this.ecies.toHex(),
            public: this.ecies.publicKey.toHex()
        };
    }
    toString() {
        oo.Ecies("[ECIES: toString()]", this.getKeyInfo());
    }
}
var ho = {
    name: "@metamask/sdk-communication-layer",
    version: "0.33.1",
    description: "",
    homepage: "https://github.com/MetaMask/metamask-sdk#readme",
    bugs: {
        url: "https://github.com/MetaMask/metamask-sdk/issues"
    },
    repository: {
        type: "git",
        url: "https://github.com/MetaMask/metamask-sdk.git",
        directory: "packages/sdk-communication-layer"
    },
    main: "dist/node/cjs/metamask-sdk-communication-layer.js",
    unpkg: "dist/browser/umd/metamask-sdk-communication-layer.js",
    module: "dist/node/es/metamask-sdk-communication-layer.js",
    browser: "dist/browser/es/metamask-sdk-communication-layer.js",
    "react-native": "dist/react-native/es/metamask-sdk-communication-layer.js",
    types: "dist/types/src/index.d.ts",
    files: [
        "/dist"
    ],
    scripts: {
        "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types",
        "build:clean": "yarn clean && yarn build",
        build: "yarn build:types && rollup -c --bundleConfigAsCjs",
        "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs",
        dev: 'concurrently "tsc --watch" "rollup -c --bundleConfigAsCjs -w"',
        "build:post-tsc": "echo 'N/A'",
        "build:pre-tsc": "echo 'N/A'",
        size: "size-limit",
        clean: "rimraf ./dist",
        lint: "yarn lint:eslint && yarn lint:misc --check",
        "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk-communication-layer",
        "lint:eslint": "eslint . --cache --ext js,ts",
        "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write",
        "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore",
        "publish:preview": "yarn npm publish --tag preview",
        prepack: "../../scripts/prepack.sh",
        reset: "yarn clean && rimraf ./node_modules/",
        test: 'jest --testPathIgnorePatterns "/e2e/"',
        "test:e2e": 'jest --testPathPattern "/e2e/"',
        "test:coverage": "jest --coverage",
        "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"',
        "test:dev": "jest",
        watch: "rollup -c --bundleConfigAsCjs -w"
    },
    dependencies: {
        "@metamask/sdk-analytics": "workspace:*",
        bufferutil: "^4.0.8",
        "date-fns": "^2.29.3",
        debug: "4.3.4",
        "utf-8-validate": "^5.0.2",
        uuid: "^8.3.2"
    },
    devDependencies: {
        "@jest/globals": "^29.3.1",
        "@lavamoat/allow-scripts": "^2.3.1",
        "@metamask/auto-changelog": "3.1.0",
        "@metamask/eslint-config": "^6.0.0",
        "@metamask/eslint-config-nodejs": "^6.0.0",
        "@metamask/eslint-config-typescript": "^6.0.0",
        "@rollup/plugin-commonjs": "^25.0.0",
        "@rollup/plugin-json": "^6.0.0",
        "@rollup/plugin-node-resolve": "^15.0.2",
        "@rollup/plugin-replace": "^6.0.1",
        "@rollup/plugin-terser": "^0.4.4",
        "@size-limit/preset-big-lib": "^11.0.2",
        "@types/jest": "^29.2.4",
        "@types/node": "^20.1.3",
        "@types/uuid": "^9.0.0",
        "@typescript-eslint/eslint-plugin": "^4.26.0",
        "@typescript-eslint/parser": "^4.26.0",
        concurrently: "^9.1.2",
        "cross-fetch": "^4.0.0",
        eciesjs: "^0.4.11",
        eslint: "^7.30.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.23.4",
        "eslint-plugin-jest": "^24.4.0",
        "eslint-plugin-jsdoc": "^36.1.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^3.4.0",
        eventemitter2: "^6.4.9",
        jest: "^29.3.1",
        prettier: "^2.3.0",
        rimraf: "^3.0.2",
        rollup: "^4.26.0",
        "rollup-plugin-jscc": "^2.0.0",
        "rollup-plugin-natives": "^0.7.5",
        "rollup-plugin-node-builtins": "^2.1.2",
        "rollup-plugin-node-globals": "^1.4.0",
        "rollup-plugin-peer-deps-external": "^2.2.4",
        "rollup-plugin-polyfill-node": "^0.13.0",
        "rollup-plugin-sizes": "^1.0.6",
        "rollup-plugin-typescript2": "^0.31.2",
        "rollup-plugin-visualizer": "^5.12.0",
        "size-limit": "^11.1.6",
        "socket.io-client": "^4.5.1",
        "stream-browserify": "^3.0.0",
        "ts-jest": "^29.0.3",
        "ts-node": "^10.9.1",
        typescript: "^5.6.3"
    },
    peerDependencies: {
        "cross-fetch": "^4.0.0",
        eciesjs: "*",
        eventemitter2: "^6.4.9",
        "readable-stream": "^3.6.2",
        "socket.io-client": "^4.5.1"
    },
    publishConfig: {
        access: "public",
        registry: "https://registry.npmjs.org/"
    },
    lavamoat: {
        allowScripts: {
            "@lavamoat/preinstall-always-fail": !1,
            canvas: !0,
            "eciesjs>secp256k1": !1,
            "socket.io-client>engine.io-client>ws>bufferutil": !1,
            "socket.io-client>engine.io-client>ws>utf-8-validate": !1,
            bufferutil: !1,
            "utf-8-validate": !1
        }
    }
};
const fo = "https://metamask-sdk.api.cx.metamask.io/", po = [
    "websocket"
], go = 6048e5, mo = 3e3, yo = {
    METAMASK_GETPROVIDERSTATE: "metamask_getProviderState",
    METAMASK_CONNECTSIGN: "metamask_connectSign",
    METAMASK_CONNECTWITH: "metamask_connectWith",
    METAMASK_OPEN: "metamask_open",
    METAMASK_BATCH: "metamask_batch",
    PERSONAL_SIGN: "personal_sign",
    WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions",
    WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions",
    WALLET_GETPERMISSIONS: "wallet_getPermissions",
    WALLET_WATCHASSET: "wallet_watchAsset",
    WALLET_SWITCHETHEREUMCHAIN: "wallet_switchEthereumChain",
    WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain",
    ETH_REQUESTACCOUNTS: "eth_requestAccounts",
    ETH_ACCOUNTS: "eth_accounts",
    ETH_CHAINID: "eth_chainId",
    ETH_SENDTRANSACTION: "eth_sendTransaction",
    ETH_SIGNTYPEDDATA: "eth_signTypedData",
    ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3",
    ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4",
    ETH_SIGNTRANSACTION: "eth_signTransaction",
    ETH_SIGN: "eth_sign",
    PERSONAL_EC_RECOVER: "personal_ecRecover"
}, vo = [
    yo.METAMASK_CONNECTSIGN,
    yo.METAMASK_CONNECTWITH,
    yo.METAMASK_OPEN,
    yo.METAMASK_BATCH,
    yo.PERSONAL_SIGN,
    yo.WALLET_REQUESTPERMISSIONS,
    yo.WALLET_REVOKEPERMISSIONS,
    yo.WALLET_WATCHASSET,
    yo.ETH_SENDTRANSACTION,
    yo.ETH_SIGNTYPEDDATA,
    yo.ETH_SIGNTYPEDDATA_V3,
    yo.ETH_SIGNTYPEDDATA_V4,
    yo.ETH_SIGNTRANSACTION,
    yo.ETH_SIGN,
    yo.PERSONAL_EC_RECOVER
];
function bo(e) {
    return vo.includes(e);
}
function wo(e) {
    const { context: t } = e;
    oo.RemoteCommunication(`[RemoteCommunication: clean()] context=${t}`), e.channelConfig = void 0, e.ready = !1, e.originatorConnectStarted = !1;
}
var Eo, So, _o, Co, ko, Ao, xo;
(xo = Eo || (Eo = {})).DISCONNECTED = "disconnected", xo.WAITING = "waiting", xo.TIMEOUT = "timeout", xo.LINKED = "linked", xo.PAUSED = "paused", xo.TERMINATED = "terminated", function(e) {
    e.KEY_INFO = "key_info", e.SERVICE_STATUS = "service_status", e.PROVIDER_UPDATE = "provider_update", e.RPC_UPDATE = "rpc_update", e.KEYS_EXCHANGED = "keys_exchanged", e.JOIN_CHANNEL = "join_channel", e.PUBLIC_KEY = "public_key", e.CHANNEL_CREATED = "channel_created", e.CLIENTS_CONNECTED = "clients_connected", e.CLIENTS_DISCONNECTED = "clients_disconnected", e.CLIENTS_WAITING = "clients_waiting", e.CLIENTS_READY = "clients_ready", e.REJECTED = "rejected", e.WALLET_INIT = "wallet_init", e.CHANNEL_PERSISTENCE = "channel_persistence", e.CONFIG = "config", e.MESSAGE_ACK = "ack", e.SOCKET_DISCONNECTED = "socket_disconnected", e.SOCKET_RECONNECT = "socket_reconnect", e.OTP = "otp", e.SDK_RPC_CALL = "sdk_rpc_call", e.AUTHORIZED = "authorized", e.CONNECTION_STATUS = "connection_status", e.MESSAGE = "message", e.TERMINATE = "terminate";
}(So || (So = {})), (_o || (_o = {})).KEY_EXCHANGE = "key_exchange", function(e) {
    e.KEY_HANDSHAKE_START = "key_handshake_start", e.KEY_HANDSHAKE_CHECK = "key_handshake_check", e.KEY_HANDSHAKE_SYN = "key_handshake_SYN", e.KEY_HANDSHAKE_SYNACK = "key_handshake_SYNACK", e.KEY_HANDSHAKE_ACK = "key_handshake_ACK", e.KEY_HANDSHAKE_WALLET = "key_handshake_wallet", e.KEY_HANDSHAKE_NONE = "none";
}(Co || (Co = {}));
class Mo extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter2$2f$lib$2f$eventemitter2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventEmitter2"] {
    constructor({ communicationLayer: e, otherPublicKey: t, context: n, ecies: r, logging: i }){
        super(), this.keysExchanged = !1, this.step = Co.KEY_HANDSHAKE_NONE, this.debug = !1, this.context = n, this.communicationLayer = e, (null == r ? void 0 : r.privateKey) && t && (oo.KeyExchange(`[KeyExchange: constructor()] otherPubKey=${t} set keysExchanged to true!`, r), this.keysExchanged = !0), this.myECIES = new uo(Object.assign(Object.assign({}, r), {
            debug: null == i ? void 0 : i.eciesLayer
        })), this.communicationLayer.state.eciesInstance = this.myECIES, this.myPublicKey = this.myECIES.getPublicKey(), this.debug = !0 === (null == i ? void 0 : i.keyExchangeLayer), t && this.setOtherPublicKey(t), this.communicationLayer.on(_o.KEY_EXCHANGE, this.onKeyExchangeMessage.bind(this));
    }
    onKeyExchangeMessage(e) {
        const { relayPersistence: t } = this.communicationLayer.remote.state;
        if (oo.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${t}`, e), t) return void oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated");
        const { message: n } = e;
        this.keysExchanged && oo.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`), this.emit(So.KEY_INFO, n.type), n.type === Co.KEY_HANDSHAKE_SYN ? (this.checkStep([
            Co.KEY_HANDSHAKE_NONE,
            Co.KEY_HANDSHAKE_ACK
        ]), oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN", n), n.pubkey && this.setOtherPublicKey(n.pubkey), this.communicationLayer.sendMessage({
            type: Co.KEY_HANDSHAKE_SYNACK,
            pubkey: this.myPublicKey
        }).catch((e)=>{
            oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK", e);
        }), this.setStep(Co.KEY_HANDSHAKE_ACK)) : n.type === Co.KEY_HANDSHAKE_SYNACK ? (this.checkStep([
            Co.KEY_HANDSHAKE_SYNACK,
            Co.KEY_HANDSHAKE_ACK,
            Co.KEY_HANDSHAKE_NONE
        ]), oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"), n.pubkey && this.setOtherPublicKey(n.pubkey), this.communicationLayer.sendMessage({
            type: Co.KEY_HANDSHAKE_ACK
        }).catch((e)=>{
            oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK", e);
        }), this.keysExchanged = !0, this.setStep(Co.KEY_HANDSHAKE_ACK), this.emit(So.KEYS_EXCHANGED)) : n.type === Co.KEY_HANDSHAKE_ACK && (oo.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"), this.checkStep([
            Co.KEY_HANDSHAKE_ACK,
            Co.KEY_HANDSHAKE_NONE
        ]), this.keysExchanged = !0, this.setStep(Co.KEY_HANDSHAKE_ACK), this.emit(So.KEYS_EXCHANGED));
    }
    resetKeys(e) {
        this.clean(), this.myECIES = new uo(e);
    }
    clean() {
        oo.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`), this.setStep(Co.KEY_HANDSHAKE_NONE), this.emit(So.KEY_INFO, this.step), this.keysExchanged = !1;
    }
    start({ isOriginator: e, force: t }) {
        const { relayPersistence: n, protocolVersion: r } = this.communicationLayer.remote.state, i = r >= 2;
        n ? oo.KeyExchange("[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated") : (oo.KeyExchange(`[KeyExchange: start()] context=${this.context} protocolVersion=${r} isOriginator=${e} step=${this.step} force=${t} relayPersistence=${n} keysExchanged=${this.keysExchanged}`), e ? !(this.keysExchanged || this.step !== Co.KEY_HANDSHAKE_NONE && this.step !== Co.KEY_HANDSHAKE_SYNACK) || t ? (oo.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${t}) -- step=${this.step}`, this.step), this.clean(), this.setStep(Co.KEY_HANDSHAKE_SYNACK), this.communicationLayer.sendMessage({
            type: Co.KEY_HANDSHAKE_SYN,
            pubkey: this.myPublicKey,
            v: 2
        }).catch((e)=>{
            oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN", e);
        })) : oo.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged ? "done" : "in progress"} -- aborted.`, this.step) : this.keysExchanged && !0 !== t ? oo.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done.") : i ? this.communicationLayer.sendMessage({
            type: Co.KEY_HANDSHAKE_SYNACK,
            pubkey: this.myPublicKey,
            v: 2
        }).catch((e)=>{
            oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK", e);
        }) : (this.communicationLayer.sendMessage({
            type: Co.KEY_HANDSHAKE_START
        }).catch((e)=>{
            oo.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_START", e);
        }), this.clean()));
    }
    setStep(e) {
        this.step = e, this.emit(So.KEY_INFO, e);
    }
    checkStep(e) {
        e.length > 0 && e.indexOf(this.step.toString());
    }
    setRelayPersistence({ localKey: e, otherKey: t }) {
        this.otherPublicKey = t, this.myECIES = new uo({
            privateKey: e,
            debug: this.debug
        }), this.keysExchanged = !0;
    }
    setKeysExchanged(e) {
        this.keysExchanged = e;
    }
    areKeysExchanged() {
        return this.keysExchanged;
    }
    getMyPublicKey() {
        return this.myPublicKey;
    }
    getOtherPublicKey() {
        return this.otherPublicKey;
    }
    setOtherPublicKey(e) {
        oo.KeyExchange("[KeyExchange: setOtherPubKey()]", e), this.otherPublicKey = e;
    }
    encryptMessage(e) {
        if (!this.otherPublicKey) throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");
        return this.myECIES.encrypt(e, this.otherPublicKey);
    }
    decryptMessage(e) {
        if (!this.otherPublicKey) throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");
        return this.myECIES.decrypt(e);
    }
    getKeyInfo() {
        return {
            ecies: Object.assign(Object.assign({}, this.myECIES.getKeyInfo()), {
                otherPubKey: this.otherPublicKey
            }),
            step: this.step,
            keysExchanged: this.areKeysExchanged()
        };
    }
    toString() {
        const e = {
            keyInfo: this.getKeyInfo(),
            keysExchanged: this.keysExchanged,
            step: this.step
        };
        return JSON.stringify(e);
    }
}
!function(e) {
    e.TERMINATE = "terminate", e.ANSWER = "answer", e.OFFER = "offer", e.CANDIDATE = "candidate", e.JSONRPC = "jsonrpc", e.WALLET_INFO = "wallet_info", e.WALLET_INIT = "wallet_init", e.ORIGINATOR_INFO = "originator_info", e.PAUSE = "pause", e.OTP = "otp", e.AUTHORIZED = "authorized", e.PING = "ping", e.READY = "ready";
}(ko || (ko = {})), function(e) {
    e.REQUEST = "sdk_connect_request_started", e.REQUEST_MOBILE = "sdk_connect_request_started_mobile", e.RECONNECT = "sdk_reconnect_request_started", e.CONNECTED = "sdk_connection_established", e.CONNECTED_MOBILE = "sdk_connection_established_mobile", e.AUTHORIZED = "sdk_connection_authorized", e.REJECTED = "sdk_connection_rejected", e.TERMINATED = "sdk_connection_terminated", e.DISCONNECTED = "sdk_disconnected", e.SDK_USE_EXTENSION = "sdk_use_extension", e.SDK_RPC_REQUEST = "sdk_rpc_request", e.SDK_RPC_REQUEST_RECEIVED = "sdk_rpc_request_received", e.SDK_RPC_REQUEST_DONE = "sdk_rpc_request_done", e.SDK_EXTENSION_UTILIZED = "sdk_extension_utilized", e.SDK_USE_INAPP_BROWSER = "sdk_use_inapp_browser";
}(Ao || (Ao = {}));
const Io = (e, t, n)=>c(void 0, void 0, void 0, function*() {
        var r, i, o, s, a, c;
        const { remote: l, state: d } = e, { channelId: u, isOriginator: h } = d;
        if ("error_terminated" === t) return oo.SocketService(`handleJoinChannelResults: Channel ${u} terminated`), void e.emit(So.TERMINATE);
        if (!n) return void oo.SocketService(`handleJoinChannelResults: No result for channel ${u}`);
        const { persistence: f, walletKey: p, rejected: g } = n;
        if (oo.SocketService(`handleJoinChannelResults: Channel ${u} persistence=${f} walletKey=${p} rejected=${g}`), g) return oo.SocketService(`handleJoinChannelResults: Channel ${u} rejected`), yield e.remote.disconnect({
            terminate: !0
        }), e.remote.emit(So.REJECTED, {
            channelId: u
        }), void e.remote.emitServiceStatusEvent();
        if (p && !(null === (r = l.state.channelConfig) || void 0 === r ? void 0 : r.otherKey)) {
            e.getKeyExchange().setOtherPublicKey(p), null === (i = e.state.keyExchange) || void 0 === i || i.setKeysExchanged(!0), l.state.ready = !0, l.state.authorized = !0, l.emit(So.AUTHORIZED);
            const { communicationLayer: t, storageManager: n } = l.state, r = Object.assign(Object.assign({}, l.state.channelConfig), {
                channelId: null !== (o = l.state.channelId) && void 0 !== o ? o : "",
                validUntil: Date.now() + go,
                localKey: null == t ? void 0 : t.getKeyInfo().ecies.private,
                otherKey: p
            });
            e.sendMessage({
                type: Co.KEY_HANDSHAKE_ACK
            }).catch((e)=>{}), null === (s = e.state.socket) || void 0 === s || s.emit(ko.PING, {
                id: u,
                clientType: h ? "dapp" : "wallet",
                context: "on_channel_reconnect",
                message: ""
            }), yield null == n ? void 0 : n.persistChannelConfig(r), l.emitServiceStatusEvent(), l.setConnectionStatus(Eo.LINKED);
        }
        f && (e.emit(So.CHANNEL_PERSISTENCE), null === (a = e.state.keyExchange) || void 0 === a || a.setKeysExchanged(!0), l.state.ready = !0, l.state.authorized = !0, l.emit(So.AUTHORIZED), lo(Object.assign(Object.assign({
            id: null != u ? u : "",
            event: h ? Ao.CONNECTED : Ao.CONNECTED_MOBILE
        }, e.remote.state.originatorInfo), {
            sdkVersion: e.remote.state.sdkVersion,
            commLayer: e.state.communicationLayerPreference,
            commLayerVersion: ho.version,
            walletVersion: null === (c = e.remote.state.walletInfo) || void 0 === c ? void 0 : c.version
        }), d.communicationServerUrl).catch((e)=>{}));
    }), To = (e)=>new Promise((t)=>{
        setTimeout(t, e);
    }), Ro = (e, t, ...n)=>c(void 0, [
        e,
        t,
        ...n
    ], void 0, function*(e, t, n = 200) {
        let r;
        const i = Date.now();
        let o = !1;
        for(; !o;){
            if (o = Date.now() - i > 3e5, r = t[e], void 0 !== r.elapsedTime) return r;
            yield To(n);
        }
        throw new Error(`RPC ${e} timed out`);
    }), Po = (e)=>c(void 0, void 0, void 0, function*() {
        const { state: t } = e, { socket: n, channelId: r, context: i, isOriginator: o, isReconnecting: s } = t;
        if (s) return oo.SocketService("[SocketService: reconnectSocket()] Reconnection already in progress, skipping", e), !1;
        if (!n) return oo.SocketService("[SocketService: reconnectSocket()] socket is not defined", e), !1;
        if (!r) return !1;
        const { connected: a } = n;
        t.isReconnecting = !0, t.reconnectionAttempts = 0, oo.SocketService(`[SocketService: reconnectSocket()] connected=${a} trying to reconnect after socketio disconnection`, e);
        try {
            for(; 3 > t.reconnectionAttempts;){
                if (oo.SocketService(`[SocketService: reconnectSocket()] Attempt ${t.reconnectionAttempts + 1} of 3`, e), yield To(200), n.connected) return oo.SocketService("Socket already connected --- ping to retrieve messages"), n.emit(ko.PING, {
                    id: r,
                    clientType: o ? "dapp" : "wallet",
                    context: "on_channel_config",
                    message: ""
                }), !0;
                t.resumed = !0, n.connect(), e.emit(So.SOCKET_RECONNECT);
                try {
                    if (yield new Promise((t, s)=>{
                        n.emit(So.JOIN_CHANNEL, {
                            channelId: r,
                            context: `${i}connect_again`,
                            clientType: o ? "dapp" : "wallet"
                        }, (n, r)=>c(void 0, void 0, void 0, function*() {
                                try {
                                    yield Io(e, n, r), t();
                                } catch (e) {
                                    s(e);
                                }
                            }));
                    }), yield To(100), n.connected) return oo.SocketService(`Reconnection successful on attempt ${t.reconnectionAttempts + 1}`), !0;
                } catch (e) {
                    oo.SocketService(`Error during reconnection attempt ${t.reconnectionAttempts + 1}:`, e);
                }
                t.reconnectionAttempts += 1, 3 > t.reconnectionAttempts && (yield To(200));
            }
            return oo.SocketService("Failed to reconnect after 3 attempts"), !1;
        } finally{
            t.isReconnecting = !1, t.reconnectionAttempts = 0;
        }
    });
function Oo(e, t) {
    return c(this, void 0, void 0, function*() {
        var n;
        const r = null === (n = e.state.keyExchange) || void 0 === n ? void 0 : n.encryptMessage(JSON.stringify(t)), i = {
            id: e.state.channelId,
            context: e.state.context,
            clientType: e.state.isOriginator ? "dapp" : "wallet",
            message: r,
            plaintext: e.state.hasPlaintext ? JSON.stringify(t) : void 0
        };
        return oo.SocketService(`[SocketService: encryptAndSendMessage()] context=${e.state.context}`, i), t.type === ko.TERMINATE && (e.state.manualDisconnect = !0), new Promise((t, n)=>{
            var r;
            null === (r = e.state.socket) || void 0 === r || r.emit(So.MESSAGE, i, (e, r)=>{
                var i;
                e && (oo.SocketService(`[SocketService: encryptAndSendMessage()] error=${e}`), n(e)), oo.SocketService("[encryptAndSendMessage] response", r), t(null !== (i = null == r ? void 0 : r.success) && void 0 !== i && i);
            });
        });
    });
}
var No;
!function(e) {
    e.RPC_CHECK = "rpcCheck", e.SKIPPED_RPC = "skippedRpc";
}(No || (No = {}));
const Lo = [
    "eth_sendTransaction",
    "eth_signTypedData",
    "eth_signTransaction",
    "personal_sign",
    "wallet_requestPermissions",
    "wallet_switchEthereumChain",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "metamask_connectSign",
    "metamask_connectWith",
    "metamask_batch"
].map((e)=>e.toLowerCase());
const Do = [
    {
        event: So.CLIENTS_CONNECTED,
        handler: function(e, t) {
            return (n)=>c(this, void 0, void 0, function*() {
                    var n, r, i, o, s, a, c, l, d, u, h;
                    const f = null !== (r = null === (n = e.remote.state.channelConfig) || void 0 === n ? void 0 : n.relayPersistence) && void 0 !== r && r;
                    if (oo.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} on 'clients_connected-${t}' relayPersistence=${f} resumed=${e.state.resumed}  clientsPaused=${e.state.clientsPaused} keysExchanged=${null === (i = e.state.keyExchange) || void 0 === i ? void 0 : i.areKeysExchanged()} isOriginator=${e.state.isOriginator}`), e.emit(So.CLIENTS_CONNECTED, {
                        isOriginator: e.state.isOriginator,
                        keysExchanged: null === (o = e.state.keyExchange) || void 0 === o ? void 0 : o.areKeysExchanged(),
                        context: e.state.context
                    }), e.state.resumed) e.state.isOriginator || (oo.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} 'clients_connected' / keysExchanged=${null === (s = e.state.keyExchange) || void 0 === s ? void 0 : s.areKeysExchanged()} -- backward compatibility`), null === (a = e.state.keyExchange) || void 0 === a || a.start({
                        isOriginator: null !== (c = e.state.isOriginator) && void 0 !== c && c
                    })), e.state.resumed = !1;
                    else if (e.state.clientsPaused) oo.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause");
                    else if (!e.state.isOriginator) {
                        const t = !f;
                        oo.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} on 'clients_connected' / keysExchanged=${null === (l = e.state.keyExchange) || void 0 === l ? void 0 : l.areKeysExchanged()} -- force=${t} -- backward compatibility`), oo.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} on 'clients_connected' / keysExchanged=${null === (d = e.state.keyExchange) || void 0 === d ? void 0 : d.areKeysExchanged()} -- force=${t} -- backward compatibility`), null === (u = e.state.keyExchange) || void 0 === u || u.start({
                            isOriginator: null !== (h = e.state.isOriginator) && void 0 !== h && h,
                            force: t
                        });
                    }
                    e.state.clientsConnected = !0, e.state.clientsPaused = !1;
                });
        }
    },
    {
        event: So.CHANNEL_CREATED,
        handler: function(e, t) {
            return (n)=>{
                oo.SocketService(`[SocketService: handleChannelCreated()] context=${e.state.context} on 'channel_created-${t}'`, n), e.emit(So.CHANNEL_CREATED, n);
            };
        }
    },
    {
        event: So.CLIENTS_DISCONNECTED,
        handler: function(e, t) {
            return ()=>{
                var n;
                e.state.clientsConnected = !1, oo.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e.state.context} on 'clients_disconnected-${t}'`), e.remote.state.relayPersistence ? oo.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e.state.context} on 'clients_disconnected-${t}' - relayPersistence enabled, skipping key exchange cleanup.`) : (e.state.isOriginator && !e.state.clientsPaused && (null === (n = e.state.keyExchange) || void 0 === n || n.clean()), e.emit(So.CLIENTS_DISCONNECTED, t));
            };
        }
    },
    {
        event: So.CONFIG,
        handler: function(e, t) {
            return (n)=>c(this, void 0, void 0, function*() {
                    var r, i, o;
                    oo.SocketService(`[SocketService: handleChannelConfig()] update relayPersistence on 'config-${t}'`, n);
                    const { persistence: s, walletKey: a } = n;
                    e.state.isOriginator && e.remote.state.channelConfig ? (n.walletKey && !e.remote.state.channelConfig.otherKey && (oo.SocketService(`Setting wallet key ${a}`), e.remote.state.channelConfig.otherKey = a, e.getKeyExchange().setOtherPublicKey(n.walletKey), null === (r = e.state.keyExchange) || void 0 === r || r.setKeysExchanged(!0), yield e.remote.sendMessage({
                        type: Co.KEY_HANDSHAKE_ACK
                    }), yield e.remote.sendMessage({
                        type: ko.PING
                    }), yield null === (i = e.remote.state.storageManager) || void 0 === i ? void 0 : i.persistChannelConfig(e.remote.state.channelConfig)), !0 !== s || e.remote.state.channelConfig.relayPersistence || (oo.SocketService(`Setting relay persistence ${s}`), e.remote.state.channelConfig.relayPersistence = s, e.remote.state.relayPersistence = !0, e.remote.emit(So.CHANNEL_PERSISTENCE), e.remote.state.authorized = !0, e.remote.state.ready = !0, e.remote.emit(So.AUTHORIZED), yield null === (o = e.remote.state.storageManager) || void 0 === o ? void 0 : o.persistChannelConfig(e.remote.state.channelConfig))) : e.state.isOriginator || n.persistence && (e.remote.state.relayPersistence = !0, e.remote.emit(So.CHANNEL_PERSISTENCE));
                });
        }
    },
    {
        event: So.MESSAGE,
        handler: function(e, t) {
            return (r)=>{
                var i, o, s, a, c, l, d, u, h, f, p, g, m, y, v, b, w, E;
                const { ackId: S, message: _, error: C } = r, k = null !== (i = e.remote.state.relayPersistence) && void 0 !== i && i;
                if (oo.SocketService(`[SocketService handleMessage()]  relayPersistence=${k}  context=${e.state.context} on 'message' ${t} keysExchanged=${null === (o = e.state.keyExchange) || void 0 === o ? void 0 : o.areKeysExchanged()}`, r), C) throw oo.SocketService(`\n      [SocketService handleMessage()] context=${e.state.context}::on 'message' error=${C}`), new Error(C);
                const A = "string" == typeof _;
                if (!A && (null == _ ? void 0 : _.type) === Co.KEY_HANDSHAKE_START) {
                    if (k) return;
                    return oo.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' received HANDSHAKE_START isOriginator=${e.state.isOriginator}`, _), void (null === (s = e.state.keyExchange) || void 0 === s || s.start({
                        isOriginator: null !== (a = e.state.isOriginator) && void 0 !== a && a,
                        force: !0
                    }));
                }
                if (!A && (null === (c = null == _ ? void 0 : _.type) || void 0 === c ? void 0 : c.startsWith("key_handshake"))) {
                    if (k) return;
                    return oo.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' emit KEY_EXCHANGE`, _), void e.emit(_o.KEY_EXCHANGE, {
                        message: _,
                        context: e.state.context
                    });
                }
                if (A && !(null === (l = e.state.keyExchange) || void 0 === l ? void 0 : l.areKeysExchanged())) {
                    let t = !1;
                    try {
                        oo.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' trying to decrypt message`), null === (d = e.state.keyExchange) || void 0 === d || d.decryptMessage(_), t = !0;
                    } catch (t) {
                        oo.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' error`, t);
                    }
                    if (!t) return e.state.isOriginator ? null === (h = e.state.keyExchange) || void 0 === h || h.start({
                        isOriginator: null !== (f = e.state.isOriginator) && void 0 !== f && f
                    }) : e.sendMessage({
                        type: Co.KEY_HANDSHAKE_START
                    }).catch((e)=>{}), void oo.SocketService(`Message ignored because invalid key exchange status. step=${null === (p = e.state.keyExchange) || void 0 === p ? void 0 : p.getKeyInfo().step}`, null === (g = e.state.keyExchange) || void 0 === g ? void 0 : g.getKeyInfo(), _);
                    oo.SocketService("Invalid key exchange status detected --- updating it."), null === (u = e.state.keyExchange) || void 0 === u || u.setKeysExchanged(!0);
                } else if (!A && (null == _ ? void 0 : _.type)) return void e.emit(So.MESSAGE, _);
                if (!A) return void e.emit(So.MESSAGE, _);
                const x = null === (m = e.state.keyExchange) || void 0 === m ? void 0 : m.decryptMessage(_), M = JSON.parse(null != x ? x : "{}");
                if (S && (null == S ? void 0 : S.length) > 0 && (oo.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' ackid=${S} channelId=${t}`), null === (y = e.state.socket) || void 0 === y || y.emit(So.MESSAGE_ACK, {
                    ackId: S,
                    channelId: t,
                    clientType: e.state.isOriginator ? "dapp" : "wallet"
                })), e.state.clientsPaused = (null == M ? void 0 : M.type) === ko.PAUSE, e.state.isOriginator && M.data) {
                    const t = M.data, r = e.state.rpcMethodTracker[t.id];
                    if (r) {
                        const i = Date.now() - r.timestamp;
                        oo.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' received answer for id=${t.id} method=${r.method} responseTime=${i}`, M), e.remote.state.analytics && Lo.includes(r.method.toLowerCase()) && lo(Object.assign(Object.assign({
                            id: null !== (v = e.remote.state.channelId) && void 0 !== v ? v : "",
                            event: Ao.SDK_RPC_REQUEST_DONE,
                            sdkVersion: e.remote.state.sdkVersion,
                            commLayerVersion: ho.version
                        }, e.remote.state.originatorInfo), {
                            walletVersion: null === (b = e.remote.state.walletInfo) || void 0 === b ? void 0 : b.version,
                            params: {
                                method: r.method,
                                from: "mobile"
                            }
                        }), e.remote.state.communicationServerUrl).catch((e)=>{}), bo(r.method) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track(t.error ? 4001 === t.error.code ? "sdk_action_rejected" : "sdk_action_failed" : "sdk_action_succeeded", {
                            action: r.method
                        });
                        const o = Object.assign(Object.assign({}, r), {
                            result: t.result,
                            error: t.error ? {
                                code: null === (w = t.error) || void 0 === w ? void 0 : w.code,
                                message: null === (E = t.error) || void 0 === E ? void 0 : E.message
                            } : void 0,
                            elapsedTime: i
                        });
                        e.state.rpcMethodTracker[t.id] = o, e.emit(So.RPC_UPDATE, o);
                    }
                }
                e.emit(So.MESSAGE, {
                    message: M
                });
            };
        }
    },
    {
        event: So.REJECTED,
        handler: function(e, t) {
            return (r)=>c(this, void 0, void 0, function*() {
                    var r;
                    e.state.isOriginator && !e.remote.state.ready ? (oo.SocketService(`[SocketService: handleChannelRejected()] context=${e.state.context} channelId=${t} isOriginator=${e.state.isOriginator} ready=${e.remote.state.ready}`, e.remote.state.originatorInfo), lo(Object.assign(Object.assign({
                        id: t,
                        event: Ao.REJECTED
                    }, e.remote.state.originatorInfo), {
                        sdkVersion: e.remote.state.sdkVersion,
                        commLayer: e.state.communicationLayerPreference,
                        commLayerVersion: ho.version,
                        walletVersion: null === (r = e.remote.state.walletInfo) || void 0 === r ? void 0 : r.version
                    }), e.remote.state.communicationServerUrl).catch((e)=>{}), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_connection_rejected", {
                        transport_type: "websocket"
                    }), yield e.remote.disconnect({
                        terminate: !0
                    }), e.remote.emit(So.REJECTED, {
                        channelId: t
                    }), e.remote.setConnectionStatus(Eo.DISCONNECTED)) : oo.SocketService(`[SocketService: handleChannelRejected()] SKIP -- channelId=${t} isOriginator=${e.state.isOriginator} ready=${e.remote.state.ready}`);
                });
        }
    },
    {
        event: "clients_waiting_to_join",
        handler: function(e, t) {
            return (n)=>{
                oo.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${e.state.context} on 'clients_waiting_to_join-${t}'`, n), e.emit(So.CLIENTS_WAITING, n);
            };
        }
    }
], $o = [
    {
        event: So.KEY_INFO,
        handler: function(e) {
            return (t)=>{
                oo.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'", t), e.emit(So.KEY_INFO, t);
            };
        }
    },
    {
        event: So.KEYS_EXCHANGED,
        handler: function(e) {
            return ()=>{
                var t, n, r;
                oo.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${null === (t = e.state.keyExchange) || void 0 === t ? void 0 : t.areKeysExchanged()}`);
                const { channelConfig: i } = e.remote.state;
                if (i) {
                    const t = e.getKeyExchange().getKeyInfo().ecies;
                    i.localKey = t.private, i.otherKey = t.otherPubKey, e.remote.state.channelConfig = i, null === (n = e.remote.state.storageManager) || void 0 === n || n.persistChannelConfig(i).catch((e)=>{});
                }
                e.emit(So.KEYS_EXCHANGED, {
                    keysExchanged: null === (r = e.state.keyExchange) || void 0 === r ? void 0 : r.areKeysExchanged(),
                    isOriginator: e.state.isOriginator
                });
                const o = {
                    keyInfo: e.getKeyInfo()
                };
                e.emit(So.SERVICE_STATUS, o);
            };
        }
    }
];
function Bo(e, t) {
    oo.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} setting socket listeners for channel ${t}...`);
    const { socket: n } = e.state, { keyExchange: r } = e.state;
    n && e.state.isOriginator && (e.state.debug && (null == n || n.io.on("error", (t)=>{
        oo.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=error`, t);
    }), null == n || n.io.on("reconnect", (t)=>{
        oo.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect`, t), Po(e).catch((e)=>{});
    }), null == n || n.io.on("reconnect_error", (t)=>{
        oo.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect_error`, t);
    }), null == n || n.io.on("reconnect_failed", ()=>{
        oo.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect_failed`);
    })), null == n || n.on("disconnect", (t)=>(oo.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${t}' begin recovery...`), (function(e) {
            return (t)=>{
                oo.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${e.state.manualDisconnect}`, t), e.state.manualDisconnect || (e.emit(So.SOCKET_DISCONNECTED), Po(e).catch((e)=>{}));
            };
        })(e)(t)))), Do.forEach(({ event: r, handler: i })=>{
        null == n || n.on(`${r}-${t}`, i(e, t));
    }), $o.forEach(({ event: t, handler: n })=>{
        null == r || r.on(t, n(e));
    }), e.state.setupChannelListeners = !0;
}
class Ko extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter2$2f$lib$2f$eventemitter2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventEmitter2"] {
    constructor(e){
        super(), this.state = {
            clientsConnected: !1,
            clientsPaused: !1,
            manualDisconnect: !1,
            lastRpcId: void 0,
            rpcMethodTracker: {},
            hasPlaintext: !1,
            communicationServerUrl: "",
            focusListenerAdded: !1,
            removeFocusListener: void 0,
            isReconnecting: !1,
            reconnectionAttempts: 0
        }, this.options = e;
        const { reconnect: n, communicationLayerPreference: r, communicationServerUrl: i, context: o, remote: s, logging: a } = e;
        this.state.resumed = n, this.state.context = o, this.state.isOriginator = s.state.isOriginator, this.state.communicationLayerPreference = r, this.state.debug = !0 === (null == a ? void 0 : a.serviceLayer), this.remote = s, !0 === (null == a ? void 0 : a.serviceLayer) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].enable("SocketService:Layer"), this.state.communicationServerUrl = i, this.state.hasPlaintext = this.state.communicationServerUrl !== fo && !0 === (null == a ? void 0 : a.plaintext), oo.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`), this.initSocket();
    }
    initSocket() {
        var e;
        const { otherPublicKey: t, ecies: n, logging: r } = this.options, i = {
            autoConnect: !1,
            transports: po,
            withCredentials: !0
        }, o = this.state.communicationServerUrl;
        oo.SocketService(`[SocketService: initSocket()] Socket IO url: ${o}`), this.state.socket = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["io"])(o, i), function(e) {
            if ("undefined" != ("TURBOPACK compile-time value", "undefined") && "undefined" != typeof document && (oo.SocketService(`[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`, e), !e.state.focusListenerAdded)) //TURBOPACK unreachable
            ;
        }(this);
        const s = {
            communicationLayer: this,
            otherPublicKey: t,
            sendPublicKey: !1,
            context: null !== (e = this.state.context) && void 0 !== e ? e : "",
            ecies: n,
            logging: r
        };
        this.state.keyExchange = new Mo(s);
    }
    resetKeys() {
        return oo.SocketService("[SocketService: resetKeys()] Resetting keys."), void (null === (e = this.state.keyExchange) || void 0 === e || e.resetKeys());
        //TURBOPACK unreachable
        ;
        var e;
    }
    createChannel() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                return c(this, void 0, void 0, function*() {
                    var t, n, r;
                    if (oo.SocketService(`[SocketService: createChannel()] context=${e.state.context}`), e.state.socket || e.initSocket(), null === (t = e.state.socket) || void 0 === t ? void 0 : t.connected) throw new Error("socket already connected");
                    null === (n = e.state.socket) || void 0 === n || n.connect(), e.state.manualDisconnect = !1, e.state.isOriginator = !0;
                    const i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
                    e.state.channelId = i, Bo(e, i), yield new Promise((t, n)=>{
                        var r;
                        null === (r = e.state.socket) || void 0 === r || r.emit(So.JOIN_CHANNEL, {
                            channelId: i,
                            context: `${e.state.context}createChannel`,
                            clientType: "dapp"
                        }, (r, i)=>c(this, void 0, void 0, function*() {
                                try {
                                    yield Io(e, r, i), t();
                                } catch (e) {
                                    n(e);
                                }
                            }));
                    });
                    const o = null === (r = e.state.keyExchange) || void 0 === r ? void 0 : r.getKeyInfo();
                    return {
                        channelId: i,
                        pubKey: (null == o ? void 0 : o.ecies.public) || "",
                        privKey: (null == o ? void 0 : o.ecies.private) || ""
                    };
                });
            }(this);
        });
    }
    connectToChannel({ channelId: e, withKeyExchange: t = !1, authorized: n }) {
        return function(e) {
            return c(this, arguments, void 0, function*({ options: e, instance: t }) {
                const { channelId: n, authorized: r, withKeyExchange: i } = e, { state: o, remote: s } = t, { isOriginator: a = !1, socket: l, keyExchange: d } = o, { channelConfig: u } = s.state;
                if (null == l ? void 0 : l.connected) throw new Error("socket already connected");
                if (a && (null == u ? void 0 : u.relayPersistence)) {
                    const { localKey: e, otherKey: t } = u;
                    e && t && (null == d || d.setRelayPersistence({
                        localKey: e,
                        otherKey: t
                    }));
                }
                return Object.assign(o, {
                    manualDisconnect: !1,
                    withKeyExchange: i,
                    isOriginator: a,
                    channelId: n
                }), null == l || l.connect(), Bo(t, n), !a && r && (null == d || d.setKeysExchanged(!0), Object.assign(s.state, {
                    ready: !0,
                    authorized: !0
                })), new Promise((e)=>{
                    var i;
                    const s = null === (i = null == d ? void 0 : d.getKeyInfo()) || void 0 === i ? void 0 : i.ecies.public;
                    null == l || l.emit(So.JOIN_CHANNEL, {
                        channelId: n,
                        context: `${o.context}_connectToChannel`,
                        clientType: a ? "dapp" : "wallet",
                        publicKey: r && !a ? s : void 0
                    }, (n, r)=>c(this, void 0, void 0, function*() {
                            yield Io(t, n, r), e();
                        }));
                });
            });
        }({
            options: {
                channelId: e,
                withKeyExchange: t,
                authorized: n
            },
            instance: this
        });
    }
    getKeyInfo() {
        return this.state.keyExchange.getKeyInfo();
    }
    keyCheck() {
        var e, t;
        null === (t = (e = this).state.socket) || void 0 === t || t.emit(So.MESSAGE, {
            id: e.state.channelId,
            context: e.state.context,
            message: {
                type: Co.KEY_HANDSHAKE_CHECK,
                pubkey: e.getKeyInfo().ecies.otherPubKey
            }
        });
    }
    getKeyExchange() {
        return this.state.keyExchange;
    }
    sendMessage(e) {
        return c(this, void 0, void 0, function*() {
            return function(e, t) {
                return c(this, void 0, void 0, function*() {
                    var r, i, o;
                    if (!e.state.channelId) throw oo.SocketService("handleSendMessage: no channelId - Create a channel first"), new Error("Create a channel first");
                    if (oo.SocketService(`[SocketService: handleSendMessage()] context=${e.state.context} areKeysExchanged=${null === (r = e.state.keyExchange) || void 0 === r ? void 0 : r.areKeysExchanged()}`, t), null === (i = null == t ? void 0 : t.type) || void 0 === i ? void 0 : i.startsWith("key_handshake")) return function(e, t) {
                        var n;
                        oo.SocketService(`[SocketService: handleKeyHandshake()] context=${e.state.context}`, t), null === (n = e.state.socket) || void 0 === n || n.emit(So.MESSAGE, {
                            id: e.state.channelId,
                            context: e.state.context,
                            clientType: e.state.isOriginator ? "dapp" : "wallet",
                            message: t
                        });
                    }(e, t), !0;
                    !function(e, t) {
                        var n;
                        if (!(null === (n = e.state.keyExchange) || void 0 === n ? void 0 : n.areKeysExchanged()) && !e.remote.state.relayPersistence) throw oo.SocketService(`[SocketService: validateKeyExchange()] context=${e.state.context} ERROR keys not exchanged`, t), new Error("Keys not exchanged BBB");
                    }(e, t), function(e, t) {
                        var n;
                        const r = null !== (n = null == t ? void 0 : t.method) && void 0 !== n ? n : "", i = null == t ? void 0 : t.id;
                        e.state.isOriginator && i && (e.state.rpcMethodTracker[i] = {
                            id: i,
                            timestamp: Date.now(),
                            method: r
                        }, e.emit(So.RPC_UPDATE, e.state.rpcMethodTracker[i]));
                    }(e, t);
                    const s = yield Oo(e, t);
                    return e.remote.state.analytics && e.remote.state.isOriginator && t.method && Lo.includes(t.method.toLowerCase()) && lo({
                        id: null !== (o = e.remote.state.channelId) && void 0 !== o ? o : "",
                        event: Ao.SDK_RPC_REQUEST,
                        params: {
                            method: t.method,
                            from: "mobile"
                        }
                    }, e.remote.state.communicationServerUrl).catch((e)=>{}), e.remote.state.isOriginator && t.method && bo(t.method) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_action_requested", {
                        action: t.method
                    }), (function(e, t) {
                        return c(this, void 0, void 0, function*() {
                            var n;
                            const r = null == t ? void 0 : t.id, i = null !== (n = null == t ? void 0 : t.method) && void 0 !== n ? n : "";
                            if (e.state.isOriginator && r) try {
                                const n = Ro(r, e.state.rpcMethodTracker, 200).then((e)=>({
                                        type: No.RPC_CHECK,
                                        result: e
                                    })), o = (()=>c(this, void 0, void 0, function*() {
                                        const t = yield ((e)=>c(void 0, [
                                                e
                                            ], void 0, function*({ rpcId: e, instance: t }) {
                                                for(; t.state.lastRpcId === e || void 0 === t.state.lastRpcId;)yield To(200);
                                                return t.state.lastRpcId;
                                            }))({
                                            instance: e,
                                            rpcId: r
                                        }), n = yield Ro(t, e.state.rpcMethodTracker, 200);
                                        return {
                                            type: No.SKIPPED_RPC,
                                            result: n
                                        };
                                    }))(), s = yield Promise.race([
                                    n,
                                    o
                                ]);
                                if (s.type === No.RPC_CHECK) {
                                    const e = s.result;
                                    oo.SocketService(`[SocketService:handleRpcReplies()] id=${t.id} ${i} ( ${e.elapsedTime} ms)`, e.result);
                                } else {
                                    if (s.type !== No.SKIPPED_RPC) throw new Error(`Error handling RPC replies for ${r}`);
                                    {
                                        const t = Object.assign(Object.assign({}, e.state.rpcMethodTracker[r]), {
                                            error: new Error("SDK_CONNECTION_ISSUE")
                                        });
                                        e.emit(So.RPC_UPDATE, t);
                                        const n = {
                                            data: Object.assign(Object.assign({}, t), {
                                                jsonrpc: "2.0"
                                            }),
                                            name: "metamask-provider"
                                        };
                                        e.emit(So.MESSAGE, {
                                            message: n
                                        });
                                    }
                                }
                            } catch (e) {
                                throw e;
                            }
                        });
                    })(e, t).catch((e)=>{}), s;
                });
            }(this, e);
        });
    }
    ping() {
        return function(e) {
            return c(this, void 0, void 0, function*() {
                var t, n;
                oo.SocketService(`[SocketService: ping()] context=${e.state.context} originator=${e.state.isOriginator} keysExchanged=${null === (t = e.state.keyExchange) || void 0 === t ? void 0 : t.areKeysExchanged()}`), null === (n = e.state.socket) || void 0 === n || n.emit(ko.PING, {
                    id: e.state.channelId,
                    context: "ping",
                    clientType: e.remote.state.isOriginator ? "dapp" : "wallet",
                    message: ""
                });
            });
        }(this);
    }
    pause() {
        return function(e) {
            return c(this, void 0, void 0, function*() {
                var t, n;
                oo.SocketService(`[SocketService: pause()] context=${e.state.context}`), e.state.manualDisconnect = !0, (null === (t = e.state.keyExchange) || void 0 === t ? void 0 : t.areKeysExchanged()) && (yield e.sendMessage({
                    type: ko.PAUSE
                })), null === (n = e.state.socket) || void 0 === n || n.disconnect();
            });
        }(this);
    }
    isConnected() {
        var e;
        return null === (e = this.state.socket) || void 0 === e ? void 0 : e.connected;
    }
    resume() {
        return function(e) {
            return c(this, void 0, void 0, function*() {
                const { state: t, remote: n } = e, { socket: r, channelId: i, context: o, keyExchange: s, isOriginator: a } = t, { isOriginator: l } = n.state;
                if (oo.SocketService(`[SocketService: resume()] channelId=${i} context=${o} connected=${null == r ? void 0 : r.connected} manualDisconnect=${t.manualDisconnect} resumed=${t.resumed} keysExchanged=${null == s ? void 0 : s.areKeysExchanged()}`), !i) throw oo.SocketService("[SocketService: resume()] channelId is not defined"), new Error("ChannelId is not defined");
                (null == r ? void 0 : r.connected) ? (oo.SocketService("[SocketService: resume()] already connected."), r.emit(ko.PING, {
                    id: i,
                    clientType: l ? "dapp" : "wallet",
                    context: "on_channel_config",
                    message: ""
                }), n.hasRelayPersistence() || (null == s ? void 0 : s.areKeysExchanged()) || (a ? yield e.sendMessage({
                    type: ko.READY
                }) : null == s || s.start({
                    isOriginator: !1
                }))) : (null == r || r.connect(), oo.SocketService(`[SocketService: resume()] after connecting socket --\x3e connected=${null == r ? void 0 : r.connected}`), null == r || r.emit(So.JOIN_CHANNEL, {
                    channelId: i,
                    context: `${o}_resume`,
                    clientType: l ? "dapp" : "wallet"
                }, (t, n)=>c(this, void 0, void 0, function*() {
                        try {
                            yield Io(e, t, n);
                        } catch (e) {}
                    }))), t.manualDisconnect = !1, t.resumed = !0;
            });
        }(this);
    }
    getRPCMethodTracker() {
        return this.state.rpcMethodTracker;
    }
    disconnect(e) {
        return function(e, t) {
            var n, r, i, o, s;
            oo.SocketService(`[SocketService: disconnect()] context=${e.state.context}`, t), (null == t ? void 0 : t.terminate) && (null === (r = (n = e.state).removeFocusListener) || void 0 === r || r.call(n), e.state.channelId = t.channelId, null === (i = e.state.socket) || void 0 === i || i.removeAllListeners(), null === (o = e.state.keyExchange) || void 0 === o || o.clean(), e.remote.state.ready = !1, e.state.socket = void 0, e.state.rpcMethodTracker = {}), e.state.manualDisconnect = !0, null === (s = e.state.socket) || void 0 === s || s.disconnect();
        }(this, e);
    }
}
var jo, Uo, Ho;
function Fo(e) {
    return ()=>c(this, void 0, void 0, function*() {
            var t, n, r;
            const { state: i } = e;
            if (i.authorized) return;
            yield (()=>c(this, void 0, void 0, function*() {
                    for(; !i.walletInfo;)yield To(500);
                }))();
            const o = "7.3".localeCompare((null === (t = i.walletInfo) || void 0 === t ? void 0 : t.version) || "");
            if (oo.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${null === (n = i.walletInfo) || void 0 === n ? void 0 : n.version} compareValue=${o}`), 1 !== o) return;
            const s = i.platformType === Uo.MobileWeb || i.platformType === Uo.ReactNative || i.platformType === Uo.MetaMaskMobileWebview;
            oo.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i.platformType} secure=${s} channel=${i.channelId} walletVersion=${null === (r = i.walletInfo) || void 0 === r ? void 0 : r.version}`), s && (i.authorized = !0, e.emit(So.AUTHORIZED));
        });
}
function zo(e) {
    return (t)=>{
        const { state: n } = e;
        oo.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${n.context} on 'channel_created' channelId=${t}`), e.emit(So.CHANNEL_CREATED, t);
    };
}
function qo(e, t) {
    return ()=>{
        var r, i, o, s;
        const { state: a } = e;
        oo.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${a.channelId} keysExchanged=${null === (i = null === (r = a.communicationLayer) || void 0 === r ? void 0 : r.getKeyInfo()) || void 0 === i ? void 0 : i.keysExchanged}`), a.analytics && lo(Object.assign(Object.assign({
            id: null !== (o = a.channelId) && void 0 !== o ? o : "",
            event: a.reconnection ? Ao.RECONNECT : a.isOriginator ? Ao.REQUEST : Ao.REQUEST_MOBILE
        }, a.originatorInfo), {
            commLayer: t,
            sdkVersion: a.sdkVersion,
            walletVersion: null === (s = a.walletInfo) || void 0 === s ? void 0 : s.version,
            commLayerVersion: ho.version
        }), a.communicationServerUrl).catch((e)=>{}), a.isOriginator && !a.reconnection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_connection_established", {
            transport_type: "websocket"
        }), a.clientsConnected = !0, a.originatorInfoSent = !1, e.emit(So.CLIENTS_CONNECTED);
    };
}
function Wo(e) {
    return (t)=>{
        const { state: n } = e;
        oo.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${n.context} on 'clients_disconnected' channelId=${t}`), n.relayPersistence || (n.clientsConnected = !1, n.ready = !1, n.authorized = !1), e.emit(So.CLIENTS_DISCONNECTED, n.channelId), e.setConnectionStatus(Eo.DISCONNECTED);
    };
}
function Vo(e) {
    return (t)=>{
        var n;
        const { state: r } = e;
        if (oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${r.context} on 'clients_waiting' numberUsers=${t} ready=${r.ready} autoStarted=${r.originatorConnectStarted}`), e.setConnectionStatus(Eo.WAITING), e.emit(So.CLIENTS_WAITING, t), r.originatorConnectStarted) {
            oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${r.originatorConnectStarted} timeout`, r.autoConnectOptions);
            const t = (null === (n = r.autoConnectOptions) || void 0 === n ? void 0 : n.timeout) || 3e3, i = setTimeout(()=>{
                oo.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${t}) terminate channelConfig`, r.autoConnectOptions), r.originatorConnectStarted = !1, r.ready || e.setConnectionStatus(Eo.TIMEOUT), clearTimeout(i);
            }, t);
        }
    };
}
function Go(e, t) {
    return (n)=>{
        var r, i, o, s, a, c, l, d;
        const { state: u } = e;
        if (oo.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${u.context} on commLayer.'keys_exchanged' channel=${u.channelId}`, n), null === (i = null === (r = u.communicationLayer) || void 0 === r ? void 0 : r.getKeyInfo()) || void 0 === i ? void 0 : i.keysExchanged) {
            const t = Object.assign(Object.assign({}, u.channelConfig), {
                channelId: null !== (o = u.channelId) && void 0 !== o ? o : "",
                validUntil: (null === (s = u.channelConfig) || void 0 === s ? void 0 : s.validUntil) || go,
                localKey: u.communicationLayer.getKeyInfo().ecies.private,
                otherKey: u.communicationLayer.getKeyInfo().ecies.otherPubKey
            });
            null === (a = u.storageManager) || void 0 === a || a.persistChannelConfig(t).catch((e)=>{}), e.setConnectionStatus(Eo.LINKED);
        }
        !function(e, t) {
            var n, r, i, o, s, a, c, l;
            const { state: d } = e;
            oo.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${d.channelId}`, t);
            const u = Object.assign(Object.assign({}, d.channelConfig), {
                channelId: null !== (n = d.channelId) && void 0 !== n ? n : "",
                validUntil: null !== (i = null === (r = d.channelConfig) || void 0 === r ? void 0 : r.validUntil) && void 0 !== i ? i : 0,
                relayPersistence: d.relayPersistence,
                localKey: null === (s = null === (o = d.communicationLayer) || void 0 === o ? void 0 : o.state.keyExchange) || void 0 === s ? void 0 : s.getKeyInfo().ecies.private,
                otherKey: null === (c = null === (a = d.communicationLayer) || void 0 === a ? void 0 : a.state.keyExchange) || void 0 === c ? void 0 : c.getKeyInfo().ecies.otherPubKey,
                lastActive: t.getTime()
            });
            null === (l = d.storageManager) || void 0 === l || l.persistChannelConfig(u);
        }(e, new Date), u.analytics && u.channelId && lo(Object.assign(Object.assign({
            id: u.channelId,
            event: n.isOriginator ? Ao.CONNECTED : Ao.CONNECTED_MOBILE
        }, u.originatorInfo), {
            sdkVersion: u.sdkVersion,
            commLayer: t,
            commLayerVersion: ho.version,
            walletVersion: null === (c = u.walletInfo) || void 0 === c ? void 0 : c.version
        }), u.communicationServerUrl).catch((e)=>{}), u.isOriginator = n.isOriginator, n.isOriginator || (null === (l = u.communicationLayer) || void 0 === l || l.sendMessage({
            type: ko.READY
        }), u.ready = !0, u.paused = !1), n.isOriginator && !u.originatorInfoSent && (null === (d = u.communicationLayer) || void 0 === d || d.sendMessage({
            type: ko.ORIGINATOR_INFO,
            originatorInfo: u.originatorInfo,
            originator: u.originatorInfo
        }), u.originatorInfoSent = !0);
    };
}
function Yo(e) {
    return (t)=>{
        let n = t;
        t.message && (n = n.message), function(e, t) {
            const { state: n } = t;
            if (oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${n.context} on 'message' typeof=${typeof e}`, e), t.state.ready = !0, n.isOriginator || e.type !== ko.ORIGINATOR_INFO) if (n.isOriginator && e.type === ko.WALLET_INFO) !function(e, t) {
                const { state: n } = e;
                n.walletInfo = t.walletInfo, n.paused = !1;
            }(t, e);
            else {
                if (n.isOriginator && e.type === ko.WALLET_INIT) (function(e, t) {
                    return c(this, void 0, void 0, function*() {
                        var n, r, i;
                        const { state: o } = e;
                        if (o.isOriginator) {
                            const o = t.data || {};
                            if ("object" == typeof o && "accounts" in o && "chainId" in o && "walletKey" in o) try {
                                const { channelConfig: t } = e.state;
                                if (oo.RemoteCommunication("WALLET_INIT: channelConfig", JSON.stringify(t, null, 2)), t) {
                                    const s = o.accounts, a = o.chainId, c = o.walletKey;
                                    let l, d = !1;
                                    "deeplinkProtocol" in o && (d = Boolean(o.deeplinkProtocol), e.state.deeplinkProtocolAvailable = d), "walletVersion" in o && (l = o.walletVersion), yield null === (n = e.state.storageManager) || void 0 === n ? void 0 : n.persistChannelConfig(Object.assign(Object.assign({}, t), {
                                        otherKey: c,
                                        walletVersion: l,
                                        deeplinkProtocolAvailable: d,
                                        relayPersistence: !0
                                    })), yield null === (r = e.state.storageManager) || void 0 === r ? void 0 : r.persistAccounts(s), yield null === (i = e.state.storageManager) || void 0 === i ? void 0 : i.persistChainId(a);
                                }
                                e.emit(So.WALLET_INIT, {
                                    accounts: o.accounts,
                                    chainId: o.chainId
                                });
                            } catch (n) {}
                        }
                    });
                })(t, e).catch((e)=>{
                    oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e}`);
                });
                else if (e.type === ko.TERMINATE) (function(e) {
                    return c(this, void 0, void 0, function*() {
                        const { state: t } = e;
                        t.isOriginator && (yield es({
                            options: {
                                terminate: !0,
                                sendMessage: !1
                            },
                            instance: e
                        }), e.emit(So.TERMINATE));
                    });
                })(t).catch((e)=>{
                    oo.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e}`);
                });
                else if (e.type === ko.PAUSE) !function(e) {
                    const { state: t } = e;
                    t.paused = !0, e.setConnectionStatus(Eo.PAUSED);
                }(t);
                else if (e.type === ko.READY && n.isOriginator) !function(e) {
                    const { state: t } = e;
                    e.setConnectionStatus(Eo.LINKED);
                    const n = t.paused;
                    t.paused = !1, e.emit(So.CLIENTS_READY, {
                        isOriginator: t.isOriginator,
                        walletInfo: t.walletInfo
                    }), n && (t.authorized = !0, e.emit(So.AUTHORIZED));
                }(t);
                else {
                    if (e.type === ko.OTP && n.isOriginator) return void function(e, t) {
                        var n;
                        const { state: r } = e;
                        e.emit(So.OTP, t.otpAnswer), 1 === "6.6".localeCompare((null === (n = r.walletInfo) || void 0 === n ? void 0 : n.version) || "") && e.emit(So.SDK_RPC_CALL, {
                            method: yo.ETH_REQUESTACCOUNTS,
                            params: []
                        });
                    }(t, e);
                    e.type === ko.AUTHORIZED && n.isOriginator && function(e) {
                        const { state: t } = e;
                        t.authorized = !0, e.emit(So.AUTHORIZED);
                    }(t);
                }
                t.emit(So.MESSAGE, e);
            }
            else !function(e, t) {
                var n;
                const { state: r } = e;
                null === (n = r.communicationLayer) || void 0 === n || n.sendMessage({
                    type: ko.WALLET_INFO,
                    walletInfo: r.walletInfo
                }), r.originatorInfo = t.originatorInfo || t.originator, e.emit(So.CLIENTS_READY, {
                    isOriginator: r.isOriginator,
                    originatorInfo: r.originatorInfo
                }), r.paused = !1;
            }(t, e);
        }(n, e);
    };
}
function Zo(e) {
    return ()=>{
        const { state: t } = e;
        oo.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"), t.ready = !1, t.authorized = !1, wo(t), e.emitServiceStatusEvent({
            context: "socket_reconnect"
        });
    };
}
function Jo(e) {
    return ()=>{
        const { state: t } = e;
        oo.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"), t.ready = !1;
    };
}
function Qo(e) {
    return ()=>c(this, void 0, void 0, function*() {
            var t, n, r, i, o, s, a;
            const { state: c } = e;
            oo.RemoteCommunication(`[RemoteCommunication: handleFullPersistenceEvent()] context=${c.context}`), e.state.ready = !0, e.state.clientsConnected = !0, e.state.authorized = !0, e.state.relayPersistence = !0, null === (t = e.state.communicationLayer) || void 0 === t || t.getKeyExchange().setKeysExchanged(!0), e.emit(So.KEYS_EXCHANGED, {
                keysExchanged: !0,
                isOriginator: !0
            }), e.emit(So.AUTHORIZED), e.emit(So.CLIENTS_READY), e.emit(So.CHANNEL_PERSISTENCE);
            try {
                c.channelConfig = Object.assign(Object.assign({}, c.channelConfig), {
                    localKey: null === (n = c.communicationLayer) || void 0 === n ? void 0 : n.getKeyExchange().getKeyInfo().ecies.private,
                    otherKey: null === (r = c.communicationLayer) || void 0 === r ? void 0 : r.getKeyExchange().getOtherPublicKey(),
                    channelId: null !== (i = c.channelId) && void 0 !== i ? i : "",
                    validUntil: null !== (s = null === (o = c.channelConfig) || void 0 === o ? void 0 : o.validUntil) && void 0 !== s ? s : go,
                    relayPersistence: !0
                }), yield null === (a = c.storageManager) || void 0 === a ? void 0 : a.persistChannelConfig(c.channelConfig);
            } catch (t) {}
        });
}
function Xo({ communicationLayerPreference: e, otherPublicKey: t, reconnect: n, ecies: r, communicationServerUrl: i = fo, instance: o }) {
    var s, a, c, l, d, u, h, f, p, g, m;
    const { state: y } = o;
    if (oo.RemoteCommunication("[initCommunicationLayer()] ", JSON.stringify(y, null, 2)), e !== jo.SOCKET) throw new Error("Invalid communication protocol");
    y.communicationLayer = new Ko({
        communicationLayerPreference: e,
        otherPublicKey: t,
        reconnect: n,
        transports: y.transports,
        communicationServerUrl: i,
        context: y.context,
        ecies: r,
        logging: y.logging,
        remote: o
    });
    let v = "undefined" != typeof document && document.URL || "", b = "undefined" != typeof document && document.title || "";
    (null === (s = y.dappMetadata) || void 0 === s ? void 0 : s.url) && (v = y.dappMetadata.url), (null === (a = y.dappMetadata) || void 0 === a ? void 0 : a.name) && (b = y.dappMetadata.name);
    const w = null !== (u = null !== (l = null === (c = y.dappMetadata) || void 0 === c ? void 0 : c.name) && void 0 !== l ? l : null === (d = y.dappMetadata) || void 0 === d ? void 0 : d.url) && void 0 !== u ? u : "N/A", E = "undefined" != ("TURBOPACK compile-time value", "undefined") && void 0 !== window.location && null !== (h = window.location.hostname) && void 0 !== h ? "TURBOPACK unreachable" : w, S = {
        url: v,
        title: b,
        source: null === (f = y.dappMetadata) || void 0 === f ? void 0 : f.source,
        dappId: E,
        anonId: y.anonId,
        icon: (null === (p = y.dappMetadata) || void 0 === p ? void 0 : p.iconUrl) || (null === (g = y.dappMetadata) || void 0 === g ? void 0 : g.base64Icon),
        platform: y.platformType,
        apiVersion: ho.version,
        connector: null === (m = y.dappMetadata) || void 0 === m ? void 0 : m.connector
    };
    y.originatorInfo = S;
    const _ = {
        [So.AUTHORIZED]: Fo(o),
        [So.MESSAGE]: Yo(o),
        [So.CHANNEL_PERSISTENCE]: Qo(o),
        [So.CLIENTS_CONNECTED]: qo(o, e),
        [So.KEYS_EXCHANGED]: Go(o, e),
        [So.SOCKET_DISCONNECTED]: Jo(o),
        [So.SOCKET_RECONNECT]: Zo(o),
        [So.CLIENTS_DISCONNECTED]: Wo(o),
        [So.KEY_INFO]: ()=>{},
        [So.CHANNEL_CREATED]: zo(o),
        [So.CLIENTS_WAITING]: Vo(o),
        [So.RPC_UPDATE]: (e)=>{
            o.emit(So.RPC_UPDATE, e);
        }
    };
    for (const [t, n] of Object.entries(_))try {
        y.communicationLayer.on(t, n);
    } catch (e) {}
}
function es(e) {
    return c(this, arguments, void 0, function*({ options: e, instance: t }) {
        const { state: n } = t;
        return oo.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${n.channelId}`, e), new Promise((r, i)=>{
            var o, a, c, l, d, u;
            (null == e ? void 0 : e.terminate) ? (t.state.ready && lo({
                id: null !== (o = t.state.channelId) && void 0 !== o ? o : "",
                event: Ao.TERMINATED
            }, t.state.communicationServerUrl).catch((e)=>{}), n.ready = !1, n.paused = !1, null === (a = n.storageManager) || void 0 === a || a.terminate(null !== (c = n.channelId) && void 0 !== c ? c : ""), t.state.terminated = !0, e.sendMessage ? (null === (l = n.communicationLayer) || void 0 === l ? void 0 : l.getKeyInfo().keysExchanged) && t.state.communicationLayer && Oo(t.state.communicationLayer, {
                type: ko.TERMINATE
            }).then(()=>{
                r(!0);
            }).catch((e)=>{
                i(e);
            }) : r(!0), n.authorized = !1, n.relayPersistence = !1, n.channelId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])(), e.channelId = n.channelId, n.channelConfig = void 0, n.originatorConnectStarted = !1, null === (d = n.communicationLayer) || void 0 === d || d.disconnect(e), t.setConnectionStatus(Eo.TERMINATED)) : (null === (u = n.communicationLayer) || void 0 === u || u.disconnect(e), t.setConnectionStatus(Eo.DISCONNECTED), r(!0));
        });
    });
}
(jo || (jo = {})).SOCKET = "socket", function(e) {
    e.NonBrowser = "nodejs", e.MetaMaskMobileWebview = "in-app-browser", e.DesktopWeb = "web-desktop", e.MobileWeb = "web-mobile", e.ReactNative = "react-native";
}(Uo || (Uo = {}));
class ts extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter2$2f$lib$2f$eventemitter2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventEmitter2"] {
    constructor(e){
        super(), this.state = {
            ready: !1,
            anonId: "",
            authorized: !1,
            isOriginator: !1,
            terminated: !1,
            protocolVersion: 1,
            paused: !1,
            deeplinkProtocolAvailable: !1,
            platformType: "metamask-mobile",
            analytics: !1,
            reconnection: !1,
            originatorInfoSent: !1,
            communicationServerUrl: fo,
            context: "",
            persist: !1,
            clientsConnected: !1,
            sessionDuration: go,
            originatorConnectStarted: !1,
            debug: !1,
            _connectionStatus: Eo.DISCONNECTED
        }, this._options = e;
        const { anonId: n, platformType: r, communicationLayerPreference: i, otherPublicKey: o, reconnect: s, walletInfo: a, dappMetadata: c, protocolVersion: l, transports: d, context: u, relayPersistence: h, ecies: f, analytics: p = !1, storage: g, sdkVersion: m, communicationServerUrl: y = fo, logging: v, autoConnect: b = {
            timeout: mo
        } } = e;
        this.state.anonId = n, this.state.otherPublicKey = o, this.state.dappMetadata = c, this.state.walletInfo = a, this.state.transports = d, this.state.platformType = r, this.state.analytics = p, this.state.protocolVersion = null != l ? l : 1, this.state.isOriginator = !o, this.state.relayPersistence = h, this.state.communicationServerUrl = y, this.state.context = u, this.state.terminated = !1, this.state.sdkVersion = m, this.setMaxListeners(50), this.setConnectionStatus(Eo.DISCONNECTED), (null == g ? void 0 : g.duration) && (this.state.sessionDuration = go), this.state.storageOptions = g, this.state.autoConnectOptions = b, this.state.debug = !0 === (null == v ? void 0 : v.remoteLayer), !0 === (null == v ? void 0 : v.remoteLayer) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].enable("RemoteCommunication:Layer"), !0 === (null == v ? void 0 : v.serviceLayer) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].enable("SocketService:Layer"), !0 === (null == v ? void 0 : v.eciesLayer) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].enable("ECIES:Layer"), !0 === (null == v ? void 0 : v.keyExchangeLayer) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].enable("KeyExchange:Layer"), this.state.logging = v, (null == g ? void 0 : g.storageManager) && (this.state.storageManager = g.storageManager), oo.RemoteCommunication(`[RemoteCommunication: constructor()] protocolVersion=${l} relayPersistence=${h} isOriginator=${this.state.isOriginator} communicationLayerPreference=${i} otherPublicKey=${o} reconnect=${s}`), this.state.isOriginator || Xo({
            communicationLayerPreference: i,
            otherPublicKey: o,
            reconnect: s,
            ecies: f,
            communicationServerUrl: y,
            instance: this
        }), this.emitServiceStatusEvent({
            context: "constructor"
        });
    }
    initFromDappStorage() {
        return c(this, void 0, void 0, function*() {
            var e;
            if (this.state.storageManager) {
                const t = yield this.state.storageManager.getPersistedChannelConfig({});
                t && (this.state.channelConfig = t, this.state.channelId = t.channelId, this.state.deeplinkProtocolAvailable = null !== (e = t.deeplinkProtocolAvailable) && void 0 !== e && e, t.relayPersistence && (this.state.authorized = !0, this.state.ready = !0, this.setConnectionStatus(Eo.LINKED), yield this.connectToChannel({
                    channelId: t.channelId
                })));
            }
            Xo({
                communicationLayerPreference: jo.SOCKET,
                otherPublicKey: this.state.otherPublicKey,
                reconnect: this._options.reconnect,
                ecies: this._options.ecies,
                communicationServerUrl: this.state.communicationServerUrl,
                instance: this
            });
        });
    }
    originatorSessionConnect() {
        return c(this, void 0, void 0, function*() {
            return yield function(e) {
                return c(this, void 0, void 0, function*() {
                    var t;
                    const { state: n } = e;
                    if (!n.storageManager) return void oo.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");
                    const r = yield n.storageManager.getPersistedChannelConfig({});
                    if (oo.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${n.originatorConnectStarted} channelConfig`, r), null === (t = n.communicationLayer) || void 0 === t ? void 0 : t.isConnected()) return oo.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"), r;
                    if (r) {
                        if (r.validUntil > Date.now()) return n.channelConfig = r, n.originatorConnectStarted = !0, n.channelId = null == r ? void 0 : r.channelId, n.reconnection = !0, r;
                        oo.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired");
                    }
                    n.originatorConnectStarted = !1;
                });
            }(this);
        });
    }
    generateChannelIdConnect() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                return c(this, void 0, void 0, function*() {
                    var t, n, r, i, o, s;
                    if (!e.communicationLayer) throw new Error("communication layer not initialized");
                    if (e.ready) throw new Error("Channel already connected");
                    if (e.channelId && (null === (t = e.communicationLayer) || void 0 === t ? void 0 : t.isConnected())) return e.channelConfig = Object.assign(Object.assign({}, e.channelConfig), {
                        channelId: e.channelId,
                        validUntil: Date.now() + e.sessionDuration
                    }), null === (n = e.storageManager) || void 0 === n || n.persistChannelConfig(e.channelConfig), {
                        channelId: e.channelId,
                        privKey: null === (i = null === (r = e.communicationLayer) || void 0 === r ? void 0 : r.getKeyInfo()) || void 0 === i ? void 0 : i.ecies.private,
                        pubKey: null === (s = null === (o = e.communicationLayer) || void 0 === o ? void 0 : o.getKeyInfo()) || void 0 === s ? void 0 : s.ecies.public
                    };
                    oo.RemoteCommunication("[RemoteCommunication: generateChannelId()]");
                    const a = yield e.communicationLayer.createChannel();
                    oo.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created", a);
                    const c = Object.assign(Object.assign({}, e.channelConfig), {
                        channelId: a.channelId,
                        localKey: a.privKey,
                        validUntil: Date.now() + e.sessionDuration
                    });
                    return e.channelId = a.channelId, e.channelConfig = c, {
                        channelId: e.channelId,
                        pubKey: a.pubKey,
                        privKey: a.privKey
                    };
                });
            }(this.state);
        });
    }
    clean() {
        return wo(this.state);
    }
    connectToChannel({ channelId: e, withKeyExchange: t, authorized: n }) {
        return function(e) {
            return c(this, arguments, void 0, function*({ channelId: e, withKeyExchange: t, authorized: n, state: r }) {
                var i, s, a;
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__["validate"])(e)) throw oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r.context} invalid channel channelId=${e}`), new Error(`Invalid channel ${e}`);
                if (oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r.context} channelId=${e} withKeyExchange=${t}`), null === (i = r.communicationLayer) || void 0 === i ? void 0 : i.isConnected()) return void oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r.context} already connected - interrupt connection.`);
                r.channelId = e, yield null === (s = r.communicationLayer) || void 0 === s ? void 0 : s.connectToChannel({
                    channelId: e,
                    authorized: n,
                    withKeyExchange: t
                });
                const c = Object.assign(Object.assign({}, r.channelConfig), {
                    channelId: e,
                    validUntil: Date.now() + r.sessionDuration
                });
                r.channelConfig = c, null === (a = r.storageManager) || void 0 === a || a.persistChannelConfig(c);
            });
        }({
            channelId: e,
            authorized: n,
            withKeyExchange: t,
            state: this.state
        });
    }
    sendMessage(e) {
        return c(this, void 0, void 0, function*() {
            const t = this.state.isOriginator && e.method && bo(e.method);
            t && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_action_requested", {
                action: e.method
            });
            try {
                return yield function(e, t) {
                    return c(this, void 0, void 0, function*() {
                        var n, r;
                        const { state: i } = e;
                        oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context} paused=${i.paused} ready=${i.ready} relayPersistence=${i.relayPersistence} authorized=${i.authorized} socket=${null === (n = i.communicationLayer) || void 0 === n ? void 0 : n.isConnected()} clientsConnected=${i.clientsConnected} status=${i._connectionStatus}`, t), i.relayPersistence || i.ready && (null === (r = i.communicationLayer) || void 0 === r ? void 0 : r.isConnected()) && i.clientsConnected || (oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context}  SKIP message waiting for MM mobile readiness.`), yield new Promise((t)=>{
                            e.once(So.CLIENTS_READY, t);
                        }), oo.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context}  AFTER SKIP / READY -- sending pending message`));
                        try {
                            const n = yield function(e, t) {
                                return c(this, void 0, void 0, function*() {
                                    return new Promise((n)=>{
                                        var r;
                                        const { state: i } = e;
                                        oo.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i.context} ready=${i.ready} authorized=${i.authorized} method=${t.method}`), !i.isOriginator || i.authorized || i.relayPersistence ? null === (r = i.communicationLayer) || void 0 === r || r.sendMessage(t).then((e)=>{
                                            n(e);
                                        }).catch((e)=>{
                                            n(!1);
                                        }) : e.once(So.AUTHORIZED, ()=>{
                                            var e;
                                            oo.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i.context}  AFTER SKIP / AUTHORIZED -- sending pending message`), null === (e = i.communicationLayer) || void 0 === e || e.sendMessage(t).then((e)=>{
                                                n(e);
                                            }).catch((e)=>{
                                                n(!1);
                                            });
                                        });
                                    });
                                });
                            }(e, t);
                            return n;
                        } catch (e) {
                            throw e;
                        }
                    });
                }(this, e);
            } catch (r) {
                throw t && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_action_failed", {
                    action: e.method
                }), r;
            }
        });
    }
    testStorage() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                return c(this, void 0, void 0, function*() {
                    var t;
                    const n = yield null === (t = e.storageManager) || void 0 === t ? void 0 : t.getPersistedChannelConfig();
                    oo.RemoteCommunication("[RemoteCommunication: testStorage()] res", n);
                });
            }(this.state);
        });
    }
    hasDeeplinkProtocol() {
        return this.state.deeplinkProtocolAvailable;
    }
    getChannelConfig() {
        return this.state.channelConfig;
    }
    isReady() {
        return this.state.ready;
    }
    isConnected() {
        var e;
        return null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.isConnected();
    }
    isAuthorized() {
        return this.state.authorized;
    }
    isPaused() {
        return this.state.paused;
    }
    getCommunicationLayer() {
        return this.state.communicationLayer;
    }
    ping() {
        return c(this, void 0, void 0, function*() {
            var e;
            oo.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`), yield null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.ping();
        });
    }
    testLogger() {
        oo.RemoteCommunication(`testLogger() channel=${this.state.channelId}`), oo.SocketService(`testLogger() channel=${this.state.channelId}`), oo.Ecies(`testLogger() channel=${this.state.channelId}`), oo.KeyExchange(`testLogger() channel=${this.state.channelId}`);
    }
    keyCheck() {
        var e;
        oo.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`), null === (e = this.state.communicationLayer) || void 0 === e || e.keyCheck();
    }
    setConnectionStatus(e) {
        this.state._connectionStatus !== e && (this.state._connectionStatus = e, this.emit(So.CONNECTION_STATUS, e), this.emitServiceStatusEvent({
            context: "setConnectionStatus"
        }));
    }
    emitServiceStatusEvent(e = {}) {
        this.emit(So.SERVICE_STATUS, this.getServiceStatus());
    }
    getConnectionStatus() {
        return this.state._connectionStatus;
    }
    getServiceStatus() {
        return {
            originatorInfo: this.state.originatorInfo,
            keyInfo: this.getKeyInfo(),
            connectionStatus: this.state._connectionStatus,
            channelConfig: this.state.channelConfig,
            channelId: this.state.channelId
        };
    }
    getKeyInfo() {
        var e;
        return null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.getKeyInfo();
    }
    resetKeys() {
        var e;
        null === (e = this.state.communicationLayer) || void 0 === e || e.resetKeys();
    }
    setOtherPublicKey(e) {
        var t;
        const n = null === (t = this.state.communicationLayer) || void 0 === t ? void 0 : t.getKeyExchange();
        if (!n) throw new Error("KeyExchange is not initialized.");
        n.getOtherPublicKey() !== e && n.setOtherPublicKey(e);
    }
    pause() {
        return c(this, void 0, void 0, function*() {
            var e;
            oo.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`), yield null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.pause(), this.setConnectionStatus(Eo.PAUSED);
        });
    }
    getVersion() {
        return ho.version;
    }
    hasRelayPersistence() {
        var e;
        return null !== (e = this.state.relayPersistence) && void 0 !== e && e;
    }
    resume() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                return c(this, void 0, void 0, function*() {
                    var t;
                    const { state: n } = e;
                    oo.RemoteCommunication(`[RemoteCommunication: resume()] channel=${n.channelId}`), yield null === (t = n.communicationLayer) || void 0 === t ? void 0 : t.resume(), e.setConnectionStatus(Eo.LINKED);
                });
            }(this);
        });
    }
    encrypt(e) {
        var t, n, r;
        const i = null === (t = this.state.communicationLayer) || void 0 === t ? void 0 : t.getKeyExchange(), o = null == i ? void 0 : i.getOtherPublicKey();
        if (!o) throw new Error("KeyExchange not completed");
        return null === (r = null === (n = this.state.communicationLayer) || void 0 === n ? void 0 : n.state.eciesInstance) || void 0 === r ? void 0 : r.encrypt(e, o);
    }
    decrypt(e) {
        var t, n, r;
        if (!(null === (t = this.state.communicationLayer) || void 0 === t ? void 0 : t.state.eciesInstance)) throw new Error("ECIES instance is not initialized");
        return null === (r = null === (n = this.state.communicationLayer) || void 0 === n ? void 0 : n.state.eciesInstance) || void 0 === r ? void 0 : r.decrypt(e);
    }
    getChannelId() {
        return this.state.channelId;
    }
    getRPCMethodTracker() {
        var e;
        return null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.getRPCMethodTracker();
    }
    reject({ channelId: e }) {
        return function(e) {
            return c(this, arguments, void 0, function*({ channelId: e, state: t }) {
                var n, r, i;
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__["validate"])(e)) throw oo.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${t.context} invalid channel channelId=${e}`), new Error(`Invalid channel ${e}`);
                if (t.isOriginator) return void oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t.context} isOriginator=${t.isOriginator} channelId=${e}`);
                const { socket: s } = null !== (r = null === (n = t.communicationLayer) || void 0 === n ? void 0 : n.state) && void 0 !== r ? r : {};
                (null == s ? void 0 : s.connected) || (oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t.context} socket already connected`), null == s || s.connect()), lo(Object.assign(Object.assign({
                    id: e,
                    event: Ao.REJECTED
                }, t.originatorInfo), {
                    sdkVersion: t.sdkVersion,
                    commLayerVersion: ho.version,
                    walletVersion: null === (i = t.walletInfo) || void 0 === i ? void 0 : i.version
                }), t.communicationServerUrl).catch((e)=>{}), yield new Promise((n, r)=>{
                    null == s || s.emit(So.REJECTED, {
                        channelId: e
                    }, (e, i)=>{
                        oo.RemoteCommunication(`[RemoteCommunication: reject()] context=${t.context} socket=${null == s ? void 0 : s.id}`, {
                            error: e,
                            response: i
                        }), e ? r(e) : n(i);
                    });
                });
            });
        }({
            channelId: e,
            state: this.state
        });
    }
    disconnect(e) {
        return c(this, void 0, void 0, function*() {
            return es({
                options: e,
                instance: this
            });
        });
    }
}
!function(e) {
    e.RENEW = "renew", e.LINK = "link";
}(Ho || (Ho = {}));
var ns = "ERC721", rs = "ERC1155", is = {
    errors: {
        disconnected: ()=>"MetaMask: Disconnected from chain. Attempting to connect.",
        permanentlyDisconnected: ()=>"MetaMask: Disconnected from MetaMask background. Page reload required.",
        sendSiteMetadata: ()=>"MetaMask: Failed to send site metadata. This is an internal error, please report this bug.",
        unsupportedSync: (e)=>`MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${e} without a callback parameter.`,
        invalidDuplexStream: ()=>"Must provide a Node.js-style duplex stream.",
        invalidNetworkParams: ()=>"MetaMask: Received invalid network parameters. Please report this bug.",
        invalidRequestArgs: ()=>"Expected a single, non-array, object argument.",
        invalidRequestMethod: ()=>"'args.method' must be a non-empty string.",
        invalidRequestParams: ()=>"'args.params' must be an object or array if provided.",
        invalidLoggerObject: ()=>"'args.logger' must be an object if provided.",
        invalidLoggerMethod: (e)=>`'args.logger' must include required method '${e}'.`
    },
    info: {
        connected: (e)=>`MetaMask: Connected to chain with ID "${e}".`
    },
    warnings: {
        chainIdDeprecation: "MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23",
        networkVersionDeprecation: "MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23",
        selectedAddressDeprecation: "MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23",
        enableDeprecation: "MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1102",
        sendDeprecation: "MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193",
        events: {
            close: "MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect",
            data: "MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message",
            networkChanged: "MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged",
            notification: "MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message"
        },
        rpc: {
            ethDecryptDeprecation: "MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686",
            ethGetEncryptionPublicKeyDeprecation: "MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686",
            walletWatchAssetNFTExperimental: "MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle"
        },
        experimentalMethods: "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning."
    }
};
function os(e) {
    const t = {
        ethDecryptDeprecation: !1,
        ethGetEncryptionPublicKeyDeprecation: !1,
        walletWatchAssetNFTExperimental: !1
    };
    return (n, r, i)=>{
        t.ethDecryptDeprecation || "eth_decrypt" !== n.method ? t.ethGetEncryptionPublicKeyDeprecation || "eth_getEncryptionPublicKey" !== n.method ? !t.walletWatchAssetNFTExperimental && "wallet_watchAsset" === n.method && [
            ns,
            rs
        ].includes(n.params?.type || "") && (e.warn(is.warnings.rpc.walletWatchAssetNFTExperimental), t.walletWatchAssetNFTExperimental = !0) : (e.warn(is.warnings.rpc.ethGetEncryptionPublicKeyDeprecation), t.ethGetEncryptionPublicKeyDeprecation = !0) : (e.warn(is.warnings.rpc.ethDecryptDeprecation), t.ethDecryptDeprecation = !0), i();
    };
}
var ss = 4294967295, as = Math.floor(Math.random() * ss);
function cs() {
    return (e, t, n, r)=>{
        const i = e.id, o = as = (as + 1) % ss;
        e.id = o, t.id = o, n((n)=>{
            e.id = i, t.id = i, n();
        });
    };
}
var ls = (e, t, n)=>{
    if (!t.has(e)) throw TypeError("Cannot " + n);
}, ds = (e, t, n)=>(ls(e, t, "read from private field"), n ? n.call(e) : t.get(e)), us = (e, t, n)=>{
    if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, hs = (e, t, n, r)=>(ls(e, t, "write to private field"), t.set(e, n), n), fs = (e, t, n)=>(ls(e, t, "access private method"), n), ps = {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
}, gs = {
    "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
    },
    "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
    },
    "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
    },
    "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
    },
    "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
    },
    "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
    },
    "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
    },
    "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
    },
    "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
    },
    4001: {
        standard: "EIP-1193",
        message: "User rejected the request."
    },
    4100: {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
    },
    4901: {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
    }
};
function ms(e) {
    return Boolean(e) && "object" == typeof e && !Array.isArray(e);
}
var ys = (e, t)=>Object.hasOwnProperty.call(e, t);
class vs extends TypeError {
    constructor(e, t){
        let n;
        const { message: r, explanation: i, ...o } = e, { path: s } = e, a = 0 === s.length ? r : `At path: ${s.join(".")} -- ${r}`;
        super(i ?? a), null != i && (this.cause = a), Object.assign(this, o), this.name = this.constructor.name, this.failures = ()=>n ?? (n = [
                e,
                ...t()
            ]);
    }
}
function bs(e) {
    return "object" == typeof e && null != e;
}
function ws(e) {
    return "symbol" == typeof e ? e.toString() : "string" == typeof e ? JSON.stringify(e) : `${e}`;
}
function Es(e, t, n, r) {
    if (!0 === e) return;
    !1 === e ? e = {} : "string" == typeof e && (e = {
        message: e
    });
    const { path: i, branch: o } = t, { type: s } = n, { refinement: a, message: c = `Expected a value of type \`${s}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${ws(r)}\`` } = e;
    return {
        value: r,
        type: s,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: o,
        ...e,
        message: c
    };
}
function* Ss(e, t, n, r) {
    (function(e) {
        return bs(e) && "function" == typeof e[Symbol.iterator];
    })(e) || (e = [
        e
    ]);
    for (const i of e){
        const e = Es(i, t, n, r);
        e && (yield e);
    }
}
function* _s(e, t, n = {}) {
    const { path: r = [], branch: i = [
        e
    ], coerce: o = !1, mask: s = !1 } = n, a = {
        path: r,
        branch: i
    };
    if (o && (e = t.coercer(e, a), s && "type" !== t.type && bs(t.schema) && bs(e) && !Array.isArray(e))) for(const n in e)void 0 === t.schema[n] && delete e[n];
    let c = "valid";
    for (const r of t.validator(e, a))r.explanation = n.message, c = "not_valid", yield [
        r,
        void 0
    ];
    for (let [l, d, u] of t.entries(e, a)){
        const t = _s(d, u, {
            path: void 0 === l ? r : [
                ...r,
                l
            ],
            branch: void 0 === l ? i : [
                ...i,
                d
            ],
            coerce: o,
            mask: s,
            message: n.message
        });
        for (const n of t)n[0] ? (c = null != n[0].refinement ? "not_refined" : "not_valid", yield [
            n[0],
            void 0
        ]) : o && (d = n[1], void 0 === l ? e = d : e instanceof Map ? e.set(l, d) : e instanceof Set ? e.add(d) : bs(e) && (void 0 !== d || l in e) && (e[l] = d));
    }
    if ("not_valid" !== c) for (const r of t.refiner(e, a))r.explanation = n.message, c = "not_refined", yield [
        r,
        void 0
    ];
    "valid" === c && (yield [
        void 0,
        e
    ]);
}
class Cs {
    constructor(e){
        const { type: t, schema: n, validator: r, refiner: i, coercer: o = (e)=>e, entries: s = function*() {} } = e;
        this.type = t, this.schema = n, this.entries = s, this.coercer = o, this.validator = r ? (e, t)=>Ss(r(e, t), t, this, e) : ()=>[], this.refiner = i ? (e, t)=>Ss(i(e, t), t, this, e) : ()=>[];
    }
    assert(e, t) {
        return ks(e, this, t);
    }
    create(e, t) {
        return As(e, this, t);
    }
    is(e) {
        return xs(e, this);
    }
    mask(e, t) {
        return function(e, t, n) {
            const r = Ms(e, t, {
                coerce: !0,
                mask: !0,
                message: n
            });
            if (r[0]) throw r[0];
            return r[1];
        }(e, this, t);
    }
    validate(e, t = {}) {
        return Ms(e, this, t);
    }
}
function ks(e, t, n) {
    const r = Ms(e, t, {
        message: n
    });
    if (r[0]) throw r[0];
}
function As(e, t, n) {
    const r = Ms(e, t, {
        coerce: !0,
        message: n
    });
    if (r[0]) throw r[0];
    return r[1];
}
function xs(e, t) {
    return !Ms(e, t)[0];
}
function Ms(e, t, n = {}) {
    const r = _s(e, t, n), i = function(e) {
        const { done: t, value: n } = e.next();
        return t ? void 0 : n;
    }(r);
    if (i[0]) {
        const e = new vs(i[0], function*() {
            for (const e of r)e[0] && (yield e[0]);
        });
        return [
            e,
            void 0
        ];
    }
    return [
        void 0,
        i[1]
    ];
}
function Is(e, t) {
    return new Cs({
        type: e,
        schema: null,
        validator: t
    });
}
function Ts(e) {
    let t;
    return new Cs({
        type: "lazy",
        schema: null,
        *entries (n, r) {
            t ?? (t = e()), yield* t.entries(n, r);
        },
        validator: (n, r)=>(t ?? (t = e()), t.validator(n, r)),
        coercer: (n, r)=>(t ?? (t = e()), t.coercer(n, r)),
        refiner: (n, r)=>(t ?? (t = e()), t.refiner(n, r))
    });
}
function Rs(e) {
    return new Cs({
        type: "array",
        schema: e,
        *entries (t) {
            if (e && Array.isArray(t)) for (const [n, r] of t.entries())yield [
                n,
                r,
                e
            ];
        },
        coercer: (e)=>Array.isArray(e) ? e.slice() : e,
        validator: (e)=>Array.isArray(e) || `Expected an array value, but received: ${ws(e)}`
    });
}
function Ps(e) {
    const t = ws(e), n = typeof e;
    return new Cs({
        type: "literal",
        schema: "string" === n || "number" === n || "boolean" === n ? e : null,
        validator: (n)=>n === e || `Expected the literal \`${t}\`, but received: ${ws(n)}`
    });
}
function Os() {
    return Is("number", (e)=>"number" == typeof e && !isNaN(e) || `Expected a number, but received: ${ws(e)}`);
}
function Ns(e) {
    const t = e ? Object.keys(e) : [], n = Is("never", ()=>!1);
    return new Cs({
        type: "object",
        schema: e || null,
        *entries (r) {
            if (e && bs(r)) {
                const i = new Set(Object.keys(r));
                for (const n of t)i.delete(n), yield [
                    n,
                    r[n],
                    e[n]
                ];
                for (const e of i)yield [
                    e,
                    r[e],
                    n
                ];
            }
        },
        validator: (e)=>bs(e) || `Expected an object, but received: ${ws(e)}`,
        coercer: (e)=>bs(e) ? {
                ...e
            } : e
    });
}
function Ls(e) {
    return new Cs({
        ...e,
        validator: (t, n)=>void 0 === t || e.validator(t, n),
        refiner: (t, n)=>void 0 === t || e.refiner(t, n)
    });
}
function Ds(e, t) {
    return new Cs({
        type: "record",
        schema: null,
        *entries (n) {
            if (bs(n)) for(const r in n){
                const i = n[r];
                yield [
                    r,
                    r,
                    e
                ], yield [
                    r,
                    i,
                    t
                ];
            }
        },
        validator: (e)=>bs(e) || `Expected an object, but received: ${ws(e)}`
    });
}
function $s() {
    return Is("string", (e)=>"string" == typeof e || `Expected a string, but received: ${ws(e)}`);
}
function Bs(e) {
    const t = e.map((e)=>e.type).join(" | ");
    return new Cs({
        type: "union",
        schema: null,
        coercer (t) {
            for (const n of e){
                const [e, r] = n.validate(t, {
                    coerce: !0
                });
                if (!e) return r;
            }
            return t;
        },
        validator (n, r) {
            const i = [];
            for (const t of e){
                const [...e] = _s(n, t, r), [o] = e;
                if (!o[0]) return [];
                for (const [t] of e)t && i.push(t);
            }
            return [
                `Expected the value to satisfy a union of \`${t}\`, but received: ${ws(n)}`,
                ...i
            ];
        }
    });
}
function Ks(e) {
    return (function(e) {
        return function(e) {
            return "object" == typeof e && null !== e && "message" in e;
        }(e) && "string" == typeof e.message ? e.message : null == e ? "" : String(e);
    })(e).replace(/\.$/u, "");
}
function js(e, t) {
    return n = e, Boolean("string" == typeof n?.prototype?.constructor?.name) ? new e({
        message: t
    }) : e({
        message: t
    });
    //TURBOPACK unreachable
    ;
    var n;
}
var Us = class extends Error {
    constructor(e){
        super(e.message), this.code = "ERR_ASSERTION";
    }
};
function Hs() {
    throw new Error("setTimeout has not been defined");
}
function Fs() {
    throw new Error("clearTimeout has not been defined");
}
var zs = Hs, qs = Fs;
function Ws(e) {
    if (zs === setTimeout) return setTimeout(e, 0);
    if ((zs === Hs || !zs) && setTimeout) return zs = setTimeout, setTimeout(e, 0);
    try {
        return zs(e, 0);
    } catch (t) {
        try {
            return zs.call(null, e, 0);
        } catch (t) {
            return zs.call(this, e, 0);
        }
    }
}
"function" == typeof l.setTimeout && (zs = setTimeout), "function" == typeof l.clearTimeout && (qs = clearTimeout);
var Vs, Gs = [], Ys = !1, Zs = -1;
function Js() {
    Ys && Vs && (Ys = !1, Vs.length ? Gs = Vs.concat(Gs) : Zs = -1, Gs.length && Qs());
}
function Qs() {
    if (!Ys) {
        var e = Ws(Js);
        Ys = !0;
        for(var t = Gs.length; t;){
            for(Vs = Gs, Gs = []; ++Zs < t;)Vs && Vs[Zs].run();
            Zs = -1, t = Gs.length;
        }
        Vs = null, Ys = !1, function(e) {
            if (qs === clearTimeout) return clearTimeout(e);
            if ((qs === Fs || !qs) && clearTimeout) return qs = clearTimeout, clearTimeout(e);
            try {
                return qs(e);
            } catch (t) {
                try {
                    return qs.call(null, e);
                } catch (t) {
                    return qs.call(this, e);
                }
            }
        }(e);
    }
}
function Xs(e, t) {
    this.fun = e, this.array = t;
}
Xs.prototype.run = function() {
    this.fun.apply(null, this.array);
};
function ea() {}
var ta = ea, na = ea, ra = ea, ia = ea, oa = ea, sa = ea, aa = ea;
var ca = l.performance || {}, la = ca.now || ca.mozNow || ca.msNow || ca.oNow || ca.webkitNow || function() {
    return (new Date).getTime();
};
var da = new Date;
var ua = {
    nextTick: function(e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) for(var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n];
        Gs.push(new Xs(e, t)), 1 !== Gs.length || Ys || Ws(Qs);
    },
    title: "browser",
    browser: !0,
    env: {},
    argv: [],
    version: "",
    versions: {},
    on: ta,
    addListener: na,
    once: ra,
    off: ia,
    removeListener: oa,
    removeAllListeners: sa,
    emit: aa,
    binding: function(e) {
        throw new Error("process.binding is not supported");
    },
    cwd: function() {
        return "/";
    },
    chdir: function(e) {
        throw new Error("process.chdir is not supported");
    },
    umask: function() {
        return 0;
    },
    hrtime: function(e) {
        var t = .001 * la.call(ca), n = Math.floor(t), r = Math.floor(t % 1 * 1e9);
        return e && (n -= e[0], (r -= e[1]) < 0 && (n--, r += 1e9)), [
            n,
            r
        ];
    },
    platform: "browser",
    release: {},
    config: {},
    uptime: function() {
        return (new Date - da) / 1e3;
    }
}, ha = (e)=>Ns(e);
function fa({ path: e, branch: t }) {
    const n = e[e.length - 1];
    return ys(t[t.length - 2], n);
}
function pa(e) {
    return new Cs({
        ...e,
        type: `optional ${e.type}`,
        validator: (t, n)=>!fa(n) || e.validator(t, n),
        refiner: (t, n)=>!fa(n) || e.refiner(t, n)
    });
}
var ga, ma, ya, va = Bs([
    Ps(null),
    Is("boolean", (e)=>"boolean" == typeof e),
    Is("finite number", (e)=>xs(e, Os()) && Number.isFinite(e)),
    $s(),
    Rs(Ts(()=>va)),
    Ds($s(), Ts(()=>va))
]), ba = (ga = va, ma = Is("any", ()=>!0), ya = (e)=>((function(e, t, n = "Assertion failed", r = Us) {
        try {
            ks(e, t);
        } catch (e) {
            throw js(r, `${n}: ${Ks(e)}.`);
        }
    })(e, va), JSON.parse(JSON.stringify(e, (e, t)=>{
        if ("__proto__" !== e && "constructor" !== e) return t;
    }))), new Cs({
    ...ga,
    coercer: (e, t)=>xs(e, ma) ? ga.coercer(ya(e, t), t) : ga.coercer(e, t)
}));
function wa(e) {
    try {
        return function(e) {
            As(e, ba);
        }(e), !0;
    } catch  {
        return !1;
    }
}
var Ea = Ps("2.0"), Sa = function(e) {
    return new Cs({
        ...e,
        validator: (t, n)=>null === t || e.validator(t, n),
        refiner: (t, n)=>null === t || e.refiner(t, n)
    });
}(Bs([
    Os(),
    $s()
])), _a = ha({
    code: Is("integer", (e)=>"number" == typeof e && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${ws(e)}`),
    message: $s(),
    data: pa(ba),
    stack: pa($s())
}), Ca = Bs([
    Ds($s(), ba),
    Rs(ba)
]), ka = ha({
    id: Sa,
    jsonrpc: Ea,
    method: $s(),
    params: pa(Ca)
}), Aa = ha({
    jsonrpc: Ea,
    method: $s(),
    params: pa(Ca)
});
function xa(e) {
    return xs(e, ka);
}
function Ma(e) {
    return xs(e, _a);
}
Ns({
    id: Sa,
    jsonrpc: Ea,
    result: Ls(Is("unknown", ()=>!0)),
    error: Ls(_a)
}), Bs([
    ha({
        id: Sa,
        jsonrpc: Ea,
        result: ba
    }),
    ha({
        id: Sa,
        jsonrpc: Ea,
        error: _a
    })
]);
var Ia = ps.internal, Ta = "Unspecified error message. This is a bug, please report it.", Ra = {
    code: Ia,
    message: Oa(Ia)
}, Pa = "Unspecified server error.";
function Oa(e, t = Ta) {
    if (function(e) {
        return Number.isInteger(e);
    }(e)) {
        const t = e.toString();
        if (ys(gs, t)) return gs[t].message;
        if (function(e) {
            return e >= -32099 && e <= -32e3;
        }(e)) return Pa;
    }
    return t;
}
function Na(e, { fallbackError: t = Ra, shouldIncludeStack: n = !0 } = {}) {
    if (!Ma(t)) throw new Error("Must provide fallback error with integer number code and string message.");
    const r = function(e, t) {
        if (e && "object" == typeof e && "serialize" in e && "function" == typeof e.serialize) return e.serialize();
        if (Ma(e)) return e;
        const n = La(e), r = {
            ...t,
            data: {
                cause: n
            }
        };
        return r;
    }(e, t);
    return n || delete r.stack, r;
}
function La(e) {
    return Array.isArray(e) ? e.map((e)=>wa(e) ? e : ms(e) ? Da(e) : null) : ms(e) ? Da(e) : wa(e) ? e : null;
}
function Da(e) {
    return Object.getOwnPropertyNames(e).reduce((t, n)=>{
        const r = e[n];
        return wa(r) && (t[n] = r), t;
    }, {});
}
var $a = Fa;
Fa.default = Fa, Fa.stable = Va, Fa.stableStringify = Va;
var Ba = "[...]", Ka = "[Circular]", ja = [], Ua = [];
function Ha() {
    return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
    };
}
function Fa(e, t, n, r) {
    var i;
    void 0 === r && (r = Ha()), qa(e, "", 0, [], void 0, 0, r);
    try {
        i = 0 === Ua.length ? JSON.stringify(e, t, n) : JSON.stringify(e, Ya(t), n);
    } catch (e) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally{
        for(; 0 !== ja.length;){
            var o = ja.pop();
            4 === o.length ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2];
        }
    }
    return i;
}
function za(e, t, n, r) {
    var i = Object.getOwnPropertyDescriptor(r, n);
    void 0 !== i.get ? i.configurable ? (Object.defineProperty(r, n, {
        value: e
    }), ja.push([
        r,
        n,
        t,
        i
    ])) : Ua.push([
        t,
        n,
        e
    ]) : (r[n] = e, ja.push([
        r,
        n,
        t
    ]));
}
function qa(e, t, n, r, i, o, s) {
    var a;
    if (o += 1, "object" == typeof e && null !== e) {
        for(a = 0; a < r.length; a++)if (r[a] === e) return void za(Ka, e, t, i);
        if (void 0 !== s.depthLimit && o > s.depthLimit) return void za(Ba, e, t, i);
        if (void 0 !== s.edgesLimit && n + 1 > s.edgesLimit) return void za(Ba, e, t, i);
        if (r.push(e), Array.isArray(e)) for(a = 0; a < e.length; a++)qa(e[a], a, a, r, e, o, s);
        else {
            var c = Object.keys(e);
            for(a = 0; a < c.length; a++){
                var l = c[a];
                qa(e[l], l, a, r, e, o, s);
            }
        }
        r.pop();
    }
}
function Wa(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
}
function Va(e, t, n, r) {
    void 0 === r && (r = Ha());
    var i, o = Ga(e, "", 0, [], void 0, 0, r) || e;
    try {
        i = 0 === Ua.length ? JSON.stringify(o, t, n) : JSON.stringify(o, Ya(t), n);
    } catch (e) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally{
        for(; 0 !== ja.length;){
            var s = ja.pop();
            4 === s.length ? Object.defineProperty(s[0], s[1], s[3]) : s[0][s[1]] = s[2];
        }
    }
    return i;
}
function Ga(e, t, n, r, i, o, s) {
    var a;
    if (o += 1, "object" == typeof e && null !== e) {
        for(a = 0; a < r.length; a++)if (r[a] === e) return void za(Ka, e, t, i);
        try {
            if ("function" == typeof e.toJSON) return;
        } catch (e) {
            return;
        }
        if (void 0 !== s.depthLimit && o > s.depthLimit) return void za(Ba, e, t, i);
        if (void 0 !== s.edgesLimit && n + 1 > s.edgesLimit) return void za(Ba, e, t, i);
        if (r.push(e), Array.isArray(e)) for(a = 0; a < e.length; a++)Ga(e[a], a, a, r, e, o, s);
        else {
            var c = {}, l = Object.keys(e).sort(Wa);
            for(a = 0; a < l.length; a++){
                var d = l[a];
                Ga(e[d], d, a, r, e, o, s), c[d] = e[d];
            }
            if (void 0 === i) return c;
            ja.push([
                i,
                t,
                e
            ]), i[t] = c;
        }
        r.pop();
    }
}
function Ya(e) {
    return e = void 0 !== e ? e : function(e, t) {
        return t;
    }, function(t, n) {
        if (Ua.length > 0) for(var r = 0; r < Ua.length; r++){
            var i = Ua[r];
            if (i[1] === t && i[0] === n) {
                n = i[2], Ua.splice(r, 1);
                break;
            }
        }
        return e.call(this, t, n);
    };
}
var Za = ue($a), Ja = class extends Error {
    constructor(e, t, n){
        if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
        if (!t || "string" != typeof t) throw new Error('"message" must be a non-empty string.');
        super(t), this.code = e, void 0 !== n && (this.data = n);
    }
    serialize() {
        const e = {
            code: this.code,
            message: this.message
        };
        return void 0 !== this.data && (e.data = this.data, function(e) {
            if ("object" != typeof e || null === e) return !1;
            try {
                let t = e;
                for(; null !== Object.getPrototypeOf(t);)t = Object.getPrototypeOf(t);
                return Object.getPrototypeOf(e) === t;
            } catch (e) {
                return !1;
            }
        }(this.data) && (e.data.cause = La(this.data.cause))), this.stack && (e.stack = this.stack), e;
    }
    toString() {
        return Za(this.serialize(), Qa, 2);
    }
};
function Qa(e, t) {
    if ("[Circular]" !== t) return t;
}
var Xa = (e)=>ec(ps.invalidRequest, e);
function ec(e, t) {
    const [n, r] = function(e) {
        if (e) {
            if ("string" == typeof e) return [
                e
            ];
            if ("object" == typeof e && !Array.isArray(e)) {
                const { message: t, data: n } = e;
                if (t && "string" != typeof t) throw new Error("Must specify string message.");
                return [
                    t ?? void 0,
                    n
                ];
            }
        }
        return [];
    }(t);
    return new Ja(e, n ?? Oa(e), r);
}
var tc = {};
function nc() {}
function rc() {
    rc.init.call(this);
}
function ic(e) {
    return void 0 === e._maxListeners ? rc.defaultMaxListeners : e._maxListeners;
}
function oc(e, t, n, r) {
    var i, o, s;
    if ("function" != typeof n) throw new TypeError('"listener" argument must be a function');
    if ((o = e._events) ? (o.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), o = e._events), s = o[t]) : (o = e._events = new nc, e._eventsCount = 0), s) {
        if ("function" == typeof s ? s = o[t] = r ? [
            n,
            s
        ] : [
            s,
            n
        ] : r ? s.unshift(n) : s.push(n), !s.warned && (i = ic(e)) && i > 0 && s.length > i) {
            s.warned = !0;
            var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + t + " listeners added. Use emitter.setMaxListeners() to increase limit");
            a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t, a.count = s.length, function(e) {
                "function" == typeof console.warn ? console.warn(e) : console.log(e);
            }(a);
        }
    } else s = o[t] = n, ++e._eventsCount;
    return e;
}
function sc(e, t, n) {
    var r = !1;
    function i() {
        e.removeListener(t, i), r || (r = !0, n.apply(e, arguments));
    }
    return i.listener = n, i;
}
function ac(e) {
    var t = this._events;
    if (t) {
        var n = t[e];
        if ("function" == typeof n) return 1;
        if (n) return n.length;
    }
    return 0;
}
function cc(e, t) {
    for(var n = new Array(t); t--;)n[t] = e[t];
    return n;
}
nc.prototype = Object.create(null), rc.EventEmitter = rc, rc.usingDomains = !1, rc.prototype.domain = void 0, rc.prototype._events = void 0, rc.prototype._maxListeners = void 0, rc.defaultMaxListeners = 10, rc.init = function() {
    this.domain = null, rc.usingDomains && undefined.active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new nc, this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, rc.prototype.setMaxListeners = function(e) {
    if ("number" != typeof e || e < 0 || isNaN(e)) throw new TypeError('"n" argument must be a positive number');
    return this._maxListeners = e, this;
}, rc.prototype.getMaxListeners = function() {
    return ic(this);
}, rc.prototype.emit = function(e) {
    var t, n, r, i, o, s, a, c = "error" === e;
    if (s = this._events) c = c && null == s.error;
    else if (!c) return !1;
    if (a = this.domain, c) {
        if (t = arguments[1], !a) {
            if (t instanceof Error) throw t;
            var l = new Error('Uncaught, unspecified "error" event. (' + t + ")");
            throw l.context = t, l;
        }
        return t || (t = new Error('Uncaught, unspecified "error" event')), t.domainEmitter = this, t.domain = a, t.domainThrown = !1, a.emit("error", t), !1;
    }
    if (!(n = s[e])) return !1;
    var d = "function" == typeof n;
    switch(r = arguments.length){
        case 1:
            !function(e, t, n) {
                if (t) e.call(n);
                else for(var r = e.length, i = cc(e, r), o = 0; o < r; ++o)i[o].call(n);
            }(n, d, this);
            break;
        case 2:
            !function(e, t, n, r) {
                if (t) e.call(n, r);
                else for(var i = e.length, o = cc(e, i), s = 0; s < i; ++s)o[s].call(n, r);
            }(n, d, this, arguments[1]);
            break;
        case 3:
            !function(e, t, n, r, i) {
                if (t) e.call(n, r, i);
                else for(var o = e.length, s = cc(e, o), a = 0; a < o; ++a)s[a].call(n, r, i);
            }(n, d, this, arguments[1], arguments[2]);
            break;
        case 4:
            !function(e, t, n, r, i, o) {
                if (t) e.call(n, r, i, o);
                else for(var s = e.length, a = cc(e, s), c = 0; c < s; ++c)a[c].call(n, r, i, o);
            }(n, d, this, arguments[1], arguments[2], arguments[3]);
            break;
        default:
            for(i = new Array(r - 1), o = 1; o < r; o++)i[o - 1] = arguments[o];
            !function(e, t, n, r) {
                if (t) e.apply(n, r);
                else for(var i = e.length, o = cc(e, i), s = 0; s < i; ++s)o[s].apply(n, r);
            }(n, d, this, i);
    }
    return !0;
}, rc.prototype.addListener = function(e, t) {
    return oc(this, e, t, !1);
}, rc.prototype.on = rc.prototype.addListener, rc.prototype.prependListener = function(e, t) {
    return oc(this, e, t, !0);
}, rc.prototype.once = function(e, t) {
    if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
    return this.on(e, sc(this, e, t)), this;
}, rc.prototype.prependOnceListener = function(e, t) {
    if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
    return this.prependListener(e, sc(this, e, t)), this;
}, rc.prototype.removeListener = function(e, t) {
    var n, r, i, o, s;
    if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
    if (!(r = this._events)) return this;
    if (!(n = r[e])) return this;
    if (n === t || n.listener && n.listener === t) 0 == --this._eventsCount ? this._events = new nc : (delete r[e], r.removeListener && this.emit("removeListener", e, n.listener || t));
    else if ("function" != typeof n) {
        for(i = -1, o = n.length; o-- > 0;)if (n[o] === t || n[o].listener && n[o].listener === t) {
            s = n[o].listener, i = o;
            break;
        }
        if (i < 0) return this;
        if (1 === n.length) {
            if (n[0] = void 0, 0 == --this._eventsCount) return this._events = new nc, this;
            delete r[e];
        } else !function(e, t) {
            for(var n = t, r = n + 1, i = e.length; r < i; n += 1, r += 1)e[n] = e[r];
            e.pop();
        }(n, i);
        r.removeListener && this.emit("removeListener", e, s || t);
    }
    return this;
}, rc.prototype.off = function(e, t) {
    return this.removeListener(e, t);
}, rc.prototype.removeAllListeners = function(e) {
    var t, n;
    if (!(n = this._events)) return this;
    if (!n.removeListener) return 0 === arguments.length ? (this._events = new nc, this._eventsCount = 0) : n[e] && (0 == --this._eventsCount ? this._events = new nc : delete n[e]), this;
    if (0 === arguments.length) {
        for(var r, i = Object.keys(n), o = 0; o < i.length; ++o)"removeListener" !== (r = i[o]) && this.removeAllListeners(r);
        return this.removeAllListeners("removeListener"), this._events = new nc, this._eventsCount = 0, this;
    }
    if ("function" == typeof (t = n[e])) this.removeListener(e, t);
    else if (t) do {
        this.removeListener(e, t[t.length - 1]);
    }while (t[0])
    return this;
}, rc.prototype.listeners = function(e) {
    var t, n, r = this._events;
    return n = r && (t = r[e]) ? "function" == typeof t ? [
        t.listener || t
    ] : function(e) {
        for(var t = new Array(e.length), n = 0; n < t.length; ++n)t[n] = e[n].listener || e[n];
        return t;
    }(t) : [], n;
}, rc.listenerCount = function(e, t) {
    return "function" == typeof e.listenerCount ? e.listenerCount(t) : ac.call(e, t);
}, rc.prototype.listenerCount = ac, rc.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
var lc = he(Object.freeze({
    __proto__: null,
    EventEmitter: rc,
    default: rc
}));
Object.defineProperty(tc, "__esModule", {
    value: !0
});
const dc = lc;
function uc(e, t, n) {
    try {
        Reflect.apply(e, t, n);
    } catch (e) {
        setTimeout(()=>{
            throw e;
        });
    }
}
let hc = class extends dc.EventEmitter {
    emit(e, ...t) {
        let n = "error" === e;
        const r = this._events;
        if (void 0 !== r) n = n && void 0 === r.error;
        else if (!n) return !1;
        if (n) {
            let e;
            if (t.length > 0 && ([e] = t), e instanceof Error) throw e;
            const n = new Error("Unhandled error." + (e ? ` (${e.message})` : ""));
            throw n.context = e, n;
        }
        const i = r[e];
        if (void 0 === i) return !1;
        if ("function" == typeof i) uc(i, this, t);
        else {
            const e = i.length, n = function(e) {
                const t = e.length, n = new Array(t);
                for(let r = 0; r < t; r += 1)n[r] = e[r];
                return n;
            }(i);
            for(let r = 0; r < e; r += 1)uc(n[r], this, t);
        }
        return !0;
    }
};
var fc, pc, gc, mc, yc, vc, bc, wc, Ec, Sc, _c, Cc, kc, Ac, xc, Mc, Ic, Tc, Rc, Pc = tc.default = hc, Oc = class e extends Pc {
    constructor({ notificationHandler: e } = {}){
        super(), us(this, mc), us(this, vc), us(this, wc), us(this, fc, !1), us(this, pc, void 0), us(this, gc, void 0), hs(this, pc, []), hs(this, gc, e);
    }
    destroy() {
        ds(this, pc).forEach((e)=>{
            "destroy" in e && "function" == typeof e.destroy && e.destroy();
        }), hs(this, pc, []), hs(this, fc, !0);
    }
    push(e) {
        fs(this, mc, yc).call(this), ds(this, pc).push(e);
    }
    handle(e, t) {
        if (fs(this, mc, yc).call(this), t && "function" != typeof t) throw new Error('"callback" must be a function if provided.');
        return Array.isArray(e) ? t ? fs(this, vc, bc).call(this, e, t) : fs(this, vc, bc).call(this, e) : t ? fs(this, wc, Ec).call(this, e, t) : this._promiseHandle(e);
    }
    asMiddleware() {
        return fs(this, mc, yc).call(this), async (t, n, r, i)=>{
            var o, s;
            try {
                const [a, c, l] = await fs(o = e, Cc, kc).call(o, t, n, ds(this, pc));
                return c ? (await fs(s = e, Mc, Ic).call(s, l), i(a)) : r(async (t)=>{
                    var n;
                    try {
                        await fs(n = e, Mc, Ic).call(n, l);
                    } catch (e) {
                        return t(e);
                    }
                    return t();
                });
            } catch (e) {
                return i(e);
            }
        };
    }
    async _promiseHandle(e) {
        return new Promise((t, n)=>{
            fs(this, wc, Ec).call(this, e, (e, r)=>{
                e && void 0 === r ? n(e) : t(r);
            }).catch(n);
        });
    }
};
fc = new WeakMap, pc = new WeakMap, gc = new WeakMap, mc = new WeakSet, yc = function() {
    if (ds(this, fc)) throw new Error("This engine is destroyed and can no longer be used.");
}, vc = new WeakSet, bc = async function(e, t) {
    try {
        if (0 === e.length) {
            const e = [
                {
                    id: null,
                    jsonrpc: "2.0",
                    error: new Ja(ps.invalidRequest, "Request batch must contain plain objects. Received an empty array")
                }
            ];
            return t ? t(null, e) : e;
        }
        const n = (await Promise.all(e.map(this._promiseHandle.bind(this)))).filter((e)=>void 0 !== e);
        return t ? t(null, n) : n;
    } catch (e) {
        if (t) return t(e);
        throw e;
    }
}, wc = new WeakSet, Ec = async function(e, t) {
    var n;
    if (!e || Array.isArray(e) || "object" != typeof e) {
        const n = new Ja(ps.invalidRequest, "Requests must be plain objects. Received: " + typeof e, {
            request: e
        });
        return t(n, {
            id: null,
            jsonrpc: "2.0",
            error: n
        });
    }
    if ("string" != typeof e.method) {
        const n = new Ja(ps.invalidRequest, "Must specify a string method. Received: " + typeof e.method, {
            request: e
        });
        return ds(this, gc) && !xa(e) ? t(null) : t(n, {
            id: e.id ?? null,
            jsonrpc: "2.0",
            error: n
        });
    }
    if (ds(this, gc) && xs(e, Aa) && !xa(e)) {
        try {
            await ds(this, gc).call(this, e);
        } catch (e) {
            return t(e);
        }
        return t(null);
    }
    let r = null;
    const i = {
        ...e
    }, o = {
        id: i.id,
        jsonrpc: i.jsonrpc
    };
    try {
        await fs(n = Oc, Sc, _c).call(n, i, o, ds(this, pc));
    } catch (e) {
        r = e;
    }
    return r && (delete o.result, o.error || (o.error = Na(r))), t(r, o);
}, Sc = new WeakSet, _c = async function(e, t, n) {
    var r, i, o;
    const [s, a, c] = await fs(r = Oc, Cc, kc).call(r, e, t, n);
    if (fs(i = Oc, Tc, Rc).call(i, e, t, a), await fs(o = Oc, Mc, Ic).call(o, c), s) throw s;
}, Cc = new WeakSet, kc = async function(e, t, n) {
    var r;
    const i = [];
    let o = null, s = !1;
    for (const a of n)if ([o, s] = await fs(r = Oc, Ac, xc).call(r, e, t, a, i), s) break;
    return [
        o,
        s,
        i.reverse()
    ];
}, Ac = new WeakSet, xc = async function(e, t, n, r) {
    return new Promise((i)=>{
        const o = (e)=>{
            const n = e || t.error;
            n && (t.error = Na(n)), i([
                n,
                !0
            ]);
        }, s = (n)=>{
            t.error ? o(t.error) : (n && ("function" != typeof n && o(new Ja(ps.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof n}" for request:\n${Lc(e)}`, {
                request: e
            })), r.push(n)), i([
                null,
                !1
            ]));
        };
        try {
            n(e, t, s, o);
        } catch (e) {
            o(e);
        }
    });
}, Mc = new WeakSet, Ic = async function(e) {
    for (const t of e)await new Promise((e, n)=>{
        t((t)=>t ? n(t) : e());
    });
}, Tc = new WeakSet, Rc = function(e, t, n) {
    if (!ys(t, "result") && !ys(t, "error")) throw new Ja(ps.internal, `JsonRpcEngine: Response has no error or result for request:\n${Lc(e)}`, {
        request: e
    });
    if (!n) throw new Ja(ps.internal, `JsonRpcEngine: Nothing ended request:\n${Lc(e)}`, {
        request: e
    });
}, us(Oc, Sc), us(Oc, Cc), us(Oc, Ac), us(Oc, Mc), us(Oc, Tc);
var Nc = Oc;
function Lc(e) {
    return JSON.stringify(e, null, 2);
}
var Dc = Object.freeze([
    "eth_subscription"
]), $c = (e = console)=>[
        cs(),
        Bc(e),
        os(e)
    ];
function Bc(e) {
    return (t, n, r)=>{
        "string" == typeof t.method && t.method || (n.error = Xa({
            message: "The request 'method' must be a non-empty string.",
            data: t
        })), r((t)=>{
            const { error: r } = n;
            return r ? (e.error(`MetaMask - RPC Error: ${r.message}`, r), t()) : t();
        });
    };
}
var Kc = (e, t, n = !0)=>(r, i)=>{
        r || i.error ? t(r || i.error) : !n || Array.isArray(i) ? e(i) : e(i.result);
    }, jc = (e)=>Boolean(e) && "string" == typeof e && e.startsWith("0x"), Uc = ()=>{};
async function Hc(e, t) {
    try {
        const t = await async function() {
            return {
                name: Fc(window),
                icon: await zc(window)
            };
        }();
        e.handle({
            jsonrpc: "2.0",
            id: 1,
            method: "metamask_sendDomainMetadata",
            params: t
        }, Uc);
    } catch (e) {
        t.error({
            message: is.errors.sendSiteMetadata(),
            originalError: e
        });
    }
}
function Fc(e) {
    const { document: t } = e, n = t.querySelector('head > meta[property="og:site_name"]');
    if (n) return n.content;
    const r = t.querySelector('head > meta[name="title"]');
    return r ? r.content : t.title && t.title.length > 0 ? t.title : window.location.hostname;
}
async function zc(e) {
    const { document: t } = e, n = t.querySelectorAll('head > link[rel~="icon"]');
    for (const e of Array.from(n))if (e && await qc(e.href)) return e.href;
    return null;
}
async function qc(e) {
    return new Promise((t, n)=>{
        try {
            const n = document.createElement("img");
            n.onload = ()=>t(!0), n.onerror = ()=>t(!1), n.src = e;
        } catch (e) {
            n(e);
        }
    });
}
var Wc = (e, t, n)=>{
    if (!t.has(e)) throw TypeError("Cannot " + n);
}, Vc = (e, t, n)=>(Wc(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Gc = (e, t, n)=>{
    if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, Yc = (e, t, n, r)=>(Wc(e, t, "write to private field"), t.set(e, n), n);
function Zc(e, t, n) {
    try {
        Reflect.apply(e, t, n);
    } catch (e) {
        setTimeout(()=>{
            throw e;
        });
    }
}
class Jc extends rc {
    emit(e, ...t) {
        let n = "error" === e;
        const r = this._events;
        if (void 0 !== r) n = n && void 0 === r.error;
        else if (!n) return !1;
        if (n) {
            let e;
            if (t.length > 0 && ([e] = t), e instanceof Error) throw e;
            const n = new Error("Unhandled error." + (e ? ` (${e.message})` : ""));
            throw n.context = e, n;
        }
        const i = r[e];
        if (void 0 === i) return !1;
        if ("function" == typeof i) Zc(i, this, t);
        else {
            const e = i.length, n = function(e) {
                const t = e.length, n = new Array(t);
                for(let r = 0; r < t; r += 1)n[r] = e[r];
                return n;
            }(i);
            for(let r = 0; r < e; r += 1)Zc(n[r], this, t);
        }
        return !0;
    }
}
var Qc, Xc, el = function e(t, n) {
    if (t === n) return !0;
    if (t && n && "object" == typeof t && "object" == typeof n) {
        if (t.constructor !== n.constructor) return !1;
        var r, i, o;
        if (Array.isArray(t)) {
            if ((r = t.length) != n.length) return !1;
            for(i = r; 0 != i--;)if (!e(t[i], n[i])) return !1;
            return !0;
        }
        if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
        if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
        if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
        if ((r = (o = Object.keys(t)).length) !== Object.keys(n).length) return !1;
        for(i = r; 0 != i--;)if (!Object.prototype.hasOwnProperty.call(n, o[i])) return !1;
        for(i = r; 0 != i--;){
            var s = o[i];
            if (!e(t[s], n[s])) return !1;
        }
        return !0;
    }
    return t != t && n != n;
}, tl = ue(el), nl = class e extends Jc {
    constructor({ logger: t = console, maxEventListeners: n = 100, rpcMiddleware: r = [] } = {}){
        super(), Gc(this, Qc, void 0), Gc(this, Xc, void 0), this._log = t, this.setMaxListeners(n), this._state = {
            ...e._defaultState
        }, Yc(this, Xc, null), Yc(this, Qc, null), this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
        const i = new Nc;
        r.forEach((e)=>i.push(e)), this._rpcEngine = i;
    }
    get chainId() {
        return Vc(this, Qc);
    }
    get selectedAddress() {
        return Vc(this, Xc);
    }
    isConnected() {
        return this._state.isConnected;
    }
    async request(e) {
        if (!e || "object" != typeof e || Array.isArray(e)) throw Xa({
            message: is.errors.invalidRequestArgs(),
            data: e
        });
        const { method: t, params: n } = e;
        if ("string" != typeof t || 0 === t.length) throw Xa({
            message: is.errors.invalidRequestMethod(),
            data: e
        });
        if (void 0 !== n && !Array.isArray(n) && ("object" != typeof n || null === n)) throw Xa({
            message: is.errors.invalidRequestParams(),
            data: e
        });
        const r = null == n ? {
            method: t
        } : {
            method: t,
            params: n
        };
        return new Promise((e, t)=>{
            this._rpcRequest(r, Kc(e, t));
        });
    }
    _initializeState(e) {
        if (this._state.initialized) throw new Error("Provider already initialized.");
        if (e) {
            const { accounts: t, chainId: n, isUnlocked: r, networkVersion: i } = e;
            this._handleConnect(n), this._handleChainChanged({
                chainId: n,
                networkVersion: i
            }), this._handleUnlockStateChanged({
                accounts: t,
                isUnlocked: r
            }), this._handleAccountsChanged(t);
        }
        this._state.initialized = !0, this.emit("_initialized");
    }
    _rpcRequest(e, t) {
        let n = t;
        return Array.isArray(e) || (e.jsonrpc || (e.jsonrpc = "2.0"), "eth_accounts" !== e.method && "eth_requestAccounts" !== e.method || (n = (n, r)=>{
            this._handleAccountsChanged(r.result ?? [], "eth_accounts" === e.method), t(n, r);
        })), this._rpcEngine.handle(e, n);
    }
    _handleConnect(e) {
        this._state.isConnected || (this._state.isConnected = !0, this.emit("connect", {
            chainId: e
        }), this._log.debug(is.info.connected(e)));
    }
    _handleDisconnect(e, t) {
        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !e) {
            let n;
            this._state.isConnected = !1, e ? (n = new Ja(1013, t ?? is.errors.disconnected()), this._log.debug(n)) : (n = new Ja(1011, t ?? is.errors.permanentlyDisconnected()), this._log.error(n), Yc(this, Qc, null), this._state.accounts = null, Yc(this, Xc, null), this._state.isUnlocked = !1, this._state.isPermanentlyDisconnected = !0), this.emit("disconnect", n);
        }
    }
    _handleChainChanged({ chainId: e } = {}) {
        jc(e) ? (this._handleConnect(e), e !== Vc(this, Qc) && (Yc(this, Qc, e), this._state.initialized && this.emit("chainChanged", Vc(this, Qc)))) : this._log.error(is.errors.invalidNetworkParams(), {
            chainId: e
        });
    }
    _handleAccountsChanged(e, t = !1) {
        let n = e;
        Array.isArray(e) || (this._log.error("MetaMask: Received invalid accounts parameter. Please report this bug.", e), n = []);
        for (const t of e)if ("string" != typeof t) {
            this._log.error("MetaMask: Received non-string account. Please report this bug.", e), n = [];
            break;
        }
        if (!tl(this._state.accounts, n) && (t && null !== this._state.accounts && this._log.error("MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.", n), this._state.accounts = n, Vc(this, Xc) !== n[0] && Yc(this, Xc, n[0] || null), this._state.initialized)) {
            const e = [
                ...n
            ];
            this.emit("accountsChanged", e);
        }
    }
    _handleUnlockStateChanged({ accounts: e, isUnlocked: t } = {}) {
        "boolean" == typeof t ? t !== this._state.isUnlocked && (this._state.isUnlocked = t, this._handleAccountsChanged(e ?? [])) : this._log.error("MetaMask: Received invalid isUnlocked parameter. Please report this bug.");
    }
};
Qc = new WeakMap, Xc = new WeakMap, nl._defaultState = {
    accounts: null,
    isConnected: !1,
    isUnlocked: !1,
    initialized: !1,
    isPermanentlyDisconnected: !1
};
var rl, il = nl, ol = {
    exports: {}
}, sl = lc.EventEmitter, al = he(le);
rl = "function" == typeof Object.create ? function(e, t) {
    e.super_ = t, e.prototype = Object.create(t.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    });
} : function(e, t) {
    e.super_ = t;
    var n = function() {};
    n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
};
var cl = Object.getOwnPropertyDescriptors || function(e) {
    for(var t = Object.keys(e), n = {}, r = 0; r < t.length; r++)n[t[r]] = Object.getOwnPropertyDescriptor(e, t[r]);
    return n;
}, ll = /%[sdj%]/g;
function dl(e) {
    if (!Al(e)) {
        for(var t = [], n = 0; n < arguments.length; n++)t.push(gl(arguments[n]));
        return t.join(" ");
    }
    n = 1;
    for(var r = arguments, i = r.length, o = String(e).replace(ll, function(e) {
        if ("%%" === e) return "%";
        if (n >= i) return e;
        switch(e){
            case "%s":
                return String(r[n++]);
            case "%d":
                return Number(r[n++]);
            case "%j":
                try {
                    return JSON.stringify(r[n++]);
                } catch (e) {
                    return "[Circular]";
                }
            default:
                return e;
        }
    }), s = r[n]; n < i; s = r[++n])_l(s) || !Tl(s) ? o += " " + s : o += " " + gl(s);
    return o;
}
function ul(e, t) {
    if (Ml(l.process)) return function() {
        return ul(e, t).apply(this, arguments);
    };
    if (!0 === ua.noDeprecation) return e;
    var n = !1;
    return function() {
        if (!n) {
            if (ua.throwDeprecation) throw new Error(t);
            ua.traceDeprecation ? console.trace(t) : console.error(t), n = !0;
        }
        return e.apply(this, arguments);
    };
}
var hl, fl = {};
function pl(e) {
    if (Ml(hl) && (hl = ua.env.NODE_DEBUG || ""), e = e.toUpperCase(), !fl[e]) if (new RegExp("\\b" + e + "\\b", "i").test(hl)) {
        fl[e] = function() {
            var t = dl.apply(null, arguments);
            console.error("%s %d: %s", e, 0, t);
        };
    } else fl[e] = function() {};
    return fl[e];
}
function gl(e, t) {
    var n = {
        seen: [],
        stylize: yl
    };
    return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), Sl(t) ? n.showHidden = t : t && jl(n, t), Ml(n.showHidden) && (n.showHidden = !1), Ml(n.depth) && (n.depth = 2), Ml(n.colors) && (n.colors = !1), Ml(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = ml), vl(n, e, n.depth);
}
function ml(e, t) {
    var n = gl.styles[t];
    return n ? "[" + gl.colors[n][0] + "m" + e + "[" + gl.colors[n][1] + "m" : e;
}
function yl(e, t) {
    return e;
}
function vl(e, t, n) {
    if (e.customInspect && t && Ol(t.inspect) && t.inspect !== gl && (!t.constructor || t.constructor.prototype !== t)) {
        var r = t.inspect(n, e);
        return Al(r) || (r = vl(e, r, n)), r;
    }
    var i = function(e, t) {
        if (Ml(t)) return e.stylize("undefined", "undefined");
        if (Al(t)) {
            var n = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e.stylize(n, "string");
        }
        if (kl(t)) return e.stylize("" + t, "number");
        if (Sl(t)) return e.stylize("" + t, "boolean");
        if (_l(t)) return e.stylize("null", "null");
    }(e, t);
    if (i) return i;
    var o = Object.keys(t), s = function(e) {
        var t = {};
        return e.forEach(function(e, n) {
            t[e] = !0;
        }), t;
    }(o);
    if (e.showHidden && (o = Object.getOwnPropertyNames(t)), Pl(t) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return bl(t);
    if (0 === o.length) {
        if (Ol(t)) {
            var a = t.name ? ": " + t.name : "";
            return e.stylize("[Function" + a + "]", "special");
        }
        if (Il(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp");
        if (Rl(t)) return e.stylize(Date.prototype.toString.call(t), "date");
        if (Pl(t)) return bl(t);
    }
    var c, l = "", d = !1, u = [
        "{",
        "}"
    ];
    (El(t) && (d = !0, u = [
        "[",
        "]"
    ]), Ol(t)) && (l = " [Function" + (t.name ? ": " + t.name : "") + "]");
    return Il(t) && (l = " " + RegExp.prototype.toString.call(t)), Rl(t) && (l = " " + Date.prototype.toUTCString.call(t)), Pl(t) && (l = " " + bl(t)), 0 !== o.length || d && 0 != t.length ? n < 0 ? Il(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), c = d ? function(e, t, n, r, i) {
        for(var o = [], s = 0, a = t.length; s < a; ++s)Ul(t, String(s)) ? o.push(wl(e, t, n, r, String(s), !0)) : o.push("");
        return i.forEach(function(i) {
            i.match(/^\d+$/) || o.push(wl(e, t, n, r, i, !0));
        }), o;
    }(e, t, n, s, o) : o.map(function(r) {
        return wl(e, t, n, s, r, d);
    }), e.seen.pop(), function(e, t, n) {
        var r = e.reduce(function(e, t) {
            return t.indexOf("\n"), e + t.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (r > 60) return n[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + n[1];
        return n[0] + t + " " + e.join(", ") + " " + n[1];
    }(c, l, u)) : u[0] + l + u[1];
}
function bl(e) {
    return "[" + Error.prototype.toString.call(e) + "]";
}
function wl(e, t, n, r, i, o) {
    var s, a, c;
    if ((c = Object.getOwnPropertyDescriptor(t, i) || {
        value: t[i]
    }).get ? a = c.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : c.set && (a = e.stylize("[Setter]", "special")), Ul(r, i) || (s = "[" + i + "]"), a || (e.seen.indexOf(c.value) < 0 ? (a = _l(n) ? vl(e, c.value, null) : vl(e, c.value, n - 1)).indexOf("\n") > -1 && (a = o ? a.split("\n").map(function(e) {
        return "  " + e;
    }).join("\n").substr(2) : "\n" + a.split("\n").map(function(e) {
        return "   " + e;
    }).join("\n")) : a = e.stylize("[Circular]", "special")), Ml(s)) {
        if (o && i.match(/^\d+$/)) return a;
        (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"));
    }
    return s + ": " + a;
}
function El(e) {
    return Array.isArray(e);
}
function Sl(e) {
    return "boolean" == typeof e;
}
function _l(e) {
    return null === e;
}
function Cl(e) {
    return null == e;
}
function kl(e) {
    return "number" == typeof e;
}
function Al(e) {
    return "string" == typeof e;
}
function xl(e) {
    return "symbol" == typeof e;
}
function Ml(e) {
    return void 0 === e;
}
function Il(e) {
    return Tl(e) && "[object RegExp]" === Dl(e);
}
function Tl(e) {
    return "object" == typeof e && null !== e;
}
function Rl(e) {
    return Tl(e) && "[object Date]" === Dl(e);
}
function Pl(e) {
    return Tl(e) && ("[object Error]" === Dl(e) || e instanceof Error);
}
function Ol(e) {
    return "function" == typeof e;
}
function Nl(e) {
    return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e;
}
function Ll(e) {
    return C.isBuffer(e);
}
function Dl(e) {
    return Object.prototype.toString.call(e);
}
function $l(e) {
    return e < 10 ? "0" + e.toString(10) : e.toString(10);
}
gl.colors = {
    bold: [
        1,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    inverse: [
        7,
        27
    ],
    white: [
        37,
        39
    ],
    grey: [
        90,
        39
    ],
    black: [
        30,
        39
    ],
    blue: [
        34,
        39
    ],
    cyan: [
        36,
        39
    ],
    green: [
        32,
        39
    ],
    magenta: [
        35,
        39
    ],
    red: [
        31,
        39
    ],
    yellow: [
        33,
        39
    ]
}, gl.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    regexp: "red"
};
var Bl = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
function Kl() {
    var e, t;
    console.log("%s - %s", (e = new Date, t = [
        $l(e.getHours()),
        $l(e.getMinutes()),
        $l(e.getSeconds())
    ].join(":"), [
        e.getDate(),
        Bl[e.getMonth()],
        t
    ].join(" ")), dl.apply(null, arguments));
}
function jl(e, t) {
    if (!t || !Tl(t)) return e;
    for(var n = Object.keys(t), r = n.length; r--;)e[n[r]] = t[n[r]];
    return e;
}
function Ul(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
}
var Hl = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
function Fl(e) {
    if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function');
    if (Hl && e[Hl]) {
        var t;
        if ("function" != typeof (t = e[Hl])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t, Hl, {
            value: t,
            enumerable: !1,
            writable: !1,
            configurable: !0
        }), t;
    }
    function t() {
        for(var t, n, r = new Promise(function(e, r) {
            t = e, n = r;
        }), i = [], o = 0; o < arguments.length; o++)i.push(arguments[o]);
        i.push(function(e, r) {
            e ? n(e) : t(r);
        });
        try {
            e.apply(this, i);
        } catch (e) {
            n(e);
        }
        return r;
    }
    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Hl && Object.defineProperty(t, Hl, {
        value: t,
        enumerable: !1,
        writable: !1,
        configurable: !0
    }), Object.defineProperties(t, cl(e));
}
function zl(e, t) {
    if (!e) {
        var n = new Error("Promise was rejected with a falsy value");
        n.reason = e, e = n;
    }
    return t(e);
}
function ql(e) {
    if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function');
    function t() {
        for(var t = [], n = 0; n < arguments.length; n++)t.push(arguments[n]);
        var r = t.pop();
        if ("function" != typeof r) throw new TypeError("The last argument must be of type Function");
        var i = this, o = function() {
            return r.apply(i, arguments);
        };
        e.apply(this, t).then(function(e) {
            ua.nextTick(o.bind(null, null, e));
        }, function(e) {
            ua.nextTick(zl.bind(null, e, o));
        });
    }
    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperties(t, cl(e)), t;
}
Fl.custom = Hl;
var Wl, Vl, Gl = {
    inherits: rl,
    _extend: jl,
    log: Kl,
    isBuffer: Ll,
    isPrimitive: Nl,
    isFunction: Ol,
    isError: Pl,
    isDate: Rl,
    isObject: Tl,
    isRegExp: Il,
    isUndefined: Ml,
    isSymbol: xl,
    isString: Al,
    isNumber: kl,
    isNullOrUndefined: Cl,
    isNull: _l,
    isBoolean: Sl,
    isArray: El,
    inspect: gl,
    deprecate: ul,
    format: dl,
    debuglog: pl,
    promisify: Fl,
    callbackify: ql
}, Yl = he(Object.freeze({
    __proto__: null,
    _extend: jl,
    callbackify: ql,
    debuglog: pl,
    default: Gl,
    deprecate: ul,
    format: dl,
    inherits: rl,
    inspect: gl,
    isArray: El,
    isBoolean: Sl,
    isBuffer: Ll,
    isDate: Rl,
    isError: Pl,
    isFunction: Ol,
    isNull: _l,
    isNullOrUndefined: Cl,
    isNumber: kl,
    isObject: Tl,
    isPrimitive: Nl,
    isRegExp: Il,
    isString: Al,
    isSymbol: xl,
    isUndefined: Ml,
    log: Kl,
    promisify: Fl
}));
function Zl() {
    if (Vl) return Wl;
    function e(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter(function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function t(t) {
        for(var r = 1; r < arguments.length; r++){
            var i = null != arguments[r] ? arguments[r] : {};
            r % 2 ? e(Object(i), !0).forEach(function(e) {
                n(t, e, i[e]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : e(Object(i)).forEach(function(e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));
            });
        }
        return t;
    }
    function n(e, t, n) {
        return (t = i(t)) in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e;
    }
    function r(e, t, n) {
        return t && function(e, t) {
            for(var n = 0; n < t.length; n++){
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, i(r.key), r);
            }
        }(e.prototype, t), Object.defineProperty(e, "prototype", {
            writable: !1
        }), e;
    }
    function i(e) {
        var t = function(e, t) {
            if ("object" != typeof e || null === e) return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t || "default");
                if ("object" != typeof r) return r;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (("TURBOPACK compile-time truthy", 1) ? String : "TURBOPACK unreachable")(e);
        }(e, "string");
        return "symbol" == typeof t ? t : String(t);
    }
    Vl = 1;
    var o = al.Buffer, s = Yl.inspect, a = s && s.custom || "inspect";
    return Wl = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
            }(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return r(e, [
            {
                key: "push",
                value: function(e) {
                    var t = {
                        data: e,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length;
                }
            },
            {
                key: "unshift",
                value: function(e) {
                    var t = {
                        data: e,
                        next: this.head
                    };
                    0 === this.length && (this.tail = t), this.head = t, ++this.length;
                }
            },
            {
                key: "shift",
                value: function() {
                    if (0 !== this.length) {
                        var e = this.head.data;
                        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
                    }
                }
            },
            {
                key: "clear",
                value: function() {
                    this.head = this.tail = null, this.length = 0;
                }
            },
            {
                key: "join",
                value: function(e) {
                    if (0 === this.length) return "";
                    for(var t = this.head, n = "" + t.data; t = t.next;)n += e + t.data;
                    return n;
                }
            },
            {
                key: "concat",
                value: function(e) {
                    if (0 === this.length) return o.alloc(0);
                    for(var t, n, r, i = o.allocUnsafe(e >>> 0), s = this.head, a = 0; s;)t = s.data, n = i, r = a, o.prototype.copy.call(t, n, r), a += s.data.length, s = s.next;
                    return i;
                }
            },
            {
                key: "consume",
                value: function(e, t) {
                    var n;
                    return e < this.head.data.length ? (n = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : n = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), n;
                }
            },
            {
                key: "first",
                value: function() {
                    return this.head.data;
                }
            },
            {
                key: "_getString",
                value: function(e) {
                    var t = this.head, n = 1, r = t.data;
                    for(e -= r.length; t = t.next;){
                        var i = t.data, o = e > i.length ? i.length : e;
                        if (o === i.length ? r += i : r += i.slice(0, e), 0 === (e -= o)) {
                            o === i.length ? (++n, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(o));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, r;
                }
            },
            {
                key: "_getBuffer",
                value: function(e) {
                    var t = o.allocUnsafe(e), n = this.head, r = 1;
                    for(n.data.copy(t), e -= n.data.length; n = n.next;){
                        var i = n.data, s = e > i.length ? i.length : e;
                        if (i.copy(t, t.length - e, 0, s), 0 === (e -= s)) {
                            s === i.length ? (++r, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = i.slice(s));
                            break;
                        }
                        ++r;
                    }
                    return this.length -= r, t;
                }
            },
            {
                key: a,
                value: function(e, n) {
                    return s(this, t(t({}, n), {}, {
                        depth: 0,
                        customInspect: !1
                    }));
                }
            }
        ]), e;
    }(), Wl;
}
function Jl(e, t) {
    Xl(e, t), Ql(e);
}
function Ql(e) {
    e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function Xl(e, t) {
    e.emit("error", t);
}
var ed = {
    destroy: function(e, t) {
        var n = this, r = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
        return r || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, ua.nextTick(Xl, this, e)) : ua.nextTick(Xl, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(e) {
            !t && e ? n._writableState ? n._writableState.errorEmitted ? ua.nextTick(Ql, n) : (n._writableState.errorEmitted = !0, ua.nextTick(Jl, n, e)) : ua.nextTick(Jl, n, e) : t ? (ua.nextTick(Ql, n), t(e)) : ua.nextTick(Ql, n);
        }), this);
    },
    undestroy: function() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    },
    errorOrDestroy: function(e, t) {
        var n = e._readableState, r = e._writableState;
        n && n.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
}, td = {};
var nd = {};
function rd(e, t, n) {
    n || (n = Error);
    var r = function(e) {
        var n, r;
        function i(n, r, i) {
            return e.call(this, function(e, n, r) {
                return "string" == typeof t ? t : t(e, n, r);
            }(n, r, i)) || this;
        }
        return r = e, (n = i).prototype = Object.create(r.prototype), n.prototype.constructor = n, n.__proto__ = r, i;
    }(n);
    r.prototype.name = n.name, r.prototype.code = e, nd[e] = r;
}
function id(e, t) {
    if (Array.isArray(e)) {
        var n = e.length;
        return e = e.map(function(e) {
            return String(e);
        }), n > 2 ? "one of ".concat(t, " ").concat(e.slice(0, n - 1).join(", "), ", or ") + e[n - 1] : 2 === n ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
    }
    return "of ".concat(t, " ").concat(String(e));
}
rd("ERR_INVALID_OPT_VALUE", function(e, t) {
    return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError), rd("ERR_INVALID_ARG_TYPE", function(e, t, n) {
    var r, i, o;
    if ("string" == typeof t && (i = "not ", t.substr(0, i.length) === i) ? (r = "must not be", t = t.replace(/^not /, "")) : r = "must be", function(e, t, n) {
        return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t;
    }(e, " argument")) o = "The ".concat(e, " ").concat(r, " ").concat(id(t, "type"));
    else {
        var s = function(e, t, n) {
            return "number" != typeof n && (n = 0), !(n + t.length > e.length) && -1 !== e.indexOf(t, n);
        }(e, ".") ? "property" : "argument";
        o = 'The "'.concat(e, '" ').concat(s, " ").concat(r, " ").concat(id(t, "type"));
    }
    return o += ". Received type ".concat(typeof n);
}, TypeError), rd("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), rd("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
    return "The " + e + " method is not implemented";
}), rd("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), rd("ERR_STREAM_DESTROYED", function(e) {
    return "Cannot call " + e + " after a stream was destroyed";
}), rd("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), rd("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), rd("ERR_STREAM_WRITE_AFTER_END", "write after end"), rd("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), rd("ERR_UNKNOWN_ENCODING", function(e) {
    return "Unknown encoding: " + e;
}, TypeError), rd("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), td.codes = nd;
var od = td.codes.ERR_INVALID_OPT_VALUE;
var sd, ad, cd, ld, dd = {
    getHighWaterMark: function(e, t, n, r) {
        var i = function(e, t, n) {
            return null != e.highWaterMark ? e.highWaterMark : t ? e[n] : null;
        }(t, r, n);
        if (null != i) {
            if (!isFinite(i) || Math.floor(i) !== i || i < 0) throw new od(r ? n : "highWaterMark", i);
            return Math.floor(i);
        }
        return e.objectMode ? 16 : 16384;
    }
}, ud = "function" == typeof Object.create ? function(e, t) {
    e.super_ = t, e.prototype = Object.create(t.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    });
} : function(e, t) {
    e.super_ = t;
    var n = function() {};
    n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
}, hd = he(Object.freeze({
    __proto__: null,
    default: ud
})), fd = function(e, t) {
    if (pd("noDeprecation")) return e;
    var n = !1;
    return function() {
        if (!n) {
            if (pd("throwDeprecation")) throw new Error(t);
            pd("traceDeprecation") ? console.trace(t) : console.warn(t), n = !0;
        }
        return e.apply(this, arguments);
    };
};
function pd(e) {
    try {
        if (!de.localStorage) return !1;
    } catch (e) {
        return !1;
    }
    var t = de.localStorage[e];
    return null != t && "true" === String(t).toLowerCase();
}
function gd() {
    if (ad) return sd;
    function e(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            !function(e, t, n) {
                var r = e.entry;
                e.entry = null;
                for(; r;){
                    var i = r.callback;
                    t.pendingcb--, i(n), r = r.next;
                }
                t.corkedRequestsFree.next = e;
            }(t, e);
        };
    }
    var t;
    ad = 1, sd = E, E.WritableState = w;
    var n = {
        deprecate: fd
    }, r = sl, i = al.Buffer, o = (void 0 !== de ? de : ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "undefined" != typeof self ? self : {}).Uint8Array || function() {};
    var s, a = ed, c = dd.getHighWaterMark, l = td.codes, d = l.ERR_INVALID_ARG_TYPE, u = l.ERR_METHOD_NOT_IMPLEMENTED, h = l.ERR_MULTIPLE_CALLBACK, f = l.ERR_STREAM_CANNOT_PIPE, p = l.ERR_STREAM_DESTROYED, g = l.ERR_STREAM_NULL_VALUES, m = l.ERR_STREAM_WRITE_AFTER_END, y = l.ERR_UNKNOWN_ENCODING, v = a.errorOrDestroy;
    function b() {}
    function w(n, r, i) {
        t = t || md(), n = n || {}, "boolean" != typeof i && (i = r instanceof t), this.objectMode = !!n.objectMode, i && (this.objectMode = this.objectMode || !!n.writableObjectMode), this.highWaterMark = c(this, n, "writableHighWaterMark", i), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var o = !1 === n.decodeStrings;
        this.decodeStrings = !o, this.defaultEncoding = n.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
            !function(e, t) {
                var n = e._writableState, r = n.sync, i = n.writecb;
                if ("function" != typeof i) throw new h;
                if (function(e) {
                    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
                }(n), t) !function(e, t, n, r, i) {
                    --t.pendingcb, n ? (ua.nextTick(i, r), ua.nextTick(x, e, t), e._writableState.errorEmitted = !0, v(e, r)) : (i(r), e._writableState.errorEmitted = !0, v(e, r), x(e, t));
                }(e, n, r, t, i);
                else {
                    var o = k(n) || e.destroyed;
                    o || n.corked || n.bufferProcessing || !n.bufferedRequest || C(e, n), r ? ua.nextTick(_, e, n, o, i) : _(e, n, o, i);
                }
            }(r, e);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== n.emitClose, this.autoDestroy = !!n.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
    }
    function E(e) {
        var n = this instanceof (t = t || md());
        if (!n && !s.call(E, this)) return new E(e);
        this._writableState = new w(e, this, n), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), r.call(this);
    }
    function S(e, t, n, r, i, o, s) {
        t.writelen = r, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new p("write")) : n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1;
    }
    function _(e, t, n, r) {
        n || function(e, t) {
            0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"));
        }(e, t), t.pendingcb--, r(), x(e, t);
    }
    function C(t, n) {
        n.bufferProcessing = !0;
        var r = n.bufferedRequest;
        if (t._writev && r && r.next) {
            var i = n.bufferedRequestCount, o = new Array(i), s = n.corkedRequestsFree;
            s.entry = r;
            for(var a = 0, c = !0; r;)o[a] = r, r.isBuf || (c = !1), r = r.next, a += 1;
            o.allBuffers = c, S(t, n, !0, n.length, o, "", s.finish), n.pendingcb++, n.lastBufferedRequest = null, s.next ? (n.corkedRequestsFree = s.next, s.next = null) : n.corkedRequestsFree = new e(n), n.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var l = r.chunk, d = r.encoding, u = r.callback;
                if (S(t, n, !1, n.objectMode ? 1 : l.length, l, d, u), r = r.next, n.bufferedRequestCount--, n.writing) break;
            }
            null === r && (n.lastBufferedRequest = null);
        }
        n.bufferedRequest = r, n.bufferProcessing = !1;
    }
    function k(e) {
        return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;
    }
    function A(e, t) {
        e._final(function(n) {
            t.pendingcb--, n && v(e, n), t.prefinished = !0, e.emit("prefinish"), x(e, t);
        });
    }
    function x(e, t) {
        var n = k(t);
        if (n && (function(e, t) {
            t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, ua.nextTick(A, e, t)));
        }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var r = e._readableState;
            (!r || r.autoDestroy && r.endEmitted) && e.destroy();
        }
        return n;
    }
    return hd(E, r), w.prototype.getBuffer = function() {
        for(var e = this.bufferedRequest, t = []; e;)t.push(e), e = e.next;
        return t;
    }, function() {
        try {
            Object.defineProperty(w.prototype, "buffer", {
                get: n.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e) {}
    }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (s = Function.prototype[Symbol.hasInstance], Object.defineProperty(E, Symbol.hasInstance, {
        value: function(e) {
            return !!s.call(this, e) || this === E && e && e._writableState instanceof w;
        }
    })) : s = function(e) {
        return e instanceof this;
    }, E.prototype.pipe = function() {
        v(this, new f);
    }, E.prototype.write = function(e, t, n) {
        var r, s = this._writableState, a = !1, c = !s.objectMode && (r = e, i.isBuffer(r) || r instanceof o);
        return c && !i.isBuffer(e) && (e = function(e) {
            return i.from(e);
        }(e)), "function" == typeof t && (n = t, t = null), c ? t = "buffer" : t || (t = s.defaultEncoding), "function" != typeof n && (n = b), s.ending ? function(e, t) {
            var n = new m;
            v(e, n), ua.nextTick(t, n);
        }(this, n) : (c || function(e, t, n, r) {
            var i;
            return null === n ? i = new g : "string" == typeof n || t.objectMode || (i = new d("chunk", [
                "string",
                "Buffer"
            ], n)), !i || (v(e, i), ua.nextTick(r, i), !1);
        }(this, s, e, n)) && (s.pendingcb++, a = function(e, t, n, r, o, s) {
            if (!n) {
                var a = function(e, t, n) {
                    e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = i.from(t, n));
                    return t;
                }(t, r, o);
                r !== a && (n = !0, o = "buffer", r = a);
            }
            var c = t.objectMode ? 1 : r.length;
            t.length += c;
            var l = t.length < t.highWaterMark;
            l || (t.needDrain = !0);
            if (t.writing || t.corked) {
                var d = t.lastBufferedRequest;
                t.lastBufferedRequest = {
                    chunk: r,
                    encoding: o,
                    isBuf: n,
                    callback: s,
                    next: null
                }, d ? d.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
            } else S(e, t, !1, c, r, o, s);
            return l;
        }(this, s, c, e, t, n)), a;
    }, E.prototype.cork = function() {
        this._writableState.corked++;
    }, E.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || C(this, e));
    }, E.prototype.setDefaultEncoding = function(e) {
        if ("string" == typeof e && (e = e.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((e + "").toLowerCase()) > -1)) throw new y(e);
        return this._writableState.defaultEncoding = e, this;
    }, Object.defineProperty(E.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    }), Object.defineProperty(E.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    }), E.prototype._write = function(e, t, n) {
        n(new u("_write()"));
    }, E.prototype._writev = null, E.prototype.end = function(e, t, n) {
        var r = this._writableState;
        return "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null != e && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || function(e, t, n) {
            t.ending = !0, x(e, t), n && (t.finished ? ua.nextTick(n) : e.once("finish", n));
            t.ended = !0, e.writable = !1;
        }(this, r, n), this;
    }, Object.defineProperty(E.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    }), Object.defineProperty(E.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return void 0 !== this._writableState && this._writableState.destroyed;
        },
        set: function(e) {
            this._writableState && (this._writableState.destroyed = e);
        }
    }), E.prototype.destroy = a.destroy, E.prototype._undestroy = a.undestroy, E.prototype._destroy = function(e, t) {
        t(e);
    }, sd;
}
function md() {
    if (ld) return cd;
    ld = 1;
    var e = Object.keys || function(e) {
        var t = [];
        for(var n in e)t.push(n);
        return t;
    };
    cd = s;
    var t = Od(), n = gd();
    hd(s, t);
    for(var r = e(n.prototype), i = 0; i < r.length; i++){
        var o = r[i];
        s.prototype[o] || (s.prototype[o] = n.prototype[o]);
    }
    function s(e) {
        if (!(this instanceof s)) return new s(e);
        t.call(this, e), n.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", a)));
    }
    function a() {
        this._writableState.ended || ua.nextTick(c, this);
    }
    function c(e) {
        e.end();
    }
    return Object.defineProperty(s.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    }), Object.defineProperty(s.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    }), Object.defineProperty(s.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    }), Object.defineProperty(s.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(e) {
            void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
        }
    }), cd;
}
var yd = C.isEncoding || function(e) {
    switch(e && e.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return !0;
        default:
            return !1;
    }
};
function vd(e) {
    switch(this.encoding = (e || "utf8").toLowerCase().replace(/[-_]/, ""), function(e) {
        if (e && !yd(e)) throw new Error("Unknown encoding: " + e);
    }(e), this.encoding){
        case "utf8":
            this.surrogateSize = 3;
            break;
        case "ucs2":
        case "utf16le":
            this.surrogateSize = 2, this.detectIncompleteChar = wd;
            break;
        case "base64":
            this.surrogateSize = 3, this.detectIncompleteChar = Ed;
            break;
        default:
            return void (this.write = bd);
    }
    this.charBuffer = new C(6), this.charReceived = 0, this.charLength = 0;
}
function bd(e) {
    return e.toString(this.encoding);
}
function wd(e) {
    this.charReceived = e.length % 2, this.charLength = this.charReceived ? 2 : 0;
}
function Ed(e) {
    this.charReceived = e.length % 3, this.charLength = this.charReceived ? 3 : 0;
}
vd.prototype.write = function(e) {
    for(var t = ""; this.charLength;){
        var n = e.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : e.length;
        if (e.copy(this.charBuffer, this.charReceived, 0, n), this.charReceived += n, this.charReceived < this.charLength) return "";
        if (e = e.slice(n, e.length), !((i = (t = this.charBuffer.slice(0, this.charLength).toString(this.encoding)).charCodeAt(t.length - 1)) >= 55296 && i <= 56319)) {
            if (this.charReceived = this.charLength = 0, 0 === e.length) return t;
            break;
        }
        this.charLength += this.surrogateSize, t = "";
    }
    this.detectIncompleteChar(e);
    var r = e.length;
    this.charLength && (e.copy(this.charBuffer, 0, e.length - this.charReceived, r), r -= this.charReceived);
    var i;
    r = (t += e.toString(this.encoding, 0, r)).length - 1;
    if ((i = t.charCodeAt(r)) >= 55296 && i <= 56319) {
        var o = this.surrogateSize;
        return this.charLength += o, this.charReceived += o, this.charBuffer.copy(this.charBuffer, o, 0, o), e.copy(this.charBuffer, 0, 0, o), t.substring(0, r);
    }
    return t;
}, vd.prototype.detectIncompleteChar = function(e) {
    for(var t = e.length >= 3 ? 3 : e.length; t > 0; t--){
        var n = e[e.length - t];
        if (1 == t && n >> 5 == 6) {
            this.charLength = 2;
            break;
        }
        if (t <= 2 && n >> 4 == 14) {
            this.charLength = 3;
            break;
        }
        if (t <= 3 && n >> 3 == 30) {
            this.charLength = 4;
            break;
        }
    }
    this.charReceived = t;
}, vd.prototype.end = function(e) {
    var t = "";
    if (e && e.length && (t = this.write(e)), this.charReceived) {
        var n = this.charReceived, r = this.charBuffer, i = this.encoding;
        t += r.slice(0, n).toString(i);
    }
    return t;
};
var Sd = he(Object.freeze({
    __proto__: null,
    StringDecoder: vd
})), _d = td.codes.ERR_STREAM_PREMATURE_CLOSE;
function Cd() {}
var kd, Ad, xd, Md, Id, Td, Rd = function e(t, n, r) {
    if ("function" == typeof n) return e(t, null, n);
    n || (n = {}), r = function(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for(var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i];
                e.apply(this, r);
            }
        };
    }(r || Cd);
    var i = n.readable || !1 !== n.readable && t.readable, o = n.writable || !1 !== n.writable && t.writable, s = function() {
        t.writable || c();
    }, a = t._writableState && t._writableState.finished, c = function() {
        o = !1, a = !0, i || r.call(t);
    }, l = t._readableState && t._readableState.endEmitted, d = function() {
        i = !1, l = !0, o || r.call(t);
    }, u = function(e) {
        r.call(t, e);
    }, h = function() {
        var e;
        return i && !l ? (t._readableState && t._readableState.ended || (e = new _d), r.call(t, e)) : o && !a ? (t._writableState && t._writableState.ended || (e = new _d), r.call(t, e)) : void 0;
    }, f = function() {
        t.req.on("finish", c);
    };
    return !function(e) {
        return e.setHeader && "function" == typeof e.abort;
    }(t) ? o && !t._writableState && (t.on("end", s), t.on("close", s)) : (t.on("complete", c), t.on("abort", h), t.req ? f() : t.on("request", f)), t.on("end", d), t.on("finish", c), !1 !== n.error && t.on("error", u), t.on("close", h), function() {
        t.removeListener("complete", c), t.removeListener("abort", h), t.removeListener("request", f), t.req && t.req.removeListener("finish", c), t.removeListener("end", s), t.removeListener("close", s), t.removeListener("finish", c), t.removeListener("end", d), t.removeListener("error", u), t.removeListener("close", h);
    };
};
function Pd() {
    if (Ad) return kd;
    var e;
    function t(e, t, n) {
        return (t = function(e) {
            var t = function(e, t) {
                if ("object" != typeof e || null === e) return e;
                var n = e[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var r = n.call(e, t || "default");
                    if ("object" != typeof r) return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (("TURBOPACK compile-time truthy", 1) ? String : "TURBOPACK unreachable")(e);
            }(e, "string");
            return "symbol" == typeof t ? t : String(t);
        }(t)) in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e;
    }
    Ad = 1;
    var n = Rd, r = Symbol("lastResolve"), i = Symbol("lastReject"), o = Symbol("error"), s = Symbol("ended"), a = Symbol("lastPromise"), c = Symbol("handlePromise"), l = Symbol("stream");
    function d(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function u(e) {
        var t = e[r];
        if (null !== t) {
            var n = e[l].read();
            null !== n && (e[a] = null, e[r] = null, e[i] = null, t(d(n, !1)));
        }
    }
    function h(e) {
        ua.nextTick(u, e);
    }
    var f = Object.getPrototypeOf(function() {}), p = Object.setPrototypeOf((t(e = {
        get stream () {
            return this[l];
        },
        next: function() {
            var e = this, t = this[o];
            if (null !== t) return Promise.reject(t);
            if (this[s]) return Promise.resolve(d(void 0, !0));
            if (this[l].destroyed) return new Promise(function(t, n) {
                ua.nextTick(function() {
                    e[o] ? n(e[o]) : t(d(void 0, !0));
                });
            });
            var n, r = this[a];
            if (r) n = new Promise(function(e, t) {
                return function(n, r) {
                    e.then(function() {
                        t[s] ? n(d(void 0, !0)) : t[c](n, r);
                    }, r);
                };
            }(r, this));
            else {
                var i = this[l].read();
                if (null !== i) return Promise.resolve(d(i, !1));
                n = new Promise(this[c]);
            }
            return this[a] = n, n;
        }
    }, Symbol.asyncIterator, function() {
        return this;
    }), t(e, "return", function() {
        var e = this;
        return new Promise(function(t, n) {
            e[l].destroy(null, function(e) {
                e ? n(e) : t(d(void 0, !0));
            });
        });
    }), e), f);
    return kd = function(e) {
        var u, f = Object.create(p, (t(u = {}, l, {
            value: e,
            writable: !0
        }), t(u, r, {
            value: null,
            writable: !0
        }), t(u, i, {
            value: null,
            writable: !0
        }), t(u, o, {
            value: null,
            writable: !0
        }), t(u, s, {
            value: e._readableState.endEmitted,
            writable: !0
        }), t(u, c, {
            value: function(e, t) {
                var n = f[l].read();
                n ? (f[a] = null, f[r] = null, f[i] = null, e(d(n, !1))) : (f[r] = e, f[i] = t);
            },
            writable: !0
        }), u));
        return f[a] = null, n(e, function(e) {
            if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
                var t = f[i];
                return null !== t && (f[a] = null, f[r] = null, f[i] = null, t(e)), void (f[o] = e);
            }
            var n = f[r];
            null !== n && (f[a] = null, f[r] = null, f[i] = null, n(d(void 0, !0))), f[s] = !0;
        }), e.on("readable", h.bind(null, f)), f;
    }, kd;
}
function Od() {
    if (Td) return Id;
    var e;
    Td = 1, Id = E, E.ReadableState = w, lc.EventEmitter;
    var t = function(e, t) {
        return e.listeners(t).length;
    }, n = sl, r = al.Buffer, i = (void 0 !== de ? de : ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : "undefined" != typeof self ? self : {}).Uint8Array || function() {};
    var o, s = Yl;
    o = s && s.debuglog ? s.debuglog("stream") : function() {};
    var a, c, l, d = Zl(), u = ed, h = dd.getHighWaterMark, f = td.codes, p = f.ERR_INVALID_ARG_TYPE, g = f.ERR_STREAM_PUSH_AFTER_EOF, m = f.ERR_METHOD_NOT_IMPLEMENTED, y = f.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    hd(E, n);
    var v = u.errorOrDestroy, b = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function w(t, n, r) {
        e = e || md(), t = t || {}, "boolean" != typeof r && (r = n instanceof e), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = h(this, t, "readableHighWaterMark", r), this.buffer = new d, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (a || (a = Sd.StringDecoder), this.decoder = new a(t.encoding), this.encoding = t.encoding);
    }
    function E(t) {
        if (e = e || md(), !(this instanceof E)) return new E(t);
        var r = this instanceof e;
        this._readableState = new w(t, this, r), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), n.call(this);
    }
    function S(e, t, n, s, a) {
        o("readableAddChunk", t);
        var c, l = e._readableState;
        if (null === t) l.reading = !1, function(e, t) {
            if (o("onEofChunk"), t.ended) return;
            if (t.decoder) {
                var n = t.decoder.end();
                n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);
            }
            t.ended = !0, t.sync ? A(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, x(e)));
        }(e, l);
        else if (a || (c = function(e, t) {
            var n;
            o = t, r.isBuffer(o) || o instanceof i || "string" == typeof t || void 0 === t || e.objectMode || (n = new p("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], t));
            var o;
            return n;
        }(l, t)), c) v(e, c);
        else if (l.objectMode || t && t.length > 0) if ("string" == typeof t || l.objectMode || Object.getPrototypeOf(t) === r.prototype || (t = function(e) {
            return r.from(e);
        }(t)), s) l.endEmitted ? v(e, new y) : _(e, l, t, !0);
        else if (l.ended) v(e, new g);
        else {
            if (l.destroyed) return !1;
            l.reading = !1, l.decoder && !n ? (t = l.decoder.write(t), l.objectMode || 0 !== t.length ? _(e, l, t, !1) : M(e, l)) : _(e, l, t, !1);
        }
        else s || (l.reading = !1, M(e, l));
        return !l.ended && (l.length < l.highWaterMark || 0 === l.length);
    }
    function _(e, t, n, r) {
        t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && A(e)), M(e, t);
    }
    Object.defineProperty(E.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return void 0 !== this._readableState && this._readableState.destroyed;
        },
        set: function(e) {
            this._readableState && (this._readableState.destroyed = e);
        }
    }), E.prototype.destroy = u.destroy, E.prototype._undestroy = u.undestroy, E.prototype._destroy = function(e, t) {
        t(e);
    }, E.prototype.push = function(e, t) {
        var n, i = this._readableState;
        return i.objectMode ? n = !0 : "string" == typeof e && ((t = t || i.defaultEncoding) !== i.encoding && (e = r.from(e, t), t = ""), n = !0), S(this, e, t, !1, n);
    }, E.prototype.unshift = function(e) {
        return S(this, e, null, !0, !1);
    }, E.prototype.isPaused = function() {
        return !1 === this._readableState.flowing;
    }, E.prototype.setEncoding = function(e) {
        a || (a = Sd.StringDecoder);
        var t = new a(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var n = this._readableState.buffer.head, r = ""; null !== n;)r += t.write(n.data), n = n.next;
        return this._readableState.buffer.clear(), "" !== r && this._readableState.buffer.push(r), this._readableState.length = r.length, this;
    };
    var C = 1073741824;
    function k(e, t) {
        return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function(e) {
            return e >= C ? e = C : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
        }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
    }
    function A(e) {
        var t = e._readableState;
        o("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (o("emitReadable", t.flowing), t.emittedReadable = !0, ua.nextTick(x, e));
    }
    function x(e) {
        var t = e._readableState;
        o("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, O(e);
    }
    function M(e, t) {
        t.readingMore || (t.readingMore = !0, ua.nextTick(I, e, t));
    }
    function I(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);){
            var n = t.length;
            if (o("maybeReadMore read 0"), e.read(0), n === t.length) break;
        }
        t.readingMore = !1;
    }
    function T(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
    }
    function R(e) {
        o("readable nexttick read 0"), e.read(0);
    }
    function P(e, t) {
        o("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), O(e), t.flowing && !t.reading && e.read(0);
    }
    function O(e) {
        var t = e._readableState;
        for(o("flow", t.flowing); t.flowing && null !== e.read(););
    }
    function N(e, t) {
        return 0 === t.length ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n);
        //TURBOPACK unreachable
        ;
        var n;
    }
    function L(e) {
        var t = e._readableState;
        o("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, ua.nextTick(D, t, e));
    }
    function D(e, t) {
        if (o("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var n = t._writableState;
            (!n || n.autoDestroy && n.finished) && t.destroy();
        }
    }
    function $(e, t) {
        for(var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n;
        return -1;
    }
    return E.prototype.read = function(e) {
        o("read", e), e = parseInt(e, 10);
        var t = this._readableState, n = e;
        if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return o("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? L(this) : A(this), null;
        if (0 === (e = k(e, t)) && t.ended) return 0 === t.length && L(this), null;
        var r, i = t.needReadable;
        return o("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && o("length less than watermark", i = !0), t.ended || t.reading ? o("reading or ended", i = !1) : i && (o("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = k(n, t))), null === (r = e > 0 ? N(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), n !== e && t.ended && L(this)), null !== r && this.emit("data", r), r;
    }, E.prototype._read = function(e) {
        v(this, new m("_read()"));
    }, E.prototype.pipe = function(e, n) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    e
                ];
                break;
            default:
                i.pipes.push(e);
        }
        i.pipesCount += 1, o("pipe count=%d opts=%j", i.pipesCount, n);
        var s = (!n || !1 !== n.end) && e !== ua.stdout && e !== ua.stderr ? c : g;
        function a(t, n) {
            o("onunpipe"), t === r && n && !1 === n.hasUnpiped && (n.hasUnpiped = !0, o("cleanup"), e.removeListener("close", f), e.removeListener("finish", p), e.removeListener("drain", l), e.removeListener("error", h), e.removeListener("unpipe", a), r.removeListener("end", c), r.removeListener("end", g), r.removeListener("data", u), d = !0, !i.awaitDrain || e._writableState && !e._writableState.needDrain || l());
        }
        function c() {
            o("onend"), e.end();
        }
        i.endEmitted ? ua.nextTick(s) : r.once("end", s), e.on("unpipe", a);
        var l = function(e) {
            return function() {
                var n = e._readableState;
                o("pipeOnDrain", n.awaitDrain), n.awaitDrain && n.awaitDrain--, 0 === n.awaitDrain && t(e, "data") && (n.flowing = !0, O(e));
            };
        }(r);
        e.on("drain", l);
        var d = !1;
        function u(t) {
            o("ondata");
            var n = e.write(t);
            o("dest.write", n), !1 === n && ((1 === i.pipesCount && i.pipes === e || i.pipesCount > 1 && -1 !== $(i.pipes, e)) && !d && (o("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        function h(n) {
            o("onerror", n), g(), e.removeListener("error", h), 0 === t(e, "error") && v(e, n);
        }
        function f() {
            e.removeListener("finish", p), g();
        }
        function p() {
            o("onfinish"), e.removeListener("close", f), g();
        }
        function g() {
            o("unpipe"), r.unpipe(e);
        }
        return r.on("data", u), function(e, t, n) {
            if ("function" == typeof e.prependListener) return e.prependListener(t, n);
            e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [
                n,
                e._events[t]
            ] : e.on(t, n);
        }(e, "error", h), e.once("close", f), e.once("finish", p), e.emit("pipe", r), i.flowing || (o("pipe resume"), r.resume()), e;
    }, E.prototype.unpipe = function(e) {
        var t = this._readableState, n = {
            hasUnpiped: !1
        };
        if (0 === t.pipesCount) return this;
        if (1 === t.pipesCount) return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, n)), this;
        if (!e) {
            var r = t.pipes, i = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for(var o = 0; o < i; o++)r[o].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var s = $(t.pipes, e);
        return -1 === s || (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, n)), this;
    }, E.prototype.on = function(e, t) {
        var r = n.prototype.on.call(this, e, t), i = this._readableState;
        return "data" === e ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === e && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, o("on readable", i.length, i.reading), i.length ? A(this) : i.reading || ua.nextTick(R, this))), r;
    }, E.prototype.addListener = E.prototype.on, E.prototype.removeListener = function(e, t) {
        var r = n.prototype.removeListener.call(this, e, t);
        return "readable" === e && ua.nextTick(T, this), r;
    }, E.prototype.removeAllListeners = function(e) {
        var t = n.prototype.removeAllListeners.apply(this, arguments);
        return "readable" !== e && void 0 !== e || ua.nextTick(T, this), t;
    }, E.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (o("resume"), e.flowing = !e.readableListening, function(e, t) {
            t.resumeScheduled || (t.resumeScheduled = !0, ua.nextTick(P, e, t));
        }(this, e)), e.paused = !1, this;
    }, E.prototype.pause = function() {
        return o("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (o("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    }, E.prototype.wrap = function(e) {
        var t = this, n = this._readableState, r = !1;
        for(var i in e.on("end", function() {
            if (o("wrapped end"), n.decoder && !n.ended) {
                var e = n.decoder.end();
                e && e.length && t.push(e);
            }
            t.push(null);
        }), e.on("data", function(i) {
            (o("wrapped data"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause()));
        }), e)void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
            return function() {
                return e[t].apply(e, arguments);
            };
        }(i));
        for(var s = 0; s < b.length; s++)e.on(b[s], this.emit.bind(this, b[s]));
        return this._read = function(t) {
            o("wrapped _read", t), r && (r = !1, e.resume());
        }, this;
    }, "function" == typeof Symbol && (E.prototype[Symbol.asyncIterator] = function() {
        return void 0 === c && (c = Pd()), c(this);
    }), Object.defineProperty(E.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    }), Object.defineProperty(E.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    }), Object.defineProperty(E.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(e) {
            this._readableState && (this._readableState.flowing = e);
        }
    }), E._fromList = N, Object.defineProperty(E.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length;
        }
    }), "function" == typeof Symbol && (E.from = function(e, t) {
        return void 0 === l && (l = Md ? xd : (Md = 1, xd = function() {
            throw new Error("Readable.from is not available in the browser");
        })), l(E, e, t);
    }), Id;
}
var Nd = Hd, Ld = td.codes, Dd = Ld.ERR_METHOD_NOT_IMPLEMENTED, $d = Ld.ERR_MULTIPLE_CALLBACK, Bd = Ld.ERR_TRANSFORM_ALREADY_TRANSFORMING, Kd = Ld.ERR_TRANSFORM_WITH_LENGTH_0, jd = md();
function Ud(e, t) {
    var n = this._transformState;
    n.transforming = !1;
    var r = n.writecb;
    if (null === r) return this.emit("error", new $d);
    n.writechunk = null, n.writecb = null, null != t && this.push(t), r(e);
    var i = this._readableState;
    i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
}
function Hd(e) {
    if (!(this instanceof Hd)) return new Hd(e);
    jd.call(this, e), this._transformState = {
        afterTransform: Ud.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", Fd);
}
function Fd() {
    var e = this;
    "function" != typeof this._flush || this._readableState.destroyed ? zd(this, null, null) : this._flush(function(t, n) {
        zd(e, t, n);
    });
}
function zd(e, t, n) {
    if (t) return e.emit("error", t);
    if (null != n && e.push(n), e._writableState.length) throw new Kd;
    if (e._transformState.transforming) throw new Bd;
    return e.push(null);
}
hd(Hd, jd), Hd.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, jd.prototype.push.call(this, e, t);
}, Hd.prototype._transform = function(e, t, n) {
    n(new Dd("_transform()"));
}, Hd.prototype._write = function(e, t, n) {
    var r = this._transformState;
    if (r.writecb = n, r.writechunk = e, r.writeencoding = t, !r.transforming) {
        var i = this._readableState;
        (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
}, Hd.prototype._read = function(e) {
    var t = this._transformState;
    null === t.writechunk || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform));
}, Hd.prototype._destroy = function(e, t) {
    jd.prototype._destroy.call(this, e, function(e) {
        t(e);
    });
};
var qd, Wd = Gd, Vd = Nd;
function Gd(e) {
    if (!(this instanceof Gd)) return new Gd(e);
    Vd.call(this, e);
}
hd(Gd, Vd), Gd.prototype._transform = function(e, t, n) {
    n(null, e);
};
var Yd = td.codes, Zd = Yd.ERR_MISSING_ARGS, Jd = Yd.ERR_STREAM_DESTROYED;
function Qd(e) {
    if (e) throw e;
}
function Xd(e) {
    e();
}
function eu(e, t) {
    return e.pipe(t);
}
var tu = function() {
    for(var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n];
    var r, i = function(e) {
        return e.length ? "function" != typeof e[e.length - 1] ? Qd : e.pop() : Qd;
    }(t);
    if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new Zd("streams");
    var o = t.map(function(e, n) {
        var s = n < t.length - 1;
        return function(e, t, n, r) {
            r = function(e) {
                var t = !1;
                return function() {
                    t || (t = !0, e.apply(void 0, arguments));
                };
            }(r);
            var i = !1;
            e.on("close", function() {
                i = !0;
            }), void 0 === qd && (qd = Rd), qd(e, {
                readable: t,
                writable: n
            }, function(e) {
                if (e) return r(e);
                i = !0, r();
            });
            var o = !1;
            return function(t) {
                if (!i && !o) return o = !0, function(e) {
                    return e.setHeader && "function" == typeof e.abort;
                }(e) ? e.abort() : "function" == typeof e.destroy ? e.destroy() : void r(t || new Jd("pipe"));
            };
        }(e, s, n > 0, function(e) {
            r || (r = e), e && o.forEach(Xd), s || (o.forEach(Xd), i(r));
        });
    });
    return t.reduce(eu);
};
!function(e, t) {
    (t = ol.exports = Od()).Stream = t, t.Readable = t, t.Writable = gd(), t.Duplex = md(), t.Transform = Nd, t.PassThrough = Wd, t.finished = Rd, t.pipeline = tu;
}(0, ol.exports);
var nu = ol.exports;
function ru(e = {}) {
    const t = {}, n = new nu.Duplex({
        objectMode: !0,
        read: ()=>{},
        write: function(n, o, s) {
            let a = null;
            try {
                !n.id ? function(n) {
                    e?.retryOnMessage && n.method === e.retryOnMessage && Object.values(t).forEach(({ req: e, retryCount: n = 0 })=>{
                        if (!e.id) return;
                        if (n >= 3) throw new Error(`StreamMiddleware - Retry limit exceeded for request id "${e.id}"`);
                        const r = t[e.id];
                        r && (r.retryCount = n + 1), i(e);
                    });
                    r.emit("notification", n);
                }(n) : function(e) {
                    const { id: n } = e;
                    if (null === n) return;
                    const r = t[n];
                    if (!r) return void console.warn(`StreamMiddleware - Unknown response id "${n}"`);
                    delete t[n], Object.assign(r.res, e), setTimeout(r.end);
                }(n);
            } catch (e) {
                a = e;
            }
            s(a);
        }
    }), r = new Pc;
    return {
        events: r,
        middleware: (e, n, r, o)=>{
            t[e.id] = {
                req: e,
                res: n,
                next: r,
                end: o
            }, i(e);
        },
        stream: n
    };
    //TURBOPACK unreachable
    ;
    function i(e) {
        n.push(e);
    }
}
var iu = {}, ou = {
    exports: {}
}, su = function e(t, n) {
    if (t && n) return e(t)(n);
    if ("function" != typeof t) throw new TypeError("need wrapper function");
    return Object.keys(t).forEach(function(e) {
        r[e] = t[e];
    }), r;
    //TURBOPACK unreachable
    ;
    function r() {
        for(var e = new Array(arguments.length), n = 0; n < e.length; n++)e[n] = arguments[n];
        var r = t.apply(this, e), i = e[e.length - 1];
        return "function" == typeof r && r !== i && Object.keys(i).forEach(function(e) {
            r[e] = i[e];
        }), r;
    }
};
var au = su;
function cu(e) {
    var t = function() {
        return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
    };
    return t.called = !1, t;
}
function lu(e) {
    var t = function() {
        if (t.called) throw new Error(t.onceError);
        return t.called = !0, t.value = e.apply(this, arguments);
    }, n = e.name || "Function wrapped with `once`";
    return t.onceError = n + " shouldn't be called more than once", t.called = !1, t;
}
ou.exports = au(cu), ou.exports.strict = au(lu), cu.proto = cu(function() {
    Object.defineProperty(Function.prototype, "once", {
        value: function() {
            return cu(this);
        },
        configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
            return lu(this);
        },
        configurable: !0
    });
});
var du = ou.exports, uu = {};
Object.defineProperty(uu, "__esModule", {
    value: !0
}), uu.Substream = void 0;
const hu = nu;
class fu extends hu.Duplex {
    constructor({ parent: e, name: t }){
        super({
            objectMode: !0
        }), this._parent = e, this._name = t;
    }
    _read() {}
    _write(e, t, n) {
        this._parent.push({
            name: this._name,
            data: e
        }), n();
    }
}
uu.Substream = fu;
var pu = de && de.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    };
};
Object.defineProperty(iu, "__esModule", {
    value: !0
}), iu.ObjectMultiplex = void 0;
const gu = nu, mu = pu(du), yu = uu, vu = Symbol("IGNORE_SUBSTREAM");
let bu = class extends gu.Duplex {
    constructor(e = {}){
        super(Object.assign(Object.assign({}, e), {
            objectMode: !0
        })), this._substreams = {};
    }
    createStream(e) {
        if (this.destroyed) throw new Error(`ObjectMultiplex - parent stream for name "${e}" already destroyed`);
        if (this._readableState.ended || this._writableState.ended) throw new Error(`ObjectMultiplex - parent stream for name "${e}" already ended`);
        if (!e) throw new Error("ObjectMultiplex - name must not be empty");
        if (this._substreams[e]) throw new Error(`ObjectMultiplex - Substream for name "${e}" already exists`);
        const t = new yu.Substream({
            parent: this,
            name: e
        });
        return this._substreams[e] = t, function(e, t) {
            const n = (0, mu.default)(t);
            (0, gu.finished)(e, {
                readable: !1
            }, n), (0, gu.finished)(e, {
                writable: !1
            }, n);
        }(this, (e)=>t.destroy(e || void 0)), t;
    }
    ignoreStream(e) {
        if (!e) throw new Error("ObjectMultiplex - name must not be empty");
        if (this._substreams[e]) throw new Error(`ObjectMultiplex - Substream for name "${e}" already exists`);
        this._substreams[e] = vu;
    }
    _read() {}
    _write(e, t, n) {
        const { name: r, data: i } = e;
        if (!r) return console.warn(`ObjectMultiplex - malformed chunk without name "${e}"`), n();
        const o = this._substreams[r];
        return o ? (o !== vu && o.push(i), n()) : (console.warn(`ObjectMultiplex - orphaned data for stream "${r}"`), n());
    }
};
iu.ObjectMultiplex = bu;
var wu = ue(iu.ObjectMultiplex);
const Eu = (e)=>null !== e && "object" == typeof e && "function" == typeof e.pipe;
Eu.writable = (e)=>Eu(e) && !1 !== e.writable && "function" == typeof e._write && "object" == typeof e._writableState, Eu.readable = (e)=>Eu(e) && !1 !== e.readable && "function" == typeof e._read && "object" == typeof e._readableState, Eu.duplex = (e)=>Eu.writable(e) && Eu.readable(e), Eu.transform = (e)=>Eu.duplex(e) && "function" == typeof e._transform;
var Su, _u = Eu, Cu = class extends il {
    constructor(e, { jsonRpcStreamName: t, logger: n = console, maxEventListeners: r = 100, rpcMiddleware: i = [] }){
        if (super({
            logger: n,
            maxEventListeners: r,
            rpcMiddleware: i
        }), !_u.duplex(e)) throw new Error(is.errors.invalidDuplexStream());
        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
        const o = new wu;
        nu.pipeline(e, o, e, this._handleStreamDisconnect.bind(this, "MetaMask")), this._jsonRpcConnection = ru({
            retryOnMessage: "METAMASK_EXTENSION_CONNECT_CAN_RETRY"
        }), nu.pipeline(this._jsonRpcConnection.stream, o.createStream(t), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "MetaMask RpcProvider")), this._rpcEngine.push(this._jsonRpcConnection.middleware), this._jsonRpcConnection.events.on("notification", (t)=>{
            const { method: n, params: r } = t;
            "metamask_accountsChanged" === n ? this._handleAccountsChanged(r) : "metamask_unlockStateChanged" === n ? this._handleUnlockStateChanged(r) : "metamask_chainChanged" === n ? this._handleChainChanged(r) : Dc.includes(n) ? this.emit("message", {
                type: n,
                data: r
            }) : "METAMASK_STREAM_FAILURE" === n && e.destroy(new Error(is.errors.permanentlyDisconnected()));
        });
    }
    async _initializeStateAsync() {
        let e;
        try {
            e = await this.request({
                method: "metamask_getProviderState"
            });
        } catch (e) {
            this._log.error("MetaMask: Failed to get initial state. Please report this bug.", e);
        }
        this._initializeState(e);
    }
    _handleStreamDisconnect(e, t) {
        let n = `MetaMask: Lost connection to "${e}".`;
        t?.stack && (n += `\n${t.stack}`), this._log.warn(n), this.listenerCount("error") > 0 && this.emit("error", n), this._handleDisconnect(!1, t ? t.message : void 0);
    }
    _handleChainChanged({ chainId: e, networkVersion: t } = {}) {
        jc(e) && ((e)=>Boolean(e) && "string" == typeof e)(t) ? "loading" === t ? this._handleDisconnect(!0) : super._handleChainChanged({
            chainId: e
        }) : this._log.error(is.errors.invalidNetworkParams(), {
            chainId: e,
            networkVersion: t
        });
    }
}, ku = class extends Cu {
    constructor(e, { jsonRpcStreamName: t = "metamask-provider", logger: n = console, maxEventListeners: r = 100, shouldSendMetadata: i } = {}){
        if (super(e, {
            jsonRpcStreamName: t,
            logger: n,
            maxEventListeners: r,
            rpcMiddleware: $c(n)
        }), this._sentWarnings = {
            chainId: !1,
            networkVersion: !1,
            selectedAddress: !1,
            enable: !1,
            experimentalMethods: !1,
            send: !1,
            events: {
                close: !1,
                data: !1,
                networkChanged: !1,
                notification: !1
            }
        }, Gc(this, Su, void 0), this._initializeStateAsync(), Yc(this, Su, null), this.isMetaMask = !0, this._sendSync = this._sendSync.bind(this), this.enable = this.enable.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this._warnOfDeprecation = this._warnOfDeprecation.bind(this), this._metamask = this._getExperimentalApi(), this._jsonRpcConnection.events.on("notification", (e)=>{
            const { method: t } = e;
            Dc.includes(t) && (this.emit("data", e), this.emit("notification", e.params.result));
        }), i) if ("complete" === document.readyState) Hc(this._rpcEngine, this._log);
        else {
            const e = ()=>{
                Hc(this._rpcEngine, this._log), window.removeEventListener("DOMContentLoaded", e);
            };
            window.addEventListener("DOMContentLoaded", e);
        }
    }
    get chainId() {
        return this._sentWarnings.chainId || (this._log.warn(is.warnings.chainIdDeprecation), this._sentWarnings.chainId = !0), super.chainId;
    }
    get networkVersion() {
        return this._sentWarnings.networkVersion || (this._log.warn(is.warnings.networkVersionDeprecation), this._sentWarnings.networkVersion = !0), Vc(this, Su);
    }
    get selectedAddress() {
        return this._sentWarnings.selectedAddress || (this._log.warn(is.warnings.selectedAddressDeprecation), this._sentWarnings.selectedAddress = !0), super.selectedAddress;
    }
    sendAsync(e, t) {
        this._rpcRequest(e, t);
    }
    addListener(e, t) {
        return this._warnOfDeprecation(e), super.addListener(e, t);
    }
    on(e, t) {
        return this._warnOfDeprecation(e), super.on(e, t);
    }
    once(e, t) {
        return this._warnOfDeprecation(e), super.once(e, t);
    }
    prependListener(e, t) {
        return this._warnOfDeprecation(e), super.prependListener(e, t);
    }
    prependOnceListener(e, t) {
        return this._warnOfDeprecation(e), super.prependOnceListener(e, t);
    }
    _handleDisconnect(e, t) {
        super._handleDisconnect(e, t), Vc(this, Su) && !e && Yc(this, Su, null);
    }
    _warnOfDeprecation(e) {
        !1 === this._sentWarnings?.events[e] && (this._log.warn(is.warnings.events[e]), this._sentWarnings.events[e] = !0);
    }
    async enable() {
        return this._sentWarnings.enable || (this._log.warn(is.warnings.enableDeprecation), this._sentWarnings.enable = !0), new Promise((e, t)=>{
            try {
                this._rpcRequest({
                    method: "eth_requestAccounts",
                    params: []
                }, Kc(e, t));
            } catch (e) {
                t(e);
            }
        });
    }
    send(e, t) {
        return this._sentWarnings.send || (this._log.warn(is.warnings.sendDeprecation), this._sentWarnings.send = !0), "string" != typeof e || t && !Array.isArray(t) ? e && "object" == typeof e && "function" == typeof t ? this._rpcRequest(e, t) : this._sendSync(e) : new Promise((n, r)=>{
            try {
                this._rpcRequest({
                    method: e,
                    params: t
                }, Kc(n, r, !1));
            } catch (e) {
                r(e);
            }
        });
    }
    _sendSync(e) {
        let t;
        switch(e.method){
            case "eth_accounts":
                t = this.selectedAddress ? [
                    this.selectedAddress
                ] : [];
                break;
            case "eth_coinbase":
                t = this.selectedAddress ?? null;
                break;
            case "eth_uninstallFilter":
                this._rpcRequest(e, Uc), t = !0;
                break;
            case "net_version":
                t = Vc(this, Su) ?? null;
                break;
            default:
                throw new Error(is.errors.unsupportedSync(e.method));
        }
        return {
            id: e.id,
            jsonrpc: e.jsonrpc,
            result: t
        };
    }
    _getExperimentalApi() {
        return new Proxy({
            isUnlocked: async ()=>(this._state.initialized || await new Promise((e)=>{
                    this.on("_initialized", ()=>e());
                }), this._state.isUnlocked),
            requestBatch: async (e)=>{
                if (!Array.isArray(e)) throw Xa({
                    message: "Batch requests must be made with an array of request objects.",
                    data: e
                });
                return new Promise((t, n)=>{
                    this._rpcRequest(e, Kc(t, n));
                });
            }
        }, {
            get: (e, t, ...n)=>(this._sentWarnings.experimentalMethods || (this._log.warn(is.warnings.experimentalMethods), this._sentWarnings.experimentalMethods = !0), Reflect.get(e, t, ...n))
        });
    }
    _handleChainChanged({ chainId: e, networkVersion: t } = {}) {
        super._handleChainChanged({
            chainId: e,
            networkVersion: t
        }), this._state.isConnected && t !== Vc(this, Su) && (Yc(this, Su, t), this._state.initialized && this.emit("networkChanged", Vc(this, Su)));
    }
};
Su = new WeakMap;
const Au = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("MM_SDK");
let xu;
Au.color = "#FFAC1C";
var Mu = {}, Iu = {};
Object.defineProperty(Iu, "__esModule", {
    value: !0
}), Iu.EthereumProviderError = Iu.EthereumRpcError = void 0;
const Tu = $a;
class Ru extends Error {
    constructor(e, t, n){
        if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
        if (!t || "string" != typeof t) throw new Error('"message" must be a nonempty string.');
        super(t), this.code = e, void 0 !== n && (this.data = n);
    }
    serialize() {
        const e = {
            code: this.code,
            message: this.message
        };
        return void 0 !== this.data && (e.data = this.data), this.stack && (e.stack = this.stack), e;
    }
    toString() {
        return Tu.default(this.serialize(), Pu, 2);
    }
}
Iu.EthereumRpcError = Ru;
function Pu(e, t) {
    if ("[Circular]" !== t) return t;
}
Iu.EthereumProviderError = class extends Ru {
    constructor(e, t, n){
        if (!function(e) {
            return Number.isInteger(e) && e >= 1e3 && e <= 4999;
        }(e)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        super(e, t, n);
    }
};
var Ou = {}, Nu = {};
Object.defineProperty(Nu, "__esModule", {
    value: !0
}), Nu.errorValues = Nu.errorCodes = void 0, Nu.errorCodes = {
    rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
    },
    provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
    }
}, Nu.errorValues = {
    "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
    },
    "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
    },
    "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
    },
    "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
    },
    "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
    },
    "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
    },
    "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
    },
    "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
    },
    "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
    },
    4001: {
        standard: "EIP-1193",
        message: "User rejected the request."
    },
    4100: {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
    },
    4901: {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
    }
}, function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    const t = Nu, n = Iu, r = t.errorCodes.rpc.internal, i = "Unspecified error message. This is a bug, please report it.", o = {
        code: r,
        message: s(r)
    };
    function s(n, r = i) {
        if (Number.isInteger(n)) {
            const r = n.toString();
            if (d(t.errorValues, r)) return t.errorValues[r].message;
            if (c(n)) return e.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
        return r;
    }
    function a(e) {
        if (!Number.isInteger(e)) return !1;
        const n = e.toString();
        return !!t.errorValues[n] || !!c(e);
    }
    function c(e) {
        return e >= -32099 && e <= -32e3;
    }
    function l(e) {
        return e && "object" == typeof e && !Array.isArray(e) ? Object.assign({}, e) : e;
    }
    function d(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
    }
    e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.", e.getMessageFromCode = s, e.isValidCode = a, e.serializeError = function(e, { fallbackError: t = o, shouldIncludeStack: r = !1 } = {}) {
        var i, c;
        if (!t || !Number.isInteger(t.code) || "string" != typeof t.message) throw new Error("Must provide fallback error with integer number code and string message.");
        if (e instanceof n.EthereumRpcError) return e.serialize();
        const u = {};
        if (e && "object" == typeof e && !Array.isArray(e) && d(e, "code") && a(e.code)) {
            const t = e;
            u.code = t.code, t.message && "string" == typeof t.message ? (u.message = t.message, d(t, "data") && (u.data = t.data)) : (u.message = s(u.code), u.data = {
                originalError: l(e)
            });
        } else {
            u.code = t.code;
            const n = null === (i = e) || void 0 === i ? void 0 : i.message;
            u.message = n && "string" == typeof n ? n : t.message, u.data = {
                originalError: l(e)
            };
        }
        const h = null === (c = e) || void 0 === c ? void 0 : c.stack;
        return r && e && h && "string" == typeof h && (u.stack = h), u;
    };
}(Ou);
var Lu = {};
Object.defineProperty(Lu, "__esModule", {
    value: !0
}), Lu.ethErrors = void 0;
const Du = Iu, $u = Ou, Bu = Nu;
function Ku(e, t) {
    const [n, r] = Uu(t);
    return new Du.EthereumRpcError(e, n || $u.getMessageFromCode(e), r);
}
function ju(e, t) {
    const [n, r] = Uu(t);
    return new Du.EthereumProviderError(e, n || $u.getMessageFromCode(e), r);
}
function Uu(e) {
    if (e) {
        if ("string" == typeof e) return [
            e
        ];
        if ("object" == typeof e && !Array.isArray(e)) {
            const { message: t, data: n } = e;
            if (t && "string" != typeof t) throw new Error("Must specify string message.");
            return [
                t || void 0,
                n
            ];
        }
    }
    return [];
}
Lu.ethErrors = {
    rpc: {
        parse: (e)=>Ku(Bu.errorCodes.rpc.parse, e),
        invalidRequest: (e)=>Ku(Bu.errorCodes.rpc.invalidRequest, e),
        invalidParams: (e)=>Ku(Bu.errorCodes.rpc.invalidParams, e),
        methodNotFound: (e)=>Ku(Bu.errorCodes.rpc.methodNotFound, e),
        internal: (e)=>Ku(Bu.errorCodes.rpc.internal, e),
        server: (e)=>{
            if (!e || "object" != typeof e || Array.isArray(e)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
            const { code: t } = e;
            if (!Number.isInteger(t) || t > -32005 || t < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
            return Ku(t, e);
        },
        invalidInput: (e)=>Ku(Bu.errorCodes.rpc.invalidInput, e),
        resourceNotFound: (e)=>Ku(Bu.errorCodes.rpc.resourceNotFound, e),
        resourceUnavailable: (e)=>Ku(Bu.errorCodes.rpc.resourceUnavailable, e),
        transactionRejected: (e)=>Ku(Bu.errorCodes.rpc.transactionRejected, e),
        methodNotSupported: (e)=>Ku(Bu.errorCodes.rpc.methodNotSupported, e),
        limitExceeded: (e)=>Ku(Bu.errorCodes.rpc.limitExceeded, e)
    },
    provider: {
        userRejectedRequest: (e)=>ju(Bu.errorCodes.provider.userRejectedRequest, e),
        unauthorized: (e)=>ju(Bu.errorCodes.provider.unauthorized, e),
        unsupportedMethod: (e)=>ju(Bu.errorCodes.provider.unsupportedMethod, e),
        disconnected: (e)=>ju(Bu.errorCodes.provider.disconnected, e),
        chainDisconnected: (e)=>ju(Bu.errorCodes.provider.chainDisconnected, e),
        custom: (e)=>{
            if (!e || "object" != typeof e || Array.isArray(e)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
            const { code: t, message: n, data: r } = e;
            if (!n || "string" != typeof n) throw new Error('"message" must be a nonempty string');
            return new Du.EthereumProviderError(t, n, r);
        }
    }
}, function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
    const t = Iu;
    Object.defineProperty(e, "EthereumRpcError", {
        enumerable: !0,
        get: function() {
            return t.EthereumRpcError;
        }
    }), Object.defineProperty(e, "EthereumProviderError", {
        enumerable: !0,
        get: function() {
            return t.EthereumProviderError;
        }
    });
    const n = Ou;
    Object.defineProperty(e, "serializeError", {
        enumerable: !0,
        get: function() {
            return n.serializeError;
        }
    }), Object.defineProperty(e, "getMessageFromCode", {
        enumerable: !0,
        get: function() {
            return n.getMessageFromCode;
        }
    });
    const r = Lu;
    Object.defineProperty(e, "ethErrors", {
        enumerable: !0,
        get: function() {
            return r.ethErrors;
        }
    });
    const i = Nu;
    Object.defineProperty(e, "errorCodes", {
        enumerable: !0,
        get: function() {
            return i.errorCodes;
        }
    });
}(Mu);
var Hu = {
    exports: {}
};
Hu.exports = function(e) {
    var t = {};
    function n(r) {
        if (t[r]) return t[r].exports;
        var i = t[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;
    }
    return n.m = e, n.c = t, n.d = function(e, t, r) {
        n.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: r
        });
    }, n.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        });
    }, n.t = function(e, t) {
        if (1 & t && (e = n(e)), 8 & t) return e;
        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
        var r = Object.create(null);
        if (n.r(r), Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
        }), 2 & t && "string" != typeof e) for(var i in e)n.d(r, i, (function(t) {
            return e[t];
        }).bind(null, i));
        return r;
    }, n.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default;
        } : function() {
            return e;
        };
        return n.d(t, "a", t), t;
    }, n.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
    }, n.p = "", n(n.s = 90);
}({
    17: function(e, t, n) {
        t.__esModule = !0, t.default = void 0;
        var r = n(18), i = function() {
            function e() {}
            return e.getFirstMatch = function(e, t) {
                var n = t.match(e);
                return n && n.length > 0 && n[1] || "";
            }, e.getSecondMatch = function(e, t) {
                var n = t.match(e);
                return n && n.length > 1 && n[2] || "";
            }, e.matchAndReturnConst = function(e, t, n) {
                if (e.test(t)) return n;
            }, e.getWindowsVersionName = function(e) {
                switch(e){
                    case "NT":
                        return "NT";
                    case "XP":
                    case "NT 5.1":
                        return "XP";
                    case "NT 5.0":
                        return "2000";
                    case "NT 5.2":
                        return "2003";
                    case "NT 6.0":
                        return "Vista";
                    case "NT 6.1":
                        return "7";
                    case "NT 6.2":
                        return "8";
                    case "NT 6.3":
                        return "8.1";
                    case "NT 10.0":
                        return "10";
                    default:
                        return;
                }
            }, e.getMacOSVersionName = function(e) {
                var t = e.split(".").splice(0, 2).map(function(e) {
                    return parseInt(e, 10) || 0;
                });
                if (t.push(0), 10 === t[0]) switch(t[1]){
                    case 5:
                        return "Leopard";
                    case 6:
                        return "Snow Leopard";
                    case 7:
                        return "Lion";
                    case 8:
                        return "Mountain Lion";
                    case 9:
                        return "Mavericks";
                    case 10:
                        return "Yosemite";
                    case 11:
                        return "El Capitan";
                    case 12:
                        return "Sierra";
                    case 13:
                        return "High Sierra";
                    case 14:
                        return "Mojave";
                    case 15:
                        return "Catalina";
                    default:
                        return;
                }
            }, e.getAndroidVersionName = function(e) {
                var t = e.split(".").splice(0, 2).map(function(e) {
                    return parseInt(e, 10) || 0;
                });
                if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0;
            }, e.getVersionPrecision = function(e) {
                return e.split(".").length;
            }, e.compareVersions = function(t, n, r) {
                void 0 === r && (r = !1);
                var i = e.getVersionPrecision(t), o = e.getVersionPrecision(n), s = Math.max(i, o), a = 0, c = e.map([
                    t,
                    n
                ], function(t) {
                    var n = s - e.getVersionPrecision(t), r = t + new Array(n + 1).join(".0");
                    return e.map(r.split("."), function(e) {
                        return new Array(20 - e.length).join("0") + e;
                    }).reverse();
                });
                for(r && (a = s - Math.min(i, o)), s -= 1; s >= a;){
                    if (c[0][s] > c[1][s]) return 1;
                    if (c[0][s] === c[1][s]) {
                        if (s === a) return 0;
                        s -= 1;
                    } else if (c[0][s] < c[1][s]) return -1;
                }
            }, e.map = function(e, t) {
                var n, r = [];
                if (Array.prototype.map) return Array.prototype.map.call(e, t);
                for(n = 0; n < e.length; n += 1)r.push(t(e[n]));
                return r;
            }, e.find = function(e, t) {
                var n, r;
                if (Array.prototype.find) return Array.prototype.find.call(e, t);
                for(n = 0, r = e.length; n < r; n += 1){
                    var i = e[n];
                    if (t(i, n)) return i;
                }
            }, e.assign = function(e) {
                for(var t, n, r = e, i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++)o[s - 1] = arguments[s];
                if ("TURBOPACK compile-time truthy", 1) return Object.assign.apply(Object, [
                    e
                ].concat(o));
                //TURBOPACK unreachable
                ;
                var a;
            }, e.getBrowserAlias = function(e) {
                return r.BROWSER_ALIASES_MAP[e];
            }, e.getBrowserTypeByAlias = function(e) {
                return r.BROWSER_MAP[e] || "";
            }, e;
        }();
        t.default = i, e.exports = t.default;
    },
    18: function(e, t, n) {
        t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0, t.BROWSER_ALIASES_MAP = {
            "Amazon Silk": "amazon_silk",
            "Android Browser": "android",
            Bada: "bada",
            BlackBerry: "blackberry",
            Chrome: "chrome",
            Chromium: "chromium",
            Electron: "electron",
            Epiphany: "epiphany",
            Firefox: "firefox",
            Focus: "focus",
            Generic: "generic",
            "Google Search": "google_search",
            Googlebot: "googlebot",
            "Internet Explorer": "ie",
            "K-Meleon": "k_meleon",
            Maxthon: "maxthon",
            "Microsoft Edge": "edge",
            "MZ Browser": "mz",
            "NAVER Whale Browser": "naver",
            Opera: "opera",
            "Opera Coast": "opera_coast",
            PhantomJS: "phantomjs",
            Puffin: "puffin",
            QupZilla: "qupzilla",
            QQ: "qq",
            QQLite: "qqlite",
            Safari: "safari",
            Sailfish: "sailfish",
            "Samsung Internet for Android": "samsung_internet",
            SeaMonkey: "seamonkey",
            Sleipnir: "sleipnir",
            Swing: "swing",
            Tizen: "tizen",
            "UC Browser": "uc",
            Vivaldi: "vivaldi",
            "WebOS Browser": "webos",
            WeChat: "wechat",
            "Yandex Browser": "yandex",
            Roku: "roku"
        }, t.BROWSER_MAP = {
            amazon_silk: "Amazon Silk",
            android: "Android Browser",
            bada: "Bada",
            blackberry: "BlackBerry",
            chrome: "Chrome",
            chromium: "Chromium",
            electron: "Electron",
            epiphany: "Epiphany",
            firefox: "Firefox",
            focus: "Focus",
            generic: "Generic",
            googlebot: "Googlebot",
            google_search: "Google Search",
            ie: "Internet Explorer",
            k_meleon: "K-Meleon",
            maxthon: "Maxthon",
            edge: "Microsoft Edge",
            mz: "MZ Browser",
            naver: "NAVER Whale Browser",
            opera: "Opera",
            opera_coast: "Opera Coast",
            phantomjs: "PhantomJS",
            puffin: "Puffin",
            qupzilla: "QupZilla",
            qq: "QQ Browser",
            qqlite: "QQ Browser Lite",
            safari: "Safari",
            sailfish: "Sailfish",
            samsung_internet: "Samsung Internet for Android",
            seamonkey: "SeaMonkey",
            sleipnir: "Sleipnir",
            swing: "Swing",
            tizen: "Tizen",
            uc: "UC Browser",
            vivaldi: "Vivaldi",
            webos: "WebOS Browser",
            wechat: "WeChat",
            yandex: "Yandex Browser"
        }, t.PLATFORMS_MAP = {
            tablet: "tablet",
            mobile: "mobile",
            desktop: "desktop",
            tv: "tv"
        }, t.OS_MAP = {
            WindowsPhone: "Windows Phone",
            Windows: "Windows",
            MacOS: "macOS",
            iOS: "iOS",
            Android: "Android",
            WebOS: "WebOS",
            BlackBerry: "BlackBerry",
            Bada: "Bada",
            Tizen: "Tizen",
            Linux: "Linux",
            ChromeOS: "Chrome OS",
            PlayStation4: "PlayStation 4",
            Roku: "Roku"
        }, t.ENGINE_MAP = {
            EdgeHTML: "EdgeHTML",
            Blink: "Blink",
            Trident: "Trident",
            Presto: "Presto",
            Gecko: "Gecko",
            WebKit: "WebKit"
        };
    },
    90: function(e, t, n) {
        t.__esModule = !0, t.default = void 0;
        var r, i = (r = n(91)) && r.__esModule ? r : {
            default: r
        }, o = n(18);
        function s(e, t) {
            for(var n = 0; n < t.length; n++){
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
            }
        }
        var a = function() {
            function e() {}
            var t, n, r;
            return e.getParser = function(e, t) {
                if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
                return new i.default(e, t);
            }, e.parse = function(e) {
                return new i.default(e).getResult();
            }, t = e, r = [
                {
                    key: "BROWSER_MAP",
                    get: function() {
                        return o.BROWSER_MAP;
                    }
                },
                {
                    key: "ENGINE_MAP",
                    get: function() {
                        return o.ENGINE_MAP;
                    }
                },
                {
                    key: "OS_MAP",
                    get: function() {
                        return o.OS_MAP;
                    }
                },
                {
                    key: "PLATFORMS_MAP",
                    get: function() {
                        return o.PLATFORMS_MAP;
                    }
                }
            ], (n = null) && s(t.prototype, n), r && s(t, r), e;
        }();
        t.default = a, e.exports = t.default;
    },
    91: function(e, t, n) {
        t.__esModule = !0, t.default = void 0;
        var r = c(n(92)), i = c(n(93)), o = c(n(94)), s = c(n(95)), a = c(n(17));
        function c(e) {
            return e && e.__esModule ? e : {
                default: e
            };
        }
        var l = function() {
            function e(e, t) {
                if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
                this._ua = e, this.parsedResult = {}, !0 !== t && this.parse();
            }
            var t = e.prototype;
            return t.getUA = function() {
                return this._ua;
            }, t.test = function(e) {
                return e.test(this._ua);
            }, t.parseBrowser = function() {
                var e = this;
                this.parsedResult.browser = {};
                var t = a.default.find(r.default, function(t) {
                    if ("function" == typeof t.test) return t.test(e);
                    if (t.test instanceof Array) return t.test.some(function(t) {
                        return e.test(t);
                    });
                    throw new Error("Browser's test function is not valid");
                });
                return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
            }, t.getBrowser = function() {
                return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
            }, t.getBrowserName = function(e) {
                return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
            }, t.getBrowserVersion = function() {
                return this.getBrowser().version;
            }, t.getOS = function() {
                return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
            }, t.parseOS = function() {
                var e = this;
                this.parsedResult.os = {};
                var t = a.default.find(i.default, function(t) {
                    if ("function" == typeof t.test) return t.test(e);
                    if (t.test instanceof Array) return t.test.some(function(t) {
                        return e.test(t);
                    });
                    throw new Error("Browser's test function is not valid");
                });
                return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
            }, t.getOSName = function(e) {
                var t = this.getOS().name;
                return e ? String(t).toLowerCase() || "" : t || "";
            }, t.getOSVersion = function() {
                return this.getOS().version;
            }, t.getPlatform = function() {
                return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
            }, t.getPlatformType = function(e) {
                void 0 === e && (e = !1);
                var t = this.getPlatform().type;
                return e ? String(t).toLowerCase() || "" : t || "";
            }, t.parsePlatform = function() {
                var e = this;
                this.parsedResult.platform = {};
                var t = a.default.find(o.default, function(t) {
                    if ("function" == typeof t.test) return t.test(e);
                    if (t.test instanceof Array) return t.test.some(function(t) {
                        return e.test(t);
                    });
                    throw new Error("Browser's test function is not valid");
                });
                return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
            }, t.getEngine = function() {
                return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
            }, t.getEngineName = function(e) {
                return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
            }, t.parseEngine = function() {
                var e = this;
                this.parsedResult.engine = {};
                var t = a.default.find(s.default, function(t) {
                    if ("function" == typeof t.test) return t.test(e);
                    if (t.test instanceof Array) return t.test.some(function(t) {
                        return e.test(t);
                    });
                    throw new Error("Browser's test function is not valid");
                });
                return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
            }, t.parse = function() {
                return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
            }, t.getResult = function() {
                return a.default.assign({}, this.parsedResult);
            }, t.satisfies = function(e) {
                var t = this, n = {}, r = 0, i = {}, o = 0;
                if (Object.keys(e).forEach(function(t) {
                    var s = e[t];
                    "string" == typeof s ? (i[t] = s, o += 1) : "object" == typeof s && (n[t] = s, r += 1);
                }), r > 0) {
                    var s = Object.keys(n), c = a.default.find(s, function(e) {
                        return t.isOS(e);
                    });
                    if (c) {
                        var l = this.satisfies(n[c]);
                        if (void 0 !== l) return l;
                    }
                    var d = a.default.find(s, function(e) {
                        return t.isPlatform(e);
                    });
                    if (d) {
                        var u = this.satisfies(n[d]);
                        if (void 0 !== u) return u;
                    }
                }
                if (o > 0) {
                    var h = Object.keys(i), f = a.default.find(h, function(e) {
                        return t.isBrowser(e, !0);
                    });
                    if (void 0 !== f) return this.compareVersion(i[f]);
                }
            }, t.isBrowser = function(e, t) {
                void 0 === t && (t = !1);
                var n = this.getBrowserName().toLowerCase(), r = e.toLowerCase(), i = a.default.getBrowserTypeByAlias(r);
                return t && i && (r = i.toLowerCase()), r === n;
            }, t.compareVersion = function(e) {
                var t = [
                    0
                ], n = e, r = !1, i = this.getBrowserVersion();
                if ("string" == typeof i) return ">" === e[0] || "<" === e[0] ? (n = e.substr(1), "=" === e[1] ? (r = !0, n = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? n = e.substr(1) : "~" === e[0] && (r = !0, n = e.substr(1)), t.indexOf(a.default.compareVersions(i, n, r)) > -1;
            }, t.isOS = function(e) {
                return this.getOSName(!0) === String(e).toLowerCase();
            }, t.isPlatform = function(e) {
                return this.getPlatformType(!0) === String(e).toLowerCase();
            }, t.isEngine = function(e) {
                return this.getEngineName(!0) === String(e).toLowerCase();
            }, t.is = function(e, t) {
                return void 0 === t && (t = !1), this.isBrowser(e, t) || this.isOS(e) || this.isPlatform(e);
            }, t.some = function(e) {
                var t = this;
                return void 0 === e && (e = []), e.some(function(e) {
                    return t.is(e);
                });
            }, e;
        }();
        t.default = l, e.exports = t.default;
    },
    92: function(e, t, n) {
        t.__esModule = !0, t.default = void 0;
        var r, i = (r = n(17)) && r.__esModule ? r : {
            default: r
        }, o = /version\/(\d+(\.?_?\d+)+)/i, s = [
            {
                test: [
                    /googlebot/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Googlebot"
                    }, n = i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /opera/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Opera"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /opr\/|opios/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Opera"
                    }, n = i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /SamsungBrowser/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Samsung Internet for Android"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /Whale/i
                ],
                describe: function(e) {
                    var t = {
                        name: "NAVER Whale Browser"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /MZBrowser/i
                ],
                describe: function(e) {
                    var t = {
                        name: "MZ Browser"
                    }, n = i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /focus/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Focus"
                    }, n = i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /swing/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Swing"
                    }, n = i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /coast/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Opera Coast"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /opt\/\d+(?:.?_?\d+)+/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Opera Touch"
                    }, n = i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /yabrowser/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Yandex Browser"
                    }, n = i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /ucbrowser/i
                ],
                describe: function(e) {
                    var t = {
                        name: "UC Browser"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /Maxthon|mxios/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Maxthon"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /epiphany/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Epiphany"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /puffin/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Puffin"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /sleipnir/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Sleipnir"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /k-meleon/i
                ],
                describe: function(e) {
                    var t = {
                        name: "K-Meleon"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /micromessenger/i
                ],
                describe: function(e) {
                    var t = {
                        name: "WeChat"
                    }, n = i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /qqbrowser/i
                ],
                describe: function(e) {
                    var t = {
                        name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
                    }, n = i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /msie|trident/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Internet Explorer"
                    }, n = i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /\sedg\//i
                ],
                describe: function(e) {
                    var t = {
                        name: "Microsoft Edge"
                    }, n = i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /edg([ea]|ios)/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Microsoft Edge"
                    }, n = i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /vivaldi/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Vivaldi"
                    }, n = i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /seamonkey/i
                ],
                describe: function(e) {
                    var t = {
                        name: "SeaMonkey"
                    }, n = i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /sailfish/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Sailfish"
                    }, n = i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /silk/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Amazon Silk"
                    }, n = i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /phantom/i
                ],
                describe: function(e) {
                    var t = {
                        name: "PhantomJS"
                    }, n = i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /slimerjs/i
                ],
                describe: function(e) {
                    var t = {
                        name: "SlimerJS"
                    }, n = i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /blackberry|\bbb\d+/i,
                    /rim\stablet/i
                ],
                describe: function(e) {
                    var t = {
                        name: "BlackBerry"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /(web|hpw)[o0]s/i
                ],
                describe: function(e) {
                    var t = {
                        name: "WebOS Browser"
                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /bada/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Bada"
                    }, n = i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /tizen/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Tizen"
                    }, n = i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /qupzilla/i
                ],
                describe: function(e) {
                    var t = {
                        name: "QupZilla"
                    }, n = i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /firefox|iceweasel|fxios/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Firefox"
                    }, n = i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /electron/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Electron"
                    }, n = i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /MiuiBrowser/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Miui"
                    }, n = i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /chromium/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Chromium"
                    }, n = i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /chrome|crios|crmo/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Chrome"
                    }, n = i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /GSA/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Google Search"
                    }, n = i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: function(e) {
                    var t = !e.test(/like android/i), n = e.test(/android/i);
                    return t && n;
                },
                describe: function(e) {
                    var t = {
                        name: "Android Browser"
                    }, n = i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /playstation 4/i
                ],
                describe: function(e) {
                    var t = {
                        name: "PlayStation 4"
                    }, n = i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /safari|applewebkit/i
                ],
                describe: function(e) {
                    var t = {
                        name: "Safari"
                    }, n = i.default.getFirstMatch(o, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /.*/i
                ],
                describe: function(e) {
                    var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
                    return {
                        name: i.default.getFirstMatch(t, e),
                        version: i.default.getSecondMatch(t, e)
                    };
                }
            }
        ];
        t.default = s, e.exports = t.default;
    },
    93: function(e, t, n) {
        t.__esModule = !0, t.default = void 0;
        var r, i = (r = n(17)) && r.__esModule ? r : {
            default: r
        }, o = n(18), s = [
            {
                test: [
                    /Roku\/DVP/
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
                    return {
                        name: o.OS_MAP.Roku,
                        version: t
                    };
                }
            },
            {
                test: [
                    /windows phone/i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
                    return {
                        name: o.OS_MAP.WindowsPhone,
                        version: t
                    };
                }
            },
            {
                test: [
                    /windows /i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e), n = i.default.getWindowsVersionName(t);
                    return {
                        name: o.OS_MAP.Windows,
                        version: t,
                        versionName: n
                    };
                }
            },
            {
                test: [
                    /Macintosh(.*?) FxiOS(.*?)\//
                ],
                describe: function(e) {
                    var t = {
                        name: o.OS_MAP.iOS
                    }, n = i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /macintosh/i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."), n = i.default.getMacOSVersionName(t), r = {
                        name: o.OS_MAP.MacOS,
                        version: t
                    };
                    return n && (r.versionName = n), r;
                }
            },
            {
                test: [
                    /(ipod|iphone|ipad)/i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
                    return {
                        name: o.OS_MAP.iOS,
                        version: t
                    };
                }
            },
            {
                test: function(e) {
                    var t = !e.test(/like android/i), n = e.test(/android/i);
                    return t && n;
                },
                describe: function(e) {
                    var t = i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e), n = i.default.getAndroidVersionName(t), r = {
                        name: o.OS_MAP.Android,
                        version: t
                    };
                    return n && (r.versionName = n), r;
                }
            },
            {
                test: [
                    /(web|hpw)[o0]s/i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e), n = {
                        name: o.OS_MAP.WebOS
                    };
                    return t && t.length && (n.version = t), n;
                }
            },
            {
                test: [
                    /blackberry|\bbb\d+/i,
                    /rim\stablet/i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || i.default.getFirstMatch(/\bbb(\d+)/i, e);
                    return {
                        name: o.OS_MAP.BlackBerry,
                        version: t
                    };
                }
            },
            {
                test: [
                    /bada/i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
                    return {
                        name: o.OS_MAP.Bada,
                        version: t
                    };
                }
            },
            {
                test: [
                    /tizen/i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
                    return {
                        name: o.OS_MAP.Tizen,
                        version: t
                    };
                }
            },
            {
                test: [
                    /linux/i
                ],
                describe: function() {
                    return {
                        name: o.OS_MAP.Linux
                    };
                }
            },
            {
                test: [
                    /CrOS/
                ],
                describe: function() {
                    return {
                        name: o.OS_MAP.ChromeOS
                    };
                }
            },
            {
                test: [
                    /PlayStation 4/
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
                    return {
                        name: o.OS_MAP.PlayStation4,
                        version: t
                    };
                }
            }
        ];
        t.default = s, e.exports = t.default;
    },
    94: function(e, t, n) {
        t.__esModule = !0, t.default = void 0;
        var r, i = (r = n(17)) && r.__esModule ? r : {
            default: r
        }, o = n(18), s = [
            {
                test: [
                    /googlebot/i
                ],
                describe: function() {
                    return {
                        type: "bot",
                        vendor: "Google"
                    };
                }
            },
            {
                test: [
                    /huawei/i
                ],
                describe: function(e) {
                    var t = i.default.getFirstMatch(/(can-l01)/i, e) && "Nova", n = {
                        type: o.PLATFORMS_MAP.mobile,
                        vendor: "Huawei"
                    };
                    return t && (n.model = t), n;
                }
            },
            {
                test: [
                    /nexus\s*(?:7|8|9|10).*/i
                ],
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tablet,
                        vendor: "Nexus"
                    };
                }
            },
            {
                test: [
                    /ipad/i
                ],
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tablet,
                        vendor: "Apple",
                        model: "iPad"
                    };
                }
            },
            {
                test: [
                    /Macintosh(.*?) FxiOS(.*?)\//
                ],
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tablet,
                        vendor: "Apple",
                        model: "iPad"
                    };
                }
            },
            {
                test: [
                    /kftt build/i
                ],
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tablet,
                        vendor: "Amazon",
                        model: "Kindle Fire HD 7"
                    };
                }
            },
            {
                test: [
                    /silk/i
                ],
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tablet,
                        vendor: "Amazon"
                    };
                }
            },
            {
                test: [
                    /tablet(?! pc)/i
                ],
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tablet
                    };
                }
            },
            {
                test: function(e) {
                    var t = e.test(/ipod|iphone/i), n = e.test(/like (ipod|iphone)/i);
                    return t && !n;
                },
                describe: function(e) {
                    var t = i.default.getFirstMatch(/(ipod|iphone)/i, e);
                    return {
                        type: o.PLATFORMS_MAP.mobile,
                        vendor: "Apple",
                        model: t
                    };
                }
            },
            {
                test: [
                    /nexus\s*[0-6].*/i,
                    /galaxy nexus/i
                ],
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.mobile,
                        vendor: "Nexus"
                    };
                }
            },
            {
                test: [
                    /[^-]mobi/i
                ],
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.mobile
                    };
                }
            },
            {
                test: function(e) {
                    return "blackberry" === e.getBrowserName(!0);
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.mobile,
                        vendor: "BlackBerry"
                    };
                }
            },
            {
                test: function(e) {
                    return "bada" === e.getBrowserName(!0);
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.mobile
                    };
                }
            },
            {
                test: function(e) {
                    return "windows phone" === e.getBrowserName();
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.mobile,
                        vendor: "Microsoft"
                    };
                }
            },
            {
                test: function(e) {
                    var t = Number(String(e.getOSVersion()).split(".")[0]);
                    return "android" === e.getOSName(!0) && t >= 3;
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tablet
                    };
                }
            },
            {
                test: function(e) {
                    return "android" === e.getOSName(!0);
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.mobile
                    };
                }
            },
            {
                test: function(e) {
                    return "macos" === e.getOSName(!0);
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.desktop,
                        vendor: "Apple"
                    };
                }
            },
            {
                test: function(e) {
                    return "windows" === e.getOSName(!0);
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.desktop
                    };
                }
            },
            {
                test: function(e) {
                    return "linux" === e.getOSName(!0);
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.desktop
                    };
                }
            },
            {
                test: function(e) {
                    return "playstation 4" === e.getOSName(!0);
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tv
                    };
                }
            },
            {
                test: function(e) {
                    return "roku" === e.getOSName(!0);
                },
                describe: function() {
                    return {
                        type: o.PLATFORMS_MAP.tv
                    };
                }
            }
        ];
        t.default = s, e.exports = t.default;
    },
    95: function(e, t, n) {
        t.__esModule = !0, t.default = void 0;
        var r, i = (r = n(17)) && r.__esModule ? r : {
            default: r
        }, o = n(18), s = [
            {
                test: function(e) {
                    return "microsoft edge" === e.getBrowserName(!0);
                },
                describe: function(e) {
                    if (/\sedg\//i.test(e)) return {
                        name: o.ENGINE_MAP.Blink
                    };
                    var t = i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
                    return {
                        name: o.ENGINE_MAP.EdgeHTML,
                        version: t
                    };
                }
            },
            {
                test: [
                    /trident/i
                ],
                describe: function(e) {
                    var t = {
                        name: o.ENGINE_MAP.Trident
                    }, n = i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: function(e) {
                    return e.test(/presto/i);
                },
                describe: function(e) {
                    var t = {
                        name: o.ENGINE_MAP.Presto
                    }, n = i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: function(e) {
                    var t = e.test(/gecko/i), n = e.test(/like gecko/i);
                    return t && !n;
                },
                describe: function(e) {
                    var t = {
                        name: o.ENGINE_MAP.Gecko
                    }, n = i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            },
            {
                test: [
                    /(apple)?webkit\/537\.36/i
                ],
                describe: function() {
                    return {
                        name: o.ENGINE_MAP.Blink
                    };
                }
            },
            {
                test: [
                    /(apple)?webkit/i
                ],
                describe: function(e) {
                    var t = {
                        name: o.ENGINE_MAP.WebKit
                    }, n = i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
                    return n && (t.version = n), t;
                }
            }
        ];
        t.default = s, e.exports = t.default;
    }
});
var Fu = ue(Hu.exports);
const zu = {
    Initialized: "initialized",
    DisplayURI: "display_uri",
    ProviderUpdate: "provider_update",
    ConnectWithResponse: "connectWithResponse",
    ConnectionStatus: "connection_status",
    ServiceStatus: "service_status"
};
class qu {
    constructor({ shouldSetOnWindow: e, connectionStream: t, shouldSendMetadata: n = !1, shouldShimWeb3: r, sdkInstance: i }){
        const o = new Gu({
            connectionStream: t,
            shouldSendMetadata: n,
            shouldSetOnWindow: e,
            shouldShimWeb3: r,
            autoRequestAccounts: !1
        }), s = new Proxy(o, {
            deleteProperty: ()=>!0
        });
        if (this.provider = s, this.sdkInstance = i, e && "undefined" != ("TURBOPACK compile-time value", "undefined")) try {
            a = o, window.ethereum = a, window.dispatchEvent(new Event("ethereum#initialized"));
        } catch (e) {
            Au("[Ethereum] Unable to set global provider - window.ethereum may be read-only", e);
        }
        var a;
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        this.provider.on("display_uri", (e)=>{
            this.sdkInstance.emit(zu.DisplayURI, e);
        }), this.provider.on("_initialized", ()=>{
            const e = {
                chainId: this.provider.getChainId(),
                isConnected: this.provider.isConnected(),
                isMetaMask: this.provider.isMetaMask,
                selectedAddress: this.provider.getSelectedAddress(),
                networkVersion: this.provider.getNetworkVersion()
            };
            this.sdkInstance.emit(zu.Initialized, e), Au("[Ethereum: constructor()] provider initialized", e);
        });
    }
    static init(e) {
        var t;
        return Au("[Ethereum: init()] Initializing Ethereum service"), this.instance = new qu(e), null === (t = this.instance) || void 0 === t ? void 0 : t.provider;
    }
    static destroy() {}
    static getInstance() {
        var e;
        if (!(null === (e = this.instance) || void 0 === e ? void 0 : e.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
        return this.instance;
    }
    static getProvider() {
        var e;
        if (!(null === (e = this.instance) || void 0 === e ? void 0 : e.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
        return this.instance.provider;
    }
}
class Wu {
    constructor({ useDeepLink: e, preferredOpenLink: t, debug: n = !1 }){
        this.state = {
            platformType: void 0,
            useDeeplink: !1,
            preferredOpenLink: void 0,
            debug: !1
        }, this.state.platformType = this.getPlatformType(), this.state.useDeeplink = e, this.state.preferredOpenLink = t, this.state.debug = n;
    }
    openDeeplink(e, t, n) {
        return function(e, t, n, r) {
            const { state: i } = e;
            Au(`[PlatfformManager: openDeeplink()] universalLink --\x3e ${t}`), Au(`[PlatfformManager: openDeeplink()] deepLink --\x3e ${n}`);
            try {
                if (i.preferredOpenLink) return void i.preferredOpenLink(i.useDeeplink ? n : t, r);
                if (Au(`[PlatfformManager: openDeeplink()] open link now useDeepLink=${i.useDeeplink} link=${i.useDeeplink ? n : t}`), i.useDeeplink) "undefined" != ("TURBOPACK compile-time value", "undefined") && (window.location.href = n);
                else if ("undefined" != typeof document) {
                    const e = document.createElement("a");
                    e.href = t, e.target = "_self", e.rel = "noreferrer noopener", e.click();
                }
            } catch (e) {
                console.log("[PlatfformManager: openDeeplink()] can't open link", e);
            }
        }(this, e, t, n);
    }
    isReactNative() {
        var e;
        return this.isNotBrowser() && "undefined" != ("TURBOPACK compile-time value", "undefined") && (null === window || void 0 === window ? void 0 : window.navigator) && "ReactNative" === (null === (e = window.navigator) || void 0 === e ? void 0 : e.product);
    }
    isMetaMaskInstalled() {
        return function() {
            const e = qu.getProvider() || (null === window || void 0 === window ? void 0 : window.ethereum);
            return Au(`[PlatfformManager: isMetaMaskInstalled()] isMetaMask=${null == e ? void 0 : e.isMetaMask} isConnected=${null == e ? void 0 : e.isConnected()}`), (null == e ? void 0 : e.isMetaMask) && (null == e ? void 0 : e.isConnected());
        }();
    }
    isDesktopWeb() {
        return this.isBrowser() && !this.isMobileWeb();
    }
    isMobile() {
        var e, t;
        const n = Fu.parse(window.navigator.userAgent);
        return "mobile" === (null === (e = null == n ? void 0 : n.platform) || void 0 === e ? void 0 : e.type) || "tablet" === (null === (t = null == n ? void 0 : n.platform) || void 0 === t ? void 0 : t.type);
    }
    isSecure() {
        return this.isReactNative() || this.isMobileWeb();
    }
    isMetaMaskMobileWebView() {
        return "undefined" != ("TURBOPACK compile-time value", "undefined") && Boolean(window.ReactNativeWebView) && Boolean(navigator.userAgent.endsWith("MetaMaskMobile"));
    }
    isMobileWeb() {
        return this.state.platformType === Uo.MobileWeb;
    }
    static isNotBrowser() {
        var e;
        return "undefined" == ("TURBOPACK compile-time value", "undefined") || !(null === window || void 0 === window ? void 0 : window.navigator) || void 0 !== l && "ReactNative" === (null === (e = null == l ? void 0 : l.navigator) || void 0 === e ? void 0 : e.product) || "ReactNative" === (null === navigator || void 0 === navigator ? void 0 : navigator.product);
    }
    isNotBrowser() {
        return Wu.isNotBrowser();
    }
    static isBrowser() {
        return !this.isNotBrowser();
    }
    isBrowser() {
        return Wu.isBrowser();
    }
    isNodeJS() {
        return this.isNotBrowser() && !this.isReactNative();
    }
    isUseDeepLink() {
        return this.state.useDeeplink;
    }
    getPlatformType() {
        return function(e) {
            const { state: t } = e;
            return t.platformType ? t.platformType : e.isReactNative() ? Uo.ReactNative : e.isNotBrowser() ? Uo.NonBrowser : e.isMetaMaskMobileWebView() ? Uo.MetaMaskMobileWebview : e.isMobile() ? Uo.MobileWeb : Uo.DesktopWeb;
        }(this);
    }
}
const Vu = (e)=>c(void 0, void 0, void 0, function*() {
        if (Wu.isBrowser()) {
            const { StorageManagerWeb: t } = yield Promise.resolve().then(function() {
                return of;
            });
            return new t(e);
        }
        const t = {
            persistChannelConfig: ()=>c(void 0, void 0, void 0, function*() {}),
            getPersistedChannelConfig: ()=>c(void 0, void 0, void 0, function*() {}),
            persistAccounts: ()=>c(void 0, void 0, void 0, function*() {}),
            getCachedAccounts: ()=>c(void 0, void 0, void 0, function*() {
                    return [];
                }),
            persistChainId: ()=>c(void 0, void 0, void 0, function*() {}),
            getCachedChainId: ()=>c(void 0, void 0, void 0, function*() {}),
            terminate: ()=>c(void 0, void 0, void 0, function*() {})
        };
        return Promise.resolve(t);
    });
class Gu extends ku {
    constructor({ connectionStream: e, shouldSendMetadata: t, autoRequestAccounts: n = !1 }){
        super(e, {
            logger: console,
            maxEventListeners: 100,
            shouldSendMetadata: t
        }), this.state = {
            accounts: null,
            autoRequestAccounts: !1,
            providerStateRequested: !1,
            chainId: "",
            networkVersion: ""
        }, Au(`[SDKProvider: constructor()] autoRequestAccounts=${n}`), this.state.autoRequestAccounts = n;
    }
    forceInitializeState() {
        return c(this, void 0, void 0, function*() {
            return Au(`[SDKProvider: forceInitializeState()] autoRequestAccounts=${this.state.autoRequestAccounts}`), this._initializeStateAsync();
        });
    }
    _setConnected() {
        Au("[SDKProvider: _setConnected()] Setting connected state"), this._state.isConnected = !0;
    }
    getState() {
        return this._state;
    }
    getSDKProviderState() {
        return this.state;
    }
    getSelectedAddress() {
        var e;
        const { accounts: t } = this._state;
        return t && 0 !== t.length ? (null === (e = t[0]) || void 0 === e ? void 0 : e.toLowerCase()) || "" : (Au("[SDKProvider: getSelectedAddress] No accounts found"), null);
    }
    getChainId() {
        return this.state.chainId;
    }
    getNetworkVersion() {
        return this.state.networkVersion;
    }
    setSDKProviderState(e) {
        this.state = Object.assign(Object.assign({}, this.state), e);
    }
    handleAccountsChanged(e, t) {
        return this._handleAccountsChanged(e, t);
    }
    handleDisconnect({ terminate: e = !1 }) {
        !function({ terminate: e = !1, instance: t }) {
            const { state: n } = t;
            Au(`[SDKProvider: handleDisconnect()] cleaning up provider state terminate=${e}`, t), e && (t._state.accounts = null, t._state.isUnlocked = !1, t._state.isPermanentlyDisconnected = !0, t._state.initialized = !1), t._handleAccountsChanged([]), t._state.isConnected = !1, t.emit("disconnect", Mu.ethErrors.provider.disconnected()), n.providerStateRequested = !1;
        }({
            terminate: e,
            instance: this
        });
    }
    _initializeStateAsync() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                var t, n;
                return c(this, void 0, void 0, function*() {
                    void 0 === e.state && (e.state = {
                        accounts: null,
                        autoRequestAccounts: !1,
                        providerStateRequested: !1,
                        chainId: ""
                    });
                    const { state: r } = e;
                    let i;
                    if (r.providerStateRequested) Au("[SDKProvider: initializeStateAsync()] initialization already in progress");
                    else {
                        let o;
                        r.providerStateRequested = !0;
                        let s = null, a = !1, c = !1;
                        const l = yield Vu({
                            enabled: !0
                        });
                        if (l) {
                            const e = yield l.getPersistedChannelConfig({});
                            a = null !== (t = null == e ? void 0 : e.relayPersistence) && void 0 !== t && t, o = yield l.getCachedChainId();
                            const n = yield l.getCachedAccounts();
                            n.length > 0 && (s = n[0]);
                        }
                        if (Au(`[SDKProvider: initializeStateAsync()] relayPersistence=${a}`, {
                            relayPersistence: a,
                            cachedChainId: o,
                            cachedSelectedAddress: s
                        }), a) if (o && s) i = {
                            accounts: [
                                s
                            ],
                            chainId: o,
                            isUnlocked: !1
                        }, c = !0;
                        else try {
                            i = yield e.request({
                                method: "metamask_getProviderState"
                            });
                        } catch (t) {
                            return e._log.error("MetaMask: Failed to get initial state. Please report this bug.", t), void (r.providerStateRequested = !1);
                        }
                        if (0 === (null === (n = null == i ? void 0 : i.accounts) || void 0 === n ? void 0 : n.length)) if (e.getSelectedAddress()) i.accounts = [
                            e.getSelectedAddress()
                        ];
                        else {
                            Au("[SDKProvider: initializeStateAsync()] Fetch accounts remotely.");
                            const t = yield e.request({
                                method: "eth_requestAccounts",
                                params: []
                            });
                            i.accounts = t;
                        }
                        e._initializeState(i), r.providerStateRequested = !1, c && (e._state.isConnected = !0, e.emit("connect", {
                            chainId: null == i ? void 0 : i.chainId
                        }));
                    }
                });
            }(this);
        });
    }
    _initializeState(e) {
        return Au("[SDKProvider: _initializeState()]", e), function(e, t, n) {
            return Au("[SDKProvider: initializeState()] set state._initialized to false"), e._state.initialized = !1, t(n);
        }(this, super._initializeState.bind(this), e);
    }
    _handleChainChanged({ chainId: e, networkVersion: t } = {}) {
        this.state.chainId = e, this.state.networkVersion = t, function({ instance: e, chainId: t, networkVersion: r, superHandleChainChanged: i }) {
            Au(`[SDKProvider: handleChainChanged()] chainId=${t} networkVersion=${r}`);
            let o = r;
            r || (Au("[SDKProvider: handleChainChanged()] forced network version to prevent provider error"), o = "1"), t !== xu && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_used_chain", {
                caip_chain_id: `eip155:${parseInt(null != t ? t : "0x1", 16)}`
            }), xu = t), e._state.isConnected = !0, e.emit("connect", {
                chainId: t
            }), i({
                chainId: t,
                networkVersion: o
            });
        }({
            instance: this,
            chainId: e,
            networkVersion: t,
            superHandleChainChanged: super._handleChainChanged.bind(this)
        });
    }
}
var Yu, Zu = {
    name: "@metamask/sdk",
    version: "0.33.1",
    description: "",
    homepage: "https://github.com/MetaMask/metamask-sdk#readme",
    bugs: {
        url: "https://github.com/MetaMask/metamask-sdk/issues"
    },
    repository: {
        type: "git",
        url: "https://github.com/MetaMask/metamask-sdk",
        directory: "packages/sdk"
    },
    main: "dist/node/cjs/metamask-sdk.js",
    module: "dist/browser/es/metamask-sdk.js",
    browser: "dist/browser/es/metamask-sdk.js",
    unpkg: "dist/browser/umd/metamask-sdk.js",
    "react-native": "dist/react-native/es/metamask-sdk.js",
    types: "dist/types/src/index.d.ts",
    sideEffects: !1,
    files: [
        "/dist"
    ],
    scripts: {
        "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types",
        build: "yarn build:types && rollup -c --bundleConfigAsCjs",
        "build:clean": "yarn clean && yarn build",
        "build:post-tsc": "echo 'N/A'",
        "build:pre-tsc": "echo 'N/A'",
        typecheck: "tsc --noEmit",
        clean: "rimraf ./dist",
        size: "node bundle-size && size-limit",
        lint: "yarn lint:eslint && yarn lint:misc --check",
        "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk",
        "lint:eslint": "eslint . --cache --ext js,ts",
        "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write",
        "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore",
        prepack: "../../scripts/prepack.sh",
        "publish:preview": "yarn npm publish --tag preview",
        reset: "yarn clean && rimraf ./node_modules/",
        test: 'jest --testPathIgnorePatterns "/e2e/"',
        "test:coverage": 'jest --coverage --testPathIgnorePatterns "/e2e/"',
        "test:e2e": 'jest --testPathPattern "/e2e/"',
        "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"',
        "test:dev": 'jest -c ./jest.config.ts --detectOpenHandles  --testPathIgnorePatterns "/e2e/"',
        watch: "rollup -c -w",
        dev: 'concurrently "tsc --watch" "rollup -c -w --bundleConfigAsCjs"',
        "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs"
    },
    dependencies: {
        "@babel/runtime": "^7.26.0",
        "@metamask/onboarding": "^1.0.1",
        "@metamask/providers": "16.1.0",
        "@metamask/sdk-analytics": "workspace:*",
        "@metamask/sdk-communication-layer": "workspace:*",
        "@metamask/sdk-install-modal-web": "workspace:*",
        "@paulmillr/qr": "^0.2.1",
        bowser: "^2.9.0",
        "cross-fetch": "^4.0.0",
        debug: "4.3.4",
        eciesjs: "^0.4.11",
        "eth-rpc-errors": "^4.0.3",
        eventemitter2: "^6.4.9",
        "obj-multiplex": "^1.0.0",
        pump: "^3.0.0",
        "readable-stream": "^3.6.2",
        "socket.io-client": "^4.5.1",
        tslib: "^2.6.0",
        util: "^0.12.4",
        uuid: "^8.3.2"
    },
    devDependencies: {
        "@jest/globals": "^29.3.1",
        "@lavamoat/allow-scripts": "^2.3.1",
        "@metamask/auto-changelog": "3.1.0",
        "@metamask/eslint-config": "^6.0.0",
        "@metamask/eslint-config-nodejs": "^6.0.0",
        "@metamask/eslint-config-typescript": "^6.0.0",
        "@react-native-async-storage/async-storage": "^1.19.6",
        "@rollup/plugin-alias": "^5.1.1",
        "@rollup/plugin-commonjs": "^25.0.7",
        "@rollup/plugin-json": "^6.0.0",
        "@rollup/plugin-node-resolve": "^15.0.2",
        "@rollup/plugin-replace": "^6.0.1",
        "@rollup/plugin-terser": "^0.4.1",
        "@size-limit/preset-big-lib": "^11.0.2",
        "@types/dom-screen-wake-lock": "^1.0.2",
        "@types/node": "^20.1.3",
        "@types/pump": "^1.1.1",
        "@types/qrcode-terminal": "^0.12.0",
        "@types/uuid": "^10.0.0",
        "@typescript-eslint/eslint-plugin": "^4.26.0",
        "@typescript-eslint/parser": "^4.26.0",
        "browserify-zlib": "^0.2.0",
        buffer: "^6.0.3",
        concurrently: "^9.1.2",
        "crypto-browserify": "^3.12.0",
        eslint: "^7.30.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.23.4",
        "eslint-plugin-jest": "^24.4.0",
        "eslint-plugin-jsdoc": "^36.1.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^3.4.0",
        "https-browserify": "^1.0.0",
        jest: "^29.3.1",
        "jest-environment-jsdom": "^29.3.1",
        prettier: "^2.3.0",
        process: "^0.11.10",
        rimraf: "^4.4.0",
        rollup: "^4.26.0",
        "rollup-plugin-analyzer": "^4.0.0",
        "rollup-plugin-jscc": "^2.0.0",
        "rollup-plugin-natives": "^0.7.5",
        "rollup-plugin-node-builtins": "^2.1.2",
        "rollup-plugin-polyfill-node": "^0.13.0",
        "rollup-plugin-sizes": "^1.0.6",
        "rollup-plugin-typescript2": "^0.31.2",
        "rollup-plugin-visualizer": "^5.12.0",
        "size-limit": "^11.0.2",
        "stream-browserify": "^3.0.0",
        "stream-http": "^3.2.0",
        "ts-jest": "^29.0.3",
        "ts-node": "^10.9.1",
        typescript: "^4.3.2",
        url: "^0.11.0",
        webpack: "^5.0.0"
    },
    publishConfig: {
        access: "public",
        registry: "https://registry.npmjs.org/"
    },
    lavamoat: {
        allowScripts: {
            "eciesjs>secp256k1": !1,
            "socket.io-client>engine.io-client>ws>bufferutil": !1,
            "socket.io-client>engine.io-client>ws>utf-8-validate": !1,
            "@metamask/sdk-communication-layer>bufferutil": !1,
            "@metamask/sdk-communication-layer>eciesjs>secp256k1": !1,
            "@metamask/sdk-communication-layer>utf-8-validate": !1
        }
    }
};
!function(e) {
    e.INPAGE = "metamask-inpage", e.CONTENT_SCRIPT = "metamask-contentscript", e.PROVIDER = "metamask-provider";
}(Yu || (Yu = {}));
const Ju = "direct", Qu = "https://metamask.app.link/connect", Xu = "metamask://connect", eh = {
    NAME: "MetaMask",
    RDNS: [
        "io.metamask",
        "io.metamask.flask"
    ]
}, th = /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u, nh = {
    METAMASK_GETPROVIDERSTATE: "metamask_getProviderState",
    METAMASK_CONNECTSIGN: "metamask_connectSign",
    METAMASK_CONNECTWITH: "metamask_connectWith",
    METAMASK_OPEN: "metamask_open",
    METAMASK_BATCH: "metamask_batch",
    PERSONAL_SIGN: "personal_sign",
    WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions",
    WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions",
    WALLET_GETPERMISSIONS: "wallet_getPermissions",
    WALLET_WATCHASSET: "wallet_watchAsset",
    WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain",
    WALLET_SWITCHETHETHEREUMCHAIN: "wallet_switchEthereumChain",
    ETH_REQUESTACCOUNTS: "eth_requestAccounts",
    ETH_ACCOUNTS: "eth_accounts",
    ETH_CHAINID: "eth_chainId",
    ETH_SENDTRANSACTION: "eth_sendTransaction",
    ETH_SIGNTYPEDDATA: "eth_signTypedData",
    ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3",
    ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4",
    ETH_SIGNTRANSACTION: "eth_signTransaction",
    ETH_SIGN: "eth_sign",
    PERSONAL_EC_RECOVER: "personal_ecRecover"
}, rh = {
    [nh.ETH_REQUESTACCOUNTS]: !0,
    [nh.ETH_SENDTRANSACTION]: !0,
    [nh.ETH_SIGNTRANSACTION]: !0,
    [nh.ETH_SIGN]: !0,
    [nh.PERSONAL_SIGN]: !0,
    [nh.ETH_ACCOUNTS]: !1,
    [nh.ETH_CHAINID]: !1,
    [nh.PERSONAL_SIGN]: !0,
    [nh.ETH_SIGNTYPEDDATA]: !0,
    [nh.ETH_SIGNTYPEDDATA_V3]: !0,
    [nh.ETH_SIGNTYPEDDATA_V4]: !0,
    [nh.WALLET_REQUESTPERMISSIONS]: !0,
    [nh.WALLET_GETPERMISSIONS]: !0,
    [nh.WALLET_WATCHASSET]: !0,
    [nh.WALLET_ADDETHEREUMCHAIN]: !0,
    [nh.WALLET_SWITCHETHETHEREUMCHAIN]: !0,
    [nh.METAMASK_CONNECTSIGN]: !0,
    [nh.METAMASK_CONNECTWITH]: !0,
    [nh.PERSONAL_EC_RECOVER]: !0,
    [nh.METAMASK_BATCH]: !0,
    [nh.METAMASK_OPEN]: !0
}, ih = Object.keys(rh).filter((e)=>!0 === rh[e]).map((e)=>e.toLowerCase()), oh = [
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sign"
].map((e)=>e.toLowerCase()), sh = ".sdk-comm", ah = "providerType", ch = ".MMSDK_cached_address", lh = ".MMSDK_cached_chainId", dh = {
    CHAIN_CHANGED: "chainChanged",
    ACCOUNTS_CHANGED: "accountsChanged",
    DISCONNECT: "disconnect",
    CONNECT: "connect",
    CONNECTED: "connected"
}, uh = 1e6;
var hh;
!function(e) {
    e.TERMINATE = "terminate", e.EXTENSION = "extension", e.INITIALIZED = "initialized";
}(hh || (hh = {}));
const fh = "undefined" != ("TURBOPACK compile-time value", "undefined") && window.localStorage;
function ph({ instance: e, msg: t }) {
    return c(this, void 0, void 0, function*() {
        if (e._initialized || (Au("[MetaMaskSDK: connectAndSign()] provider not ready -- wait for init()"), yield e.init()), Au(`[MetaMaskSDK: connectAndSign()] activeProvider=${e.activeProvider}`), !e.activeProvider) throw new Error("SDK state invalid -- undefined provider");
        const n = /^0x([0-9A-Fa-f]{2})*$/u.test(t) ? t : function(e) {
            let t;
            if (void 0 !== C) t = C.from(e, "utf8").toString("hex");
            else if ("undefined" != typeof TextEncoder) {
                const n = (new TextEncoder).encode(e);
                t = Array.from(n).map((e)=>e.toString(16).padStart(2, "0")).join("");
            } else {
                if ("object" != ("TURBOPACK compile-time value", "object") || !("Buffer" in l)) throw new Error("Unable to convert string to hex: No available method.");
                t = l.Buffer.from(e, "utf8").toString("hex");
            }
            return `0x${t}`;
        }(t);
        return e.activeProvider.request({
            method: nh.METAMASK_CONNECTWITH,
            params: [
                {
                    method: nh.PERSONAL_SIGN,
                    params: [
                        n
                    ]
                }
            ]
        });
    });
}
function gh(e) {
    var t, n;
    return c(this, void 0, void 0, function*() {
        Au("[MetaMaskSDK: connectWithExtensionProvider()] ", e), e.sdkProvider = e.activeProvider, e.activeProvider = window.extension, window.ethereum = window.extension;
        try {
            const e = yield null === (t = window.extension) || void 0 === t ? void 0 : t.request({
                method: "eth_requestAccounts"
            });
            Au(`[MetaMaskSDK: connectWithExtensionProvider()] accounts=${e}`);
        } catch (e) {
            return void console.warn("[MetaMaskSDK: connectWithExtensionProvider()] can't request accounts error", e);
        }
        localStorage.setItem(ah, "extension"), e.extensionActive = !0, e.emit(zu.ProviderUpdate, hh.EXTENSION), e.options.enableAnalytics && (null === (n = e.analytics) || void 0 === n || n.send({
            event: Ao.SDK_USE_EXTENSION
        }));
    });
}
function mh(e) {
    let t;
    if (void 0 !== C) t = C.from(e, "utf8").toString("base64");
    else if ("function" == typeof btoa) t = btoa(encodeURIComponent(e).replace(/%([0-9A-F]{2})/gu, (e, t)=>String.fromCharCode(parseInt(t, 16))));
    else {
        if ("object" != ("TURBOPACK compile-time value", "object") || !("Buffer" in l)) throw new Error("Unable to base64 encode: No available method.");
        t = l.Buffer.from(e, "utf8").toString("base64");
    }
    return t;
}
function yh(e, t, n, r) {
    var i, o, s, a, l, d, u, h, f, p, g, m, y, v, b, w, E, S, _, k;
    return c(this, void 0, void 0, function*() {
        const n = null === (i = e.state.remote) || void 0 === i ? void 0 : i.isReady(), c = null === (o = e.state.remote) || void 0 === o ? void 0 : o.isConnected(), A = null === (s = e.state.remote) || void 0 === s ? void 0 : s.isPaused(), x = qu.getProvider(), M = null === (a = e.state.remote) || void 0 === a ? void 0 : a.getChannelId(), I = null === (l = e.state.remote) || void 0 === l ? void 0 : l.isAuthorized(), { deeplinkProtocol: T } = e.state, { method: R, data: P, triggeredInstaller: O } = ((e)=>{
            var t, n, r, i;
            let o;
            C.isBuffer(e) ? (o = e.toJSON(), o._isBuffer = !0) : o = e;
            const s = null === (t = null == o ? void 0 : o.data) || void 0 === t ? void 0 : t.method;
            let a = !1;
            return "object" == typeof (null === (n = null == o ? void 0 : o.data) || void 0 === n ? void 0 : n.params) && !0 === (null === (i = null === (r = null == o ? void 0 : o.data) || void 0 === r ? void 0 : r.params) || void 0 === i ? void 0 : i.__triggeredInstaller) && (a = !0, o.data.params = o.data.params.wrappedParams), {
                method: s,
                data: o,
                triggeredInstaller: a
            };
        })(t);
        if (Au(`[RCPMS: write()] method='${R}' isRemoteReady=${n} channelId=${M} isSocketConnected=${c} isRemotePaused=${A} providerConnected=${x.isConnected()}`, t), !M) return R !== nh.METAMASK_GETPROVIDERSTATE && Au(`[RCPMS: write()] ${R} --\x3e channelId is undefined`), r(new Error("disconnected"));
        Au(`[RCPMS: write()] remote.isPaused()=${null === (d = e.state.remote) || void 0 === d ? void 0 : d.isPaused()} authorized=${I} ready=${n} socketConnected=${c}`, t);
        const N = null === (u = e.state.platformManager) || void 0 === u ? void 0 : u.isSecure(), L = null !== (f = null === (h = e.state.platformManager) || void 0 === h ? void 0 : h.isMobileWeb()) && void 0 !== f && f, D = null !== (g = null === (p = e.state.remote) || void 0 === p ? void 0 : p.hasDeeplinkProtocol()) && void 0 !== g && g && L && I;
        try {
            if (!O) {
                const t = JSON.stringify(null == P ? void 0 : P.data);
                if (t.length > uh) return r(new Error(`Message size ${t.length} exceeds maximum allowed size of 1000000 bytes`));
                null === (m = e.state.remote) || void 0 === m || m.sendMessage(null == P ? void 0 : P.data).then(()=>{
                    Au(`[RCPMS: _write()] ${R} sent successfully`);
                }).catch((e)=>{
                    Au("[RCPMS: _write()] error sending message", e);
                });
            }
            if (!N) return Au(`[RCPMS: _write()] unsecure platform for method ${R} -- return callback`), r();
            if (O) return Au("[RCPMS: _write()] prevent deeplink -- installation completed separately."), r();
            const t = null !== (b = null === (v = null === (y = e.state.remote) || void 0 === y ? void 0 : y.getKeyInfo()) || void 0 === v ? void 0 : v.ecies.public) && void 0 !== b ? b : "";
            let n = encodeURI(`channelId=${M}&pubkey=${t}&comm=socket&t=d&v=2`);
            if (D) {
                const t = JSON.stringify(null == P ? void 0 : P.data), i = null === (w = e.state.remote) || void 0 === w ? void 0 : w.encrypt(t);
                if (!i) return Au("[RCPMS: _write()] error encrypting message"), r(new Error("RemoteCommunicationPostMessageStream - disconnected"));
                n += `&scheme=${T}&rpc=${mh(i)}`;
            }
            if (!(null === (E = e.state.platformManager) || void 0 === E ? void 0 : E.isMetaMaskInstalled())) return Au("[RCPMS: _write()] prevent deeplink until installation is completed."), r();
            rh[R] ? (Au(`[RCPMS: _write()] redirect link for '${R}' socketConnected=${c} connect?${n}`), null === (S = e.state.platformManager) || void 0 === S || S.openDeeplink(`${Qu}?${n}`, `${Xu}?${n}`, "_self")) : (null === (_ = e.state.remote) || void 0 === _ ? void 0 : _.isPaused()) ? (Au(`[RCPMS: _write()] MM is PAUSED! deeplink with connect! targetMethod=${R}`), null === (k = e.state.platformManager) || void 0 === k || k.openDeeplink(`${Qu}?redirect=true&${n}`, `${Xu}?redirect=true&${n}`, "_self")) : Au(`[RCPMS: _write()] method ${R} doesn't need redirect.`);
        } catch (e) {
            return Au("[RCPMS: _write()] error sending message", e), r(new Error("RemoteCommunicationPostMessageStream - disconnected"));
        }
        return r();
    });
}
class vh extends nu.Duplex {
    constructor({ name: e, remote: t, deeplinkProtocol: n, platformManager: r }){
        super({
            objectMode: !0
        }), this.state = {
            _name: null,
            remote: null,
            deeplinkProtocol: !1,
            platformManager: null
        }, this.state._name = e, this.state.remote = t, this.state.deeplinkProtocol = n, this.state.platformManager = r, this._onMessage = this._onMessage.bind(this), this.state.remote.on(So.MESSAGE, this._onMessage);
    }
    _write(e, t, n) {
        return c(this, void 0, void 0, function*() {
            return yh(this, e, 0, n);
        });
    }
    _read() {}
    _onMessage(e) {
        return function(e, t) {
            try {
                if (Au("[RCPMS: onMessage()] message", t), !t || "object" != typeof t) return;
                if ("object" != typeof (null == t ? void 0 : t.data)) return;
                if (!(null == t ? void 0 : t.name)) return void Au("[RCPMS: onMessage()] ignore message without name", t);
                if ((null == t ? void 0 : t.name) !== Yu.PROVIDER) return void Au(`[RCPMS: onMessage()] ignore message with wrong name message=${t}`);
                if (C.isBuffer(t)) {
                    const n = C.from(t);
                    e.push(n);
                } else e.push(t);
            } catch (e) {
                Au(`[RCPMS: onMessage()] ignore message error err=${e}`);
            }
        }(this, e);
    }
    start() {}
}
let bh = 1;
const wh = (e)=>new Promise((t)=>{
        setTimeout(()=>{
            t(!0);
        }, e);
    }), Eh = ({ checkInstallationOnAllCalls: t = !1, communicationLayerPreference: n, injectProvider: r, shouldShimWeb3: i, platformManager: o, installer: s, sdk: a, remoteConnection: l, debug: d })=>c(void 0, void 0, void 0, function*() {
        var u, h;
        const f = (({ name: e, remoteConnection: t })=>{
            if (!t || !(null == t ? void 0 : t.getConnector())) throw new Error("Missing remote connection parameter");
            return new vh({
                name: e,
                remote: null == t ? void 0 : t.getConnector(),
                deeplinkProtocol: null == t ? void 0 : t.state.deeplinkProtocol,
                platformManager: null == t ? void 0 : t.getPlatformManager()
            });
        })({
            name: Yu.INPAGE,
            target: Yu.CONTENT_SCRIPT,
            platformManager: o,
            communicationLayerPreference: n,
            remoteConnection: l
        }), p = o.getPlatformType(), g = a.options.dappMetadata, m = `Sdk/Javascript SdkVersion/${Zu.version} Platform/${p} dApp/${null !== (u = g.url) && void 0 !== u ? u : g.name} dAppTitle/${g.name}`;
        let y = null, v = null;
        const b = null === (h = a.options.storage) || void 0 === h ? void 0 : h.storageManager;
        if (b) {
            try {
                const e = yield b.getCachedAccounts();
                e.length > 0 && (y = e[0]);
            } catch (e) {
                console.error(`[initializeMobileProvider] failed to get cached addresses: ${e}`);
            }
            try {
                const e = yield b.getCachedChainId();
                e && (v = e);
            } catch (e) {
                console.error(`[initializeMobileProvider] failed to parse cached chainId: ${e}`);
            }
        }
        Au(`[initializeMobileProvider] cachedAccountAddress: ${y}, cachedChainId: ${v}`);
        const w = !(!r || p === Uo.NonBrowser || p === Uo.ReactNative), E = qu.init({
            shouldSetOnWindow: w,
            connectionStream: f,
            shouldShimWeb3: i,
            sdkInstance: a
        });
        let S = !1;
        const _ = (e)=>{
            S = e;
        }, C = ()=>S, k = (n, r, i, d)=>c(void 0, void 0, void 0, function*() {
                var u, h, f, p, g, w, E, k, A;
                const x = qu.getProvider();
                if (S) {
                    x.emit("display_uri", (null == l ? void 0 : l.state.qrcodeLink) || ""), null == l || l.showActiveModal();
                    let e = C();
                    for(; e;){
                        const t = C(), n = null == l ? void 0 : l.isAuthorized();
                        e = t && !n, Au(`[initializeMobileProvider: sendRequest()] waiting for initialization to complete - initializing: ${t} authorized: ${n}`), yield wh(1e3);
                    }
                    return Au("[initializeMobileProvider: sendRequest()] initial method completed -- prevent installation and call provider"), i(...r);
                }
                const M = o.isMetaMaskInstalled(), I = null == l ? void 0 : l.isConnected();
                let T = null, R = null, P = null;
                if (T = null !== (u = x.getSelectedAddress()) && void 0 !== u ? u : y, P = x.getChainId() || v, T && b && T !== y && b.persistAccounts([
                    T
                ]).catch((e)=>{
                    console.error(`[initializeMobileProvider] failed to persist account: ${e}`);
                }), P && (v = P, b && b.persistChainId(P).catch((e)=>{
                    console.error(`[initializeMobileProvider] failed to persist chainId: ${e}`);
                })), Au("[initializeMobileProvider: sendRequest()]", {
                    selectedAddress: T,
                    chainId: P
                }), d && Au(`[initializeMobileProvider: sendRequest()] method=${n} ongoing=${S} selectedAddress=${T} isInstalled=${M} checkInstallationOnAllCalls=${t} socketConnected=${I}`), T && n.toLowerCase() === nh.ETH_ACCOUNTS.toLowerCase()) return [
                    T
                ];
                if (P && n.toLowerCase() === nh.ETH_CHAINID.toLowerCase()) return P;
                const O = [
                    nh.ETH_REQUESTACCOUNTS,
                    nh.WALLET_REQUESTPERMISSIONS,
                    nh.METAMASK_CONNECTSIGN,
                    nh.METAMASK_CONNECTWITH
                ], N = !rh[n], L = null === (h = a.options.readonlyRPCMap) || void 0 === h ? void 0 : h[P];
                if (L && N) try {
                    const t = null === (f = null == r ? void 0 : r[0]) || void 0 === f ? void 0 : f.params, i = yield (({ rpcEndpoint: t, method: n, sdkInfo: r, params: i })=>c(void 0, void 0, void 0, function*() {
                            const o = JSON.stringify({
                                jsonrpc: "2.0",
                                method: n,
                                params: i,
                                id: (bh += 1, bh)
                            }), s = {
                                Accept: "application/json",
                                "Content-Type": "application/json"
                            };
                            let a;
                            t.includes("infura") && (s["Metamask-Sdk-Info"] = r);
                            try {
                                a = yield (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$node$2d$ponyfill$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(t, {
                                    method: "POST",
                                    headers: s,
                                    body: o
                                });
                            } catch (e) {
                                throw e instanceof Error ? new Error(`Failed to fetch from RPC: ${e.message}`) : new Error(`Failed to fetch from RPC: ${e}`);
                            }
                            if (!a.ok) throw new Error(`Server responded with a status of ${a.status}`);
                            return (yield a.json()).result;
                        }))({
                        rpcEndpoint: L,
                        sdkInfo: m,
                        method: n,
                        params: t || []
                    });
                    return d && Au(`initializeProvider::ReadOnlyRPCResponse ${i}`), i;
                } catch (e) {
                    console.warn(`[initializeMobileProvider: sendRequest()] method=${n} readOnlyRPCRequest failed:`, e);
                }
                if ((!M || M && !I) && n !== nh.METAMASK_GETPROVIDERSTATE) {
                    const e = (null === (p = null == r ? void 0 : r[0]) || void 0 === p ? void 0 : p.params) || [];
                    if (-1 !== O.indexOf(n) || t) {
                        _(!0);
                        const t = n === nh.METAMASK_CONNECTWITH, o = `${Date.now()}`;
                        try {
                            yield s.start({
                                wait: !1,
                                connectWith: t ? {
                                    method: n,
                                    id: o,
                                    params: e
                                } : void 0
                            }), yield new Promise((e, t)=>{
                                (null == l ? void 0 : l.isAuthorized()) && (Au("[initializeMobileProvider: sendRequest()] already authorized"), e(!0)), null == l || l.getConnector().once(So.AUTHORIZED, ()=>{
                                    e(!0);
                                }), a.once(So.PROVIDER_UPDATE, (e)=>{
                                    Au(`[initializeMobileProvider: sendRequest()] PROVIDER_UPDATE --- remote provider request interupted type=${e}`), e === hh.EXTENSION ? t(So.PROVIDER_UPDATE) : t(new Error("Connection Terminated"));
                                });
                            });
                        } catch (t) {
                            if (hh.EXTENSION === t) {
                                if (Au(`[initializeMobileProvider: sendRequest()] extension provider detect: re-create ${n} on the active provider`), n.toLowerCase() === nh.METAMASK_CONNECTSIGN.toLowerCase()) {
                                    const t = yield null === (g = a.getProvider()) || void 0 === g ? void 0 : g.request({
                                        method: nh.ETH_REQUESTACCOUNTS,
                                        params: []
                                    });
                                    if (!t.length) throw new Error("SDK state invalid -- undefined accounts");
                                    const n = yield null === (w = a.getProvider()) || void 0 === w ? void 0 : w.request({
                                        method: nh.PERSONAL_SIGN,
                                        params: [
                                            e[0],
                                            t[0]
                                        ]
                                    });
                                    return a.emit(zu.ConnectWithResponse, n), n;
                                }
                                if (n.toLowerCase() === nh.METAMASK_CONNECTWITH.toLowerCase()) {
                                    const [t] = e, n = yield (({ method: e, sdk: t, params: n })=>c(void 0, void 0, void 0, function*() {
                                            var r, i, o, s;
                                            if (!t.isExtensionActive()) throw new Error("SDK state invalid -- extension is not active");
                                            Au("[MetaMaskProvider: extensionConnectWithOverwrite()] Overwriting request method", e, n);
                                            const a = yield null === (r = t.getProvider()) || void 0 === r ? void 0 : r.request({
                                                method: nh.ETH_REQUESTACCOUNTS,
                                                params: []
                                            });
                                            if (!a.length) throw new Error("SDK state invalid -- undefined accounts");
                                            if ((null == e ? void 0 : e.toLowerCase()) === nh.PERSONAL_SIGN.toLowerCase()) {
                                                const r = {
                                                    method: e,
                                                    params: [
                                                        n[0],
                                                        a[0]
                                                    ]
                                                };
                                                return yield null === (i = t.getProvider()) || void 0 === i ? void 0 : i.request(r);
                                            }
                                            if ((null == e ? void 0 : e.toLowerCase()) === nh.ETH_SENDTRANSACTION.toLowerCase()) {
                                                const r = {
                                                    method: e,
                                                    params: [
                                                        Object.assign(Object.assign({}, n[0]), {
                                                            from: a[0]
                                                        })
                                                    ]
                                                };
                                                return yield null === (o = t.getProvider()) || void 0 === o ? void 0 : o.request(r);
                                            }
                                            return oh.includes(e.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${e} -- not handled by the extension -- call separately`), a) : yield null === (s = t.getProvider()) || void 0 === s ? void 0 : s.request({
                                                method: e,
                                                params: n
                                            });
                                        }))({
                                        method: t.method,
                                        sdk: a,
                                        params: t.params
                                    });
                                    return a.emit(zu.ConnectWithResponse, n), n;
                                }
                                return Au(`[initializeMobileProvider: sendRequest()] sending '${n}' on active provider`, e), yield null === (E = a.getProvider()) || void 0 === E ? void 0 : E.request({
                                    method: n,
                                    params: e
                                });
                            }
                            if (t === So.REJECTED) throw null == l || l.closeModal(), null === (k = a.getProvider()) || void 0 === k || k.handleDisconnect({
                                terminate: !1
                            }), Object.assign(new Error("User rejected connection"), {
                                code: 4001
                            });
                            throw Au(`[initializeMobileProvider: sendRequest()] failed to start installer: ${t}`), t;
                        } finally{
                            _(!1);
                        }
                        if (n === nh.ETH_REQUESTACCOUNTS) return R = yield new Promise((e)=>{
                            const t = setInterval(()=>{
                                const { accounts: n } = x.getState();
                                n && (clearInterval(t), e(n));
                            }, 100);
                        }), Au(`[initializeMobileProvider: sendRequest()] selectedAddress: ${T} --- SKIP rpc call`), R;
                        if (n === nh.METAMASK_CONNECTWITH) try {
                            let e = 0;
                            const t = 5, n = ({ resolve: n, reject: r })=>{
                                e += 1;
                                const i = null == l ? void 0 : l.getConnector().getRPCMethodTracker(), s = null == i ? void 0 : i[o];
                                return Au(`TRACKER: update method ${o}`, s), (null == s ? void 0 : s.result) ? (Au("[initializeMobileProvider: sendRequest()] found result", s.result), a.emit(zu.ConnectWithResponse, s.result), void n(s.result)) : (null == s ? void 0 : s.error) ? (Au("[initializeMobileProvider: sendRequest()] found error", s.error), void r(s.error)) : e >= t ? (Au("[initializeMobileProvider: sendRequest()] max message count reached without result"), void r(new Error("Max message count reached without result"))) : void Au("[initializeMobileProvider: sendRequest()] not found yet, need to wait for next update");
                            };
                            let r, i;
                            const s = yield new Promise((e, t)=>{
                                const s = null == l ? void 0 : l.getConnector().getRPCMethodTracker();
                                Au(`TRACKER: method ${o}`, s), (null == s ? void 0 : s[o].result) ? (Au("[initializeMobileProvider: sendRequest()] found result", null == s ? void 0 : s[o].result), e(null == s ? void 0 : s[o].result)) : (null == s ? void 0 : s[o].error) && (Au("[initializeMobileProvider: sendRequest()] found error", null == s ? void 0 : s[o].error), t(null == s ? void 0 : s[o].error)), i = ()=>n({
                                        resolve: e,
                                        reject: t
                                    }), r = null == l ? void 0 : l.getConnector().on(So.RPC_UPDATE, i);
                            });
                            return i && (null == r || r.off(So.RPC_UPDATE, i)), Au("TRACKER: result", s), s;
                        } catch (e) {
                            throw Au("[initializeMobileProvider: sendRequest()] error:", e), e;
                        }
                        r[0] && "object" == typeof r[0] && (r[0].params = {
                            __triggeredInstaller: !0,
                            wrappedParams: r[0].params
                        });
                        return i(...r);
                    }
                    if (o.isSecure() && rh[n]) return i(...r);
                    if (a.isExtensionActive()) return Au(`[initializeMobileProvider: sendRequest()] EXTENSION active - redirect request '${n}' to it`, r, e), yield null === (A = a.getProvider()) || void 0 === A ? void 0 : A.request({
                        method: n,
                        params: e
                    });
                    throw Au(`[initializeMobileProvider: sendRequest()] method=${n} --- skip --- not connected/installed`), new Error("MetaMask is not connected/installed, please call eth_requestAccounts to connect first.");
                }
                try {
                    const e = yield i(...r);
                    if (Au(`[initializeMobileProvider: sendRequest()] method=${n} rpcResponse`, e), n === nh.WALLET_REQUESTPERMISSIONS) {
                        const t = e.reduce((e, t)=>{
                            var n;
                            if ("eth_accounts" === t.parentCapability) {
                                const r = null === (n = t.caveats.find((e)=>"restrictReturnedAccounts" === e.type)) || void 0 === n ? void 0 : n.value;
                                r && e.push(...r);
                            }
                            return e;
                        }, []);
                        Au("[initializeMobileProvider: sendRequest()] accountsToPersist:", t), t.length > 0 && (x.handleAccountsChanged(t, !1), null == b || b.persistAccounts(t));
                    }
                    return e;
                } catch (e) {
                    throw console.error("[initializeMobileProvider: sendRequest()] error:", e), e;
                }
            }), { request: A } = E;
        E.request = (...e)=>c(void 0, void 0, void 0, function*() {
                return k(null == e ? void 0 : e[0].method, e, A, d);
            });
        const { send: x } = E;
        return E.send = (...e)=>c(void 0, void 0, void 0, function*() {
                return k(null == e ? void 0 : e[0], e, x, d);
            }), Au("[initializeMobileProvider: sendRequest()] metamaskStream.start()"), f.start(), E;
    });
function Sh(e) {
    var t, n, r, i;
    return c(this, void 0, void 0, function*() {
        const { options: o } = e, s = {
            communicationLayerPreference: null !== (t = o.communicationLayerPreference) && void 0 !== t ? t : jo.SOCKET,
            platformManager: e.platformManager,
            sdk: e,
            checkInstallationOnAllCalls: o.checkInstallationOnAllCalls,
            injectProvider: null === (n = o.injectProvider) || void 0 === n || n,
            shouldShimWeb3: null === (r = o.shouldShimWeb3) || void 0 === r || r,
            extensionOnly: null === (i = o.extensionOnly) || void 0 === i || i,
            installer: e.installer,
            remoteConnection: e.remoteConnection,
            debug: e.debug
        }, a = yield Eh(s);
        e.activeProvider = a, function(e) {
            var t, n, r, i;
            null === (n = null === (t = e.remoteConnection) || void 0 === t ? void 0 : t.getConnector()) || void 0 === n || n.on(zu.ConnectionStatus, (t)=>{
                e.emit(zu.ConnectionStatus, t);
            }), null === (i = null === (r = e.remoteConnection) || void 0 === r ? void 0 : r.getConnector()) || void 0 === i || i.on(zu.ServiceStatus, (t)=>{
                e.emit(zu.ServiceStatus, t);
            });
        }(e);
    });
}
const _h = "sdk";
class Ch {
    constructor({ serverUrl: e, enabled: t, originatorInfo: n }){
        this.serverURL = fo, this.serverURL = e, this.originatorInfo = n, this.enabled = null == t || t;
    }
    send({ event: e, params: t }) {
        if (!this.enabled) return;
        const n = Object.assign(Object.assign({
            id: _h,
            event: e,
            sdkVersion: Zu.version
        }, this.originatorInfo), {
            params: t
        });
        Au(`[Analytics: send()] event: ${e}`, n), lo(n, this.serverURL).catch((e)=>{
            Au(`[Analytics: send()] error: ${e}`);
        });
    }
}
const kh = ()=>{
    if ("undefined" == typeof document) return;
    let e;
    const t = document.getElementsByTagName("link");
    for(let n = 0; n < t.length; n++)"icon" !== t[n].getAttribute("rel") && "shortcut icon" !== t[n].getAttribute("rel") || (e = t[n].getAttribute("href"));
    return e;
}, Ah = 163400;
function xh(e) {
    var t, n, r;
    const { dappMetadata: i } = e, o = function({ url: e, name: t }) {
        var n;
        const r = e + t, i = mh(r);
        if (!localStorage) return "";
        let o = null !== (n = localStorage.getItem(i)) && void 0 !== n ? n : "";
        if (!o) {
            o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
            try {
                localStorage.setItem(i, o);
            } catch (e) {
                return "";
            }
        }
        return o;
    }({
        url: null !== (t = null == i ? void 0 : i.url) && void 0 !== t ? t : "no_url",
        name: null !== (n = null == i ? void 0 : i.name) && void 0 !== n ? n : "no_name"
    }), a = null === (r = e.platformManager) || void 0 === r ? void 0 : r.getPlatformType(), c = a === Uo.DesktopWeb, l = a === Uo.MetaMaskMobileWebview;
    let d = "N/A";
    return c ? d = "extension" : l && (d = "mobile"), {
        id: o,
        from: d
    };
}
const Mh = (e, t, r)=>{
    if (bo(e)) {
        if (r || t && "object" == typeof t && null !== t && "error" in t) {
            const i = r || (null == t ? void 0 : t.error);
            i && 4001 === i.code ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_action_rejected", {
                action: e
            }) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_action_failed", {
                action: e
            });
        } else __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_action_succeeded", {
            action: e
        });
    }
}, Ih = ({ provider: e, sdkInstance: t })=>{
    if ("state" in e) throw new Error("INVALID EXTENSION PROVIDER");
    return new Proxy(e, {
        get: (r, i)=>"request" === i ? function(e) {
                var i, o;
                return c(this, void 0, void 0, function*() {
                    Au("[wrapExtensionProvider()] Overwriting request method", e);
                    const { method: s, params: a } = e, l = ih.includes(s.toLowerCase()), { id: d, from: u } = xh(t);
                    if (l && (null === (i = t.analytics) || void 0 === i || i.send({
                        event: Ao.SDK_RPC_REQUEST,
                        params: {
                            method: s,
                            from: u,
                            id: d
                        }
                    })), bo(s) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_action_requested", {
                        action: s
                    }), s === nh.METAMASK_BATCH && Array.isArray(a)) return (({ target: e, args: t, trackEvent: n, sdkInstance: r })=>c(void 0, void 0, void 0, function*() {
                            var i, o;
                            if ("metamask_batch" !== t.method) throw new Error("Invalid usage");
                            const s = [], a = null !== (i = null == t ? void 0 : t.params) && void 0 !== i ? i : [];
                            for (const t of a){
                                const n = yield null == e ? void 0 : e.request({
                                    method: t.method,
                                    params: t.params
                                });
                                s.push(n);
                            }
                            const { id: c, from: l } = xh(r);
                            n && (null === (o = r.analytics) || void 0 === o || o.send({
                                event: Ao.SDK_RPC_REQUEST_DONE,
                                params: {
                                    method: t.method,
                                    from: l,
                                    id: c
                                }
                            }));
                            for (const e of s)Mh(t.method, e, null);
                            return s;
                        }))({
                        target: r,
                        args: e,
                        trackEvent: l,
                        sdkInstance: t
                    });
                    if (s.toLowerCase() === nh.METAMASK_CONNECTSIGN.toLowerCase() && Array.isArray(a)) return (({ target: e, params: t })=>c(void 0, void 0, void 0, function*() {
                            let n, r = null;
                            try {
                                const r = yield e.request({
                                    method: nh.ETH_REQUESTACCOUNTS,
                                    params: []
                                });
                                if (!r.length) throw new Error("SDK state invalid -- undefined accounts");
                                return n = yield e.request({
                                    method: nh.PERSONAL_SIGN,
                                    params: [
                                        t[0],
                                        r[0]
                                    ]
                                }), n;
                            } catch (e) {
                                throw r = e, e;
                            } finally{
                                Mh(nh.PERSONAL_SIGN, n, r);
                            }
                        }))({
                        target: r,
                        params: a
                    });
                    if (s.toLowerCase() === nh.METAMASK_CONNECTWITH.toLowerCase() && Array.isArray(a)) return (({ target: e, params: t })=>c(void 0, void 0, void 0, function*() {
                            const [n] = t, r = n.method, i = n.params;
                            let o, s = null;
                            try {
                                const t = yield e.request({
                                    method: nh.ETH_REQUESTACCOUNTS,
                                    params: []
                                });
                                if (!Array.isArray(t) || !t.length) throw new Error("SDK state invalid -- undefined accounts");
                                return (null == r ? void 0 : r.toLowerCase()) === nh.PERSONAL_SIGN.toLowerCase() ? (o = yield e.request({
                                    method: r,
                                    params: [
                                        i[0],
                                        t[0]
                                    ]
                                }), o) : (null == r ? void 0 : r.toLowerCase()) === nh.ETH_SENDTRANSACTION.toLowerCase() ? (o = yield e.request({
                                    method: r,
                                    params: [
                                        Object.assign(Object.assign({}, i[0]), {
                                            from: t[0]
                                        })
                                    ]
                                }), o) : oh.includes(r.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${r} -- not handled by the extension -- call separately`), o = t, o) : (o = yield e.request({
                                    method: r,
                                    params: i
                                }), o);
                            } catch (e) {
                                throw s = e, e;
                            } finally{
                                Mh(r, o, s);
                            }
                        }))({
                        target: r,
                        params: a
                    });
                    let h, f = null;
                    try {
                        return h = yield r.request(e), h;
                    } catch (e) {
                        throw f = e, e;
                    } finally{
                        l && (null === (o = t.analytics) || void 0 === o || o.send({
                            event: Ao.SDK_RPC_REQUEST_DONE,
                            params: {
                                method: s,
                                from: u,
                                id: d
                            }
                        })), Mh(s, h, f);
                    }
                });
            } : "getChainId" === i ? function() {
                return e.chainId;
            } : "getNetworkVersion" === i ? function() {
                return e.networkVersion;
            } : "getSelectedAddress" === i ? function() {
                return e.selectedAddress;
            } : "isConnected" === i ? function() {
                return e._state.isConnected;
            } : r[i]
    });
};
var Th;
function Rh({ mustBeMetaMask: e, sdkInstance: t }) {
    return c(this, void 0, void 0, function*() {
        if ("TURBOPACK compile-time truthy", 1) throw new Error("window not available");
        try {
            const e = yield new Promise((e, t)=>{
                const n = setTimeout(()=>{
                    t(new Error("eip6963RequestProvider timed out"));
                }, 500);
                window.addEventListener(Th.Announce, (t)=>{
                    const r = t, { detail: { info: i, provider: o } = {} } = r, { name: s, rdns: a, uuid: c } = null != i ? i : {};
                    th.test(c) && s.startsWith(eh.NAME) && eh.RDNS.includes(a) && (clearTimeout(n), e(o));
                }), window.dispatchEvent(new Event(Th.Request));
            });
            return Ih({
                provider: e,
                sdkInstance: t
            });
        } catch (n) {
            if (!e && window.ethereum) return Ih({
                provider: window.ethereum,
                sdkInstance: t
            });
            throw new Error("Provider not found");
        }
    });
}
!function(e) {
    e.Announce = "eip6963:announceProvider", e.Request = "eip6963:requestProvider";
}(Th || (Th = {}));
const Ph = (e)=>c(void 0, void 0, void 0, function*() {
        const { options: t } = e, { infuraAPIKey: n } = t;
        if (!n) return;
        const r = {
            "0x1": `https://mainnet.infura.io/v3/${n}`,
            "0x5": `https://goerli.infura.io/v3/${n}`,
            "0xaa36a7": `https://sepolia.infura.io/v3/${n}`,
            "0xe708": `https://linea-mainnet.infura.io/v3/${n}`,
            "0xe704": `https://linea-goerli.infura.io/v3/${n}`,
            "0x89": `https://polygon-mainnet.infura.io/v3/${n}`,
            "0x13881": `https://polygon-mumbai.infura.io/v3/${n}`,
            "0x45": `https://optimism-mainnet.infura.io/v3/${n}`,
            "0x1a4": `https://optimism-goerli.infura.io/v3/${n}`,
            "0xa4b1": `https://arbitrum-mainnet.infura.io/v3/${n}`,
            "0x66eed": `https://arbitrum-goerli.infura.io/v3/${n}`,
            "0x2a15c308d": `https://palm-mainnet.infura.io/v3/${n}`,
            "0x2a15c3083": `https://palm-testnet.infura.io/v3/${n}`,
            "0xa86a": `https://avalanche-mainnet.infura.io/v3/${n}`,
            "0xa869": `https://avalanche-fuji.infura.io/v3/${n}`,
            "0x4e454152": `https://aurora-mainnet.infura.io/v3/${n}`,
            "0x4e454153": `https://aurora-testnet.infura.io/v3/${n}`,
            "0x534e5f4d41494e": `https://starknet-mainnet.infura.io/v3/${n}`,
            "0x534e5f474f45524c49": `https://starknet-goerli.infura.io/v3/${n}`,
            "0x534e5f474f45524c4932": `https://starknet-goerli2.infura.io/v3/${n}`,
            "0xa4ec": `https://celo-mainnet.infura.io/v3/${n}`,
            "0xaef3": `https://celo-alfajores.infura.io/v3/${n}`
        };
        e.options.readonlyRPCMap ? e.options.readonlyRPCMap = Object.assign(Object.assign({}, e.options.readonlyRPCMap), r) : e.options.readonlyRPCMap = r;
    });
const Oh = (e)=>c(void 0, void 0, void 0, function*() {
        const { options: t } = e, { readonlyRPCMap: n } = t;
        if (n) try {
            Au("[MetaMaskSDK: setupReadOnlyRPCProviders()] Setting up Readonly RPC Providers", n), e.setReadOnlyRPCCalls(!0);
        } catch (e) {
            throw new Error("Invalid Infura Settings");
        }
    });
function Nh(e, t, n, r) {
    return new (n || (n = Promise))(function(t, i) {
        function o(e) {
            try {
                a(r.next(e));
            } catch (e) {
                i(e);
            }
        }
        function s(e) {
            try {
                a(r.throw(e));
            } catch (e) {
                i(e);
            }
        }
        function a(e) {
            var r;
            e.done ? t(e.value) : (r = e.value, r instanceof n ? r : new n(function(e) {
                e(r);
            })).then(o, s);
        }
        a((r = r.apply(e, [])).next());
    });
}
function Lh(e, t) {
    var n, r, i, o, s = {
        label: 0,
        sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    };
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
        return this;
    }), o;
    //TURBOPACK unreachable
    ;
    function a(o) {
        return function(a) {
            return function(o) {
                if (n) throw new TypeError("Generator is already executing.");
                for(; s;)try {
                    if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                    switch(r = 0, i && (o = [
                        2 & o[0],
                        i.value
                    ]), o[0]){
                        case 0:
                        case 1:
                            i = o;
                            break;
                        case 4:
                            return s.label++, {
                                value: o[1],
                                done: !1
                            };
                        case 5:
                            s.label++, r = o[1], o = [
                                0
                            ];
                            continue;
                        case 7:
                            o = s.ops.pop(), s.trys.pop();
                            continue;
                        default:
                            if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                s = 0;
                                continue;
                            }
                            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                s.label = o[1];
                                break;
                            }
                            if (6 === o[0] && s.label < i[1]) {
                                s.label = i[1], i = o;
                                break;
                            }
                            if (i && s.label < i[2]) {
                                s.label = i[2], s.ops.push(o);
                                break;
                            }
                            i[2] && s.ops.pop(), s.trys.pop();
                            continue;
                    }
                    o = t.call(e, s);
                } catch (e) {
                    o = [
                        6,
                        e
                    ], r = 0;
                } finally{
                    n = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                    value: o[0] ? o[1] : void 0,
                    done: !0
                };
            }([
                o,
                a
            ]);
        };
    }
}
var Dh = "INSTALLED", $h = "NOT_INSTALLED", Bh = "REGISTERED", Kh = "REGISTERING", jh = "RELOADING", Uh = {
    CHROME: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    FIREFOX: "https://addons.mozilla.org/firefox/addon/ether-metamask/",
    DEFAULT: "https://metamask.io"
}, Hh = "REGISTRATION_IN_PROGRESS", Fh = "FORWARDER_ID", zh = function() {
    function e(t) {
        var n = void 0 === t ? {} : t, r = n.forwarderOrigin, i = void 0 === r ? "https://fwd.metamask.io" : r, o = n.forwarderMode, s = void 0 === o ? e.FORWARDER_MODE.INJECT : o;
        this.forwarderOrigin = i, this.forwarderMode = s, this.state = e.isMetaMaskInstalled() ? Dh : $h;
        var a = e._detectBrowser();
        this.downloadUrl = a ? Uh[a] : Uh.DEFAULT, this._onMessage = this._onMessage.bind(this), this._onMessageFromForwarder = this._onMessageFromForwarder.bind(this), this._openForwarder = this._openForwarder.bind(this), this._openDownloadPage = this._openDownloadPage.bind(this), this.startOnboarding = this.startOnboarding.bind(this), this.stopOnboarding = this.stopOnboarding.bind(this), window.addEventListener("message", this._onMessage), s === e.FORWARDER_MODE.INJECT && "true" === sessionStorage.getItem(Hh) && e._injectForwarder(this.forwarderOrigin);
    }
    return e.prototype._onMessage = function(e) {
        if (e.origin === this.forwarderOrigin) return "metamask:reload" === e.data.type ? this._onMessageFromForwarder(e) : void console.debug("Unknown message from '" + e.origin + "' with data " + JSON.stringify(e.data));
    }, e.prototype._onMessageUnknownStateError = function(e) {
        throw new Error("Unknown state: '" + e + "'");
    }, e.prototype._onMessageFromForwarder = function(t) {
        return Nh(this, 0, void 0, function() {
            return Lh(this, function(n) {
                switch(n.label){
                    case 0:
                        switch(this.state){
                            case jh:
                                return [
                                    3,
                                    1
                                ];
                            case $h:
                                return [
                                    3,
                                    2
                                ];
                            case Dh:
                                return [
                                    3,
                                    3
                                ];
                            case Kh:
                                return [
                                    3,
                                    5
                                ];
                            case Bh:
                                return [
                                    3,
                                    6
                                ];
                        }
                        return [
                            3,
                            7
                        ];
                    case 1:
                        return console.debug("Ignoring message while reloading"), [
                            3,
                            8
                        ];
                    case 2:
                        return console.debug("Reloading now to register with MetaMask"), this.state = jh, location.reload(), [
                            3,
                            8
                        ];
                    case 3:
                        return console.debug("Registering with MetaMask"), this.state = Kh, [
                            4,
                            e._register()
                        ];
                    case 4:
                        return n.sent(), this.state = Bh, t.source.postMessage({
                            type: "metamask:registrationCompleted"
                        }, t.origin), this.stopOnboarding(), [
                            3,
                            8
                        ];
                    case 5:
                        return console.debug("Already registering - ignoring reload message"), [
                            3,
                            8
                        ];
                    case 6:
                        return console.debug("Already registered - ignoring reload message"), [
                            3,
                            8
                        ];
                    case 7:
                        this._onMessageUnknownStateError(this.state), n.label = 8;
                    case 8:
                        return [
                            2
                        ];
                }
            });
        });
    }, e.prototype.startOnboarding = function() {
        sessionStorage.setItem(Hh, "true"), this._openDownloadPage(), this._openForwarder();
    }, e.prototype.stopOnboarding = function() {
        "true" === sessionStorage.getItem(Hh) && (this.forwarderMode === e.FORWARDER_MODE.INJECT && (console.debug("Removing forwarder"), e._removeForwarder()), sessionStorage.setItem(Hh, "false"));
    }, e.prototype._openForwarder = function() {
        this.forwarderMode === e.FORWARDER_MODE.OPEN_TAB ? window.open(this.forwarderOrigin, "_blank") : e._injectForwarder(this.forwarderOrigin);
    }, e.prototype._openDownloadPage = function() {
        window.open(this.downloadUrl, "_blank");
    }, e.isMetaMaskInstalled = function() {
        return Boolean(window.ethereum && window.ethereum.isMetaMask);
    }, e._register = function() {
        return window.ethereum.request({
            method: "wallet_registerOnboarding"
        });
    }, e._injectForwarder = function(e) {
        var t = document.body, n = document.createElement("iframe");
        n.setAttribute("height", "0"), n.setAttribute("width", "0"), n.setAttribute("style", "display: none;"), n.setAttribute("src", e), n.setAttribute("id", Fh), t.insertBefore(n, t.children[0]);
    }, e._removeForwarder = function() {
        var e;
        null === (e = document.getElementById(Fh)) || void 0 === e || e.remove();
    }, e._detectBrowser = function() {
        var e = Fu.parse(window.navigator.userAgent);
        return "Firefox" === e.browser.name ? "FIREFOX" : [
            "Chrome",
            "Chromium"
        ].includes(e.browser.name || "") ? "CHROME" : null;
    }, e.FORWARDER_MODE = {
        INJECT: "INJECT",
        OPEN_TAB: "OPEN_TAB"
    }, e;
}();
function qh(e, { wait: t = !1 }) {
    return c(this, void 0, void 0, function*() {
        return Au(`[MetamaskInstaller: startInstaller()] wait=${t}`), t && (yield wh(1e3)), yield e.checkInstallation();
    });
}
class Wh {
    constructor({ remote: e, preferDesktop: t, platformManager: n, debug: r = !1 }){
        this.state = {
            isInstalling: !1,
            hasInstalled: !1,
            resendRequest: null,
            preferDesktop: !1,
            platformManager: null,
            remote: null,
            debug: !1,
            connectWith: void 0
        }, this.state.remote = e, this.state.preferDesktop = t, this.state.platformManager = n, this.state.debug = r;
    }
    startDesktopOnboarding() {
        return function() {
            return c(this, void 0, void 0, function*() {
                Au("[MetamaskInstaller: startDesktopOnboarding() starting desktop onboarding"), window.ethereum && (window.ethereum = void 0), (new zh).startOnboarding();
            });
        }();
    }
    redirectToProperInstall() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                var t, n;
                return c(this, void 0, void 0, function*() {
                    const { state: r } = e, i = null === (t = r.platformManager) || void 0 === t ? void 0 : t.getPlatformType();
                    if (Au(`[MetamaskInstaller: redirectToProperInstall()] platform=${i}`), i === Uo.MetaMaskMobileWebview) return !1;
                    r.isInstalling = !0;
                    try {
                        yield null === (n = r.remote) || void 0 === n ? void 0 : n.startConnection({
                            connectWith: r.connectWith
                        }), r.isInstalling = !1, r.hasInstalled = !0;
                    } catch (e) {
                        throw r.isInstalling = !1, e;
                    }
                    return !0;
                });
            }(this);
        });
    }
    checkInstallation() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                var t;
                return c(this, void 0, void 0, function*() {
                    const { state: n } = e, r = null === (t = n.platformManager) || void 0 === t ? void 0 : t.isMetaMaskInstalled();
                    return Au(`[MetamaskInstaller: checkInstallation()] isInstalled=${r}`), !!r || (yield e.redirectToProperInstall());
                });
            }(this);
        });
    }
    start({ wait: e = !1, connectWith: t }) {
        return c(this, void 0, void 0, function*() {
            this.state.connectWith = t, Au(`[MetaMaskInstaller: start()] wait=${e}`, t), yield qh(this, {
                wait: e
            });
        });
    }
}
class Vh {
    constructor({ debug: e, sdkVersion: t }){
        this.containers = {
            install: void 0,
            pending: void 0,
            select: void 0
        }, this.defined = {
            install: !1,
            pending: !1,
            select: !1
        }, this.debug = null != e && e, this.sdkVersion = t;
    }
    loadComponent(e) {
        return c(this, void 0, void 0, function*() {
            if (!this.defined[e]) {
                this.defined[e] = !0;
                try {
                    const e = yield Promise.resolve().then(function() {
                        return Pp;
                    });
                    console.log("loader", e), e.defineCustomElements();
                } catch (t) {
                    console.error(`Failed to load ${e} modal:`, t);
                }
            }
        });
    }
    renderInstallModal(e) {
        var t;
        return c(this, void 0, void 0, function*() {
            this.debug && console.debug("ModalLoader: renderInstallModal", e), this.containers.install = e.parentElement, yield this.loadComponent("install");
            const n = document.createElement("mm-install-modal");
            n.link = e.link, n.preferDesktop = e.preferDesktop, n.sdkVersion = null !== (t = e.sdkVersion) && void 0 !== t ? t : this.sdkVersion, n.addEventListener("close", ({ detail: { shouldTerminate: t } })=>e.onClose(t)), n.addEventListener("startDesktopOnboarding", e.metaMaskInstaller.startDesktopOnboarding), n.addEventListener("trackAnalytics", (t)=>{
                var n;
                return null === (n = e.onAnalyticsEvent) || void 0 === n ? void 0 : n.call(e, t.detail);
            }), e.parentElement.appendChild(n);
        });
    }
    renderSelectModal(e) {
        var t;
        return c(this, void 0, void 0, function*() {
            this.containers.select = e.parentElement, yield this.loadComponent("select");
            const n = document.createElement("mm-select-modal");
            n.link = e.link, n.sdkVersion = null !== (t = e.sdkVersion) && void 0 !== t ? t : this.sdkVersion, n.preferDesktop = e.preferDesktop, n.addEventListener("close", ({ detail: { shouldTerminate: t } })=>e.onClose(t)), n.addEventListener("connectWithExtension", e.connectWithExtension), e.parentElement.appendChild(n), setTimeout(()=>this.updateQRCode(e.link), 100);
        });
    }
    renderPendingModal(e) {
        var t;
        return c(this, void 0, void 0, function*() {
            this.containers.pending = e.parentElement, yield this.loadComponent("pending");
            const n = document.createElement("mm-pending-modal");
            n.sdkVersion = null !== (t = e.sdkVersion) && void 0 !== t ? t : this.sdkVersion, n.displayOTP = e.displayOTP, n.addEventListener("close", e.onClose), n.addEventListener("updateOTPValue", ({ detail: { otpValue: t } })=>e.updateOTPValue(t)), e.onDisconnect && n.addEventListener("disconnect", e.onDisconnect), e.parentElement.appendChild(n);
        });
    }
    updateOTPValue(e) {
        const t = ()=>{
            var t;
            const n = null === (t = this.containers.pending) || void 0 === t ? void 0 : t.querySelector("mm-pending-modal");
            return !!n && (n.otpCode = e, !0);
        };
        setTimeout(()=>{
            t();
        }, 800);
    }
    updateQRCode(e) {
        var t, n;
        const r = null === (t = this.containers.install) || void 0 === t ? void 0 : t.querySelector("mm-install-modal");
        if (r) r.link = e;
        else {
            const t = null === (n = this.containers.select) || void 0 === n ? void 0 : n.querySelector("mm-select-modal");
            t && (t.link = e);
        }
    }
    unmount() {
        Object.entries(this.containers).forEach(([e, t])=>{
            var n;
            null === (n = null == t ? void 0 : t.parentNode) || void 0 === n || n.removeChild(t), this.containers[e] = void 0;
        });
    }
}
const Gh = ({ link: e, debug: t, installer: n, terminate: r, connectWithExtension: i, preferDesktop: o, onAnalyticsEvent: s })=>{
    let a = null, c = null;
    Au("[UI: InstallModal-web: sdkWebInstallModal()] ################## Installing Modal #################"), Au(`[UI: InstallModal-web: sdkWebInstallModal()] link=${e}`), Au(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e}" --ios`), Au(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e}" --android`), Au(`[UI: InstallModal-web: sdkWebInstallModal()] adb shell am start -a android.intent.action.VIEW -d "${e}"`);
    const l = (e)=>{
        var t;
        Au("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web unmounting install modal -- shouldTerminate:", e, c), (null == c ? void 0 : c.parentNode) && (null === (t = c.parentNode) || void 0 === t || t.removeChild(c)), c = null, a = null, !0 === e && (null == r || r());
    };
    return {
        mount: (r)=>{
            if (Au("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web mounting install modal", c), c) return c.style.display = "block", void (null == a || a.updateQRCode(r));
            a = new Vh({
                debug: t,
                sdkVersion: Zu.version
            }), c = document.createElement("div"), document.body.appendChild(c), window.extension ? a.renderSelectModal({
                parentElement: c,
                connectWithExtension: ()=>{
                    l(), null == i || i();
                },
                onClose: l,
                link: e,
                preferDesktop: null != o && o
            }).catch((e)=>{
                console.error(e);
            }) : a.renderInstallModal({
                parentElement: c,
                preferDesktop: null != o && o,
                link: e,
                metaMaskInstaller: n,
                onClose: l,
                onAnalyticsEvent: s
            }).catch((e)=>{
                console.error("[UI: InstallModal-web: sdkWebInstallModal()]", e);
            });
        },
        unmount: l
    };
}, Yh = ({ onDisconnect: e, debug: t })=>{
    let n = null, r = null;
    const i = ()=>{
        Au("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web unmount", n), (null == n ? void 0 : n.parentNode) && n.parentNode.removeChild(n), n = null, r = null;
    }, o = (e)=>{
        Au("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web updateOTPValue", e), r && r.updateOTPValue(e);
    }, s = ({ displayOTP: s } = {
        displayOTP: !0
    })=>{
        Au("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web mount", n), n ? n.style.display = "block" : (r = new Vh({
            debug: t,
            sdkVersion: Zu.version
        }), n = document.createElement("div"), document.body.appendChild(n), r.renderPendingModal({
            parentElement: n,
            onClose: i,
            onDisconnect: e,
            updateOTPValue: o,
            displayOTP: s
        }).catch((e)=>{
            console.error("[UI: pendingModal-web: sdkWebPendingModal()]", e);
        }));
    };
    return s(), {
        mount: s,
        unmount: i,
        updateOTPValue: o
    };
};
function Zh(e, t) {
    var n, r, i, o;
    e.connector || (Au("[RemoteConnection: initializeConnector()] initialize connector"), e.connector = new ts({
        anonId: t.anonId,
        platformType: t.platformManager.getPlatformType(),
        communicationLayerPreference: t.communicationLayerPreference,
        transports: t.transports,
        dappMetadata: Object.assign(Object.assign({}, t.dappMetadata), {
            source: t._source
        }),
        analytics: t.enableAnalytics,
        communicationServerUrl: t.communicationServerUrl,
        sdkVersion: Zu.version,
        context: "dapp",
        ecies: t.ecies,
        storage: t.storage,
        logging: t.logging
    }), t.timer && (Au("[RemoteConnection: initializeConnector()] reset background timer", t.timer), null === (r = null === (n = t.timer) || void 0 === n ? void 0 : n.stopBackgroundTimer) || void 0 === r || r.call(n), null === (o = null === (i = t.timer) || void 0 === i ? void 0 : i.runBackgroundTimer) || void 0 === o || o.call(i, ()=>!1, 1e4)));
}
function Jh(e) {
    e.listeners.forEach(({ event: t, handler: n })=>{
        var r;
        null === (r = e.connector) || void 0 === r || r.off(t, n);
    }), e.listeners = [];
}
function Qh(e, t, r) {
    return c(this, void 0, void 0, function*() {
        const i = setTimeout(()=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_connection_failed", {
                transport_type: "websocket"
            });
        }, 6e4);
        return new Promise((n, o)=>{
            if (!e.connector) return void o(new Error("No connector available"));
            Au("[RemoteConnection: connectWithModalInstaller()]", {
                state: e,
                options: t,
                linkParams: r
            });
            const s = `${e.useDeeplink ? Xu : Qu}?${r}`;
            !function(e, t, n) {
                var r, i, o, s;
                e.installModal = null === (i = (r = t.modals).install) || void 0 === i ? void 0 : i.call(r, {
                    link: n,
                    preferDesktop: e.preferDesktop,
                    installer: t.getMetaMaskInstaller(),
                    terminate: ()=>{
                        Au("[RemoteConnection: showInstallModal() => terminate()] terminate connection"), t.sdk.terminate().catch((e)=>{
                            console.warn("[MMSDK] failed to terminate connection", e);
                        });
                    },
                    debug: e.developerMode,
                    connectWithExtension: ()=>{
                        var e;
                        return null === (e = t.connectWithExtensionProvider) || void 0 === e || e.call(t), !1;
                    },
                    onAnalyticsEvent: ({ event: n, params: r })=>{
                        var i, o, s;
                        const a = Object.assign(Object.assign({}, r), {
                            sdkVersion: t.sdk.getVersion(),
                            dappId: null === (i = t.dappMetadata) || void 0 === i ? void 0 : i.name,
                            source: t._source,
                            url: null === (o = t.dappMetadata) || void 0 === o ? void 0 : o.url
                        });
                        null === (s = e.analytics) || void 0 === s || s.send({
                            event: n,
                            params: a
                        });
                    }
                }), null === (s = null === (o = e.installModal) || void 0 === o ? void 0 : o.mount) || void 0 === s || s.call(o, n);
            }(e, t, s), t.sdk.once(So.PROVIDER_UPDATE, (e)=>c(this, void 0, void 0, function*() {
                    if (Au("[RemoteConnection: connectWithModalInstaller()] once provider_update -- resolving startConnection promise"), e === hh.TERMINATE) {
                        const e = {
                            code: 4001,
                            message: "User rejected the request."
                        };
                        return clearTimeout(i), void o(e);
                    }
                    o(e);
                })), e.connector.once(So.AUTHORIZED, ()=>{
                clearTimeout(i), n();
            }), e.connector.once(So.REJECTED, ()=>{
                clearTimeout(i), o(So.REJECTED);
            }), e.connector.once(So.CLIENTS_READY, ()=>c(this, void 0, void 0, function*() {
                    Au("[RemoteConnection: connectWithModalInstaller()] once clients_ready -- resolving startConnection promise"), clearTimeout(i), n();
                }));
        });
    });
}
function Xh(e, t) {
    function n(t, n) {
        var r;
        null === (r = e.connector) || void 0 === r || r.on(t, n), e.listeners.push({
            event: t,
            handler: n
        });
    }
    e.connector && (Jh(e), n(So.WALLET_INIT, ({ accounts: e, chainId: t })=>c(this, void 0, void 0, function*() {
            Au(`[RemoteConnection: setupListeners() => EventType.WALLET_INIT] 'wallet_init' accounts=${e} chainId=${t}`);
            const n = qu.getProvider();
            n._setConnected();
            const r = {
                accounts: e,
                chainId: t,
                isUnlocked: !1
            };
            n._initializeState(r), n.emit("chainChanged", t), n.emit("accountsChanged", e);
        })), n(So.AUTHORIZED, ()=>c(this, void 0, void 0, function*() {
            var t, n, r, i;
            try {
                Au("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' closing modals", e.pendingModal, e.installModal);
                const o = qu.getProvider();
                o._setConnected(), null === (n = null === (t = e.pendingModal) || void 0 === t ? void 0 : t.unmount) || void 0 === n || n.call(t), null === (i = null === (r = e.installModal) || void 0 === r ? void 0 : r.unmount) || void 0 === i || i.call(r, !1), e.otpAnswer = void 0, e.authorized = !0, Au("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' provider.state", o.getState()), yield o.forceInitializeState();
            } catch (e) {}
        })), n(So.TERMINATE, ()=>{
        var t, n, r, i, o;
        null === (n = null === (t = e.pendingModal) || void 0 === t ? void 0 : t.unmount) || void 0 === n || n.call(t), null === (i = null === (r = e.installModal) || void 0 === r ? void 0 : r.unmount) || void 0 === i || i.call(r, !0), e.pendingModal = void 0, e.installModal = void 0, e.otpAnswer = void 0, null === (o = e.connector) || void 0 === o || o.disconnect({
            terminate: !0
        }), e.authorized = !1;
        qu.getProvider().handleDisconnect({
            terminate: !0
        }), Jh(e), Au("[RemoteConnection: setupListeners()] All listeners cleaned up");
    }));
}
function ef(e, t, { initialCheck: r, connectWith: i } = {}) {
    var o, s, a, l, d, u, h, f, p, g, m, y, v, b, w, E, S, _, C;
    return c(this, void 0, void 0, function*() {
        try {
            if (Zh(e, t), !e.connector) throw new Error("no connector defined");
            Xh(e);
            const k = qu.getProvider();
            e.authorized = !1, k.emit("connecting");
            const A = yield null === (o = e.connector) || void 0 === o ? void 0 : o.originatorSessionConnect();
            Au(`[RemoteConnection: startConnection()] after originatorSessionConnect initialCheck=${r}`, A);
            let x = null !== (s = null == A ? void 0 : A.channelId) && void 0 !== s ? s : "", M = null !== (l = null === (a = e.connector.getKeyInfo()) || void 0 === a ? void 0 : a.ecies.public) && void 0 !== l ? l : "", I = null !== (u = null === (d = e.connector.getKeyInfo()) || void 0 === d ? void 0 : d.ecies.private) && void 0 !== u ? u : "";
            if (r && !A) return Promise.resolve();
            if (!A && !r) {
                const t = yield e.connector.generateChannelIdConnect();
                x = null !== (h = t.channelId) && void 0 !== h ? h : "", M = null !== (f = t.pubKey) && void 0 !== f ? f : "", I = null !== (p = t.privKey) && void 0 !== p ? p : "";
                const n = Date.now();
                null === (g = e.connector.state.storageManager) || void 0 === g || g.persistChannelConfig({
                    channelId: x,
                    localKey: I,
                    lastActive: n,
                    validUntil: n + go
                });
            }
            if (r && (null == A ? void 0 : A.channelId)) return (null === (m = e.connector) || void 0 === m ? void 0 : m.isConnected()) || (Au(`[RemoteConnection: startConnection()] reconnecting to channel initialCheck=${r}`, A), yield null === (y = e.connector) || void 0 === y ? void 0 : y.connectToChannel({
                channelId: x
            })), Promise.resolve();
            A && !(null === (v = e.connector) || void 0 === v ? void 0 : v.isConnected()) && (Au("[RemoteConnection: startConnection()] reconnecting to channel", A), yield null === (b = e.connector) || void 0 === b ? void 0 : b.connectToChannel({
                channelId: x
            }));
            const T = (null === (w = e.platformManager) || void 0 === w ? void 0 : w.isSecure()) ? "" : "&t=q", R = Zu.version, { iconUrl: P, name: O, url: N, scheme: L } = t.dappMetadata || {}, D = null === (E = e.platformManager) || void 0 === E ? void 0 : E.getPlatformType();
            let $ = "N/A";
            ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : void 0 !== O ? $ = O : void 0 !== N && ($ = N);
            const B = {
                url: null != N ? N : "",
                title: null != O ? O : "",
                icon: P,
                scheme: null != L ? L : "",
                apiVersion: R,
                dappId: $ || N || "N/A",
                anonId: t.anonId,
                platform: null != D ? D : "",
                source: null !== (S = t._source) && void 0 !== S ? S : ""
            }, K = mh(JSON.stringify(B));
            let j = `channelId=${x}&v=2&comm=${null !== (_ = e.communicationLayerPreference) && void 0 !== _ ? _ : ""}&pubkey=${M}${T}&originatorInfo=${K}`;
            if (i) {
                j += `&rpc=${mh(JSON.stringify(i))}`;
                const t = e.connector.getRPCMethodTracker();
                t && (t[`${i.id}`] = Object.assign(Object.assign({}, i), {
                    id: `${i.id}`,
                    timestamp: Date.now()
                }));
            }
            const U = encodeURI(j), H = `${e.useDeeplink ? Xu : Qu}?${j}`;
            if (e.qrcodeLink = H, e.developerMode && Au(`[RemoteConnection: startConnection()] qrcodeLink=${U}`), k.emit("display_uri", H), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_connection_initiated", {
                transport_type: "websocket"
            }), null === (C = e.platformManager) || void 0 === C ? void 0 : C.isSecure()) {
                const t = setTimeout(()=>{
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_connection_failed", {
                        transport_type: "websocket"
                    });
                }, 6e4);
                return yield function(e, t) {
                    var n, r;
                    return c(this, void 0, void 0, function*() {
                        const i = `${Qu}?${t}`, o = `${Xu}?${t}`;
                        null === (r = null === (n = e.platformManager) || void 0 === n ? void 0 : n.openDeeplink) || void 0 === r || r.call(n, i, o, "_self");
                    });
                }(e, U), new Promise((n, r)=>{
                    var i, o, s;
                    if (null === (i = e.connector) || void 0 === i ? void 0 : i.isAuthorized()) return clearTimeout(t), void n();
                    null === (o = e.connector) || void 0 === o || o.once(So.AUTHORIZED, ()=>{
                        clearTimeout(t), n();
                    }), null === (s = e.connector) || void 0 === s || s.once(So.REJECTED, ()=>{
                        clearTimeout(t), r(So.REJECTED);
                    });
                });
            }
            return Qh(e, t, U);
        } catch (e) {
            throw console.error("[startConnection] error", e), e;
        }
    });
}
class tf {
    constructor(e){
        var t, n, r;
        this.state = {
            connector: void 0,
            qrcodeLink: void 0,
            analytics: void 0,
            developerMode: !1,
            authorized: !1,
            reconnection: !1,
            preferDesktop: !1,
            deeplinkProtocol: !1,
            listeners: [],
            communicationLayerPreference: void 0,
            platformManager: void 0,
            pendingModal: void 0,
            installModal: void 0,
            otpAnswer: void 0
        }, this.options = e;
        const i = !0 === (null === (t = e.logging) || void 0 === t ? void 0 : t.developerMode) || !0 === (null === (n = e.logging) || void 0 === n ? void 0 : n.sdk);
        this.state.developerMode = i, this.state.analytics = e.analytics, this.state.preferDesktop = null !== (r = e.preferDesktop) && void 0 !== r && r, this.state.useDeeplink = e.sdk.options.useDeeplink, this.state.communicationLayerPreference = e.communicationLayerPreference, this.state.platformManager = e.platformManager, e.modals.install || (e.modals.install = Gh), e.modals.otp || (e.modals.otp = Yh);
    }
    startConnection(e) {
        return c(this, void 0, void 0, function*() {
            return ef(this.state, this.options, e);
        });
    }
    initRemoteCommunication({ sdkInstance: e }) {
        var t, n, r;
        return c(this, void 0, void 0, function*() {
            const i = yield null === (n = null === (t = e.options.storage) || void 0 === t ? void 0 : t.storageManager) || void 0 === n ? void 0 : n.getPersistedChannelConfig();
            if (!this.options.ecies) {
                const e = {
                    privateKey: null == i ? void 0 : i.localKey
                };
                this.options.ecies = e;
            }
            Zh(this.state, this.options), yield null === (r = this.getConnector()) || void 0 === r ? void 0 : r.initFromDappStorage(), Xh(this.state, this.options);
        });
    }
    showActiveModal() {
        return function(e) {
            var t, n, r, i;
            e.authorized ? Au("[RemoteConnection: showActiveModal()] already authorized") : e.pendingModal ? null === (n = (t = e.pendingModal).mount) || void 0 === n || n.call(t) : e.installModal && (null === (i = (r = e.installModal).mount) || void 0 === i || i.call(r, e.qrcodeLink || ""));
        }(this.state);
    }
    closeModal() {
        var e, t, n, r;
        null === (t = null === (e = this.state.pendingModal) || void 0 === e ? void 0 : e.unmount) || void 0 === t || t.call(e), null === (r = null === (n = this.state.installModal) || void 0 === n ? void 0 : n.unmount) || void 0 === r || r.call(n, !1);
    }
    getUniversalLink() {
        if (!this.state.qrcodeLink) throw new Error("connection not started. run startConnection() first.");
        return this.state.qrcodeLink;
    }
    getChannelConfig() {
        var e;
        return null === (e = this.state.connector) || void 0 === e ? void 0 : e.getChannelConfig();
    }
    getKeyInfo() {
        var e;
        return null === (e = this.state.connector) || void 0 === e ? void 0 : e.getKeyInfo();
    }
    getConnector() {
        if (!this.state.connector) throw new Error("invalid remote connector");
        return this.state.connector;
    }
    getPlatformManager() {
        if (!this.state.platformManager) throw new Error("PlatformManager not available");
        return this.state.platformManager;
    }
    isConnected() {
        var e;
        return (null === (e = this.state.connector) || void 0 === e ? void 0 : e.isReady()) || !1;
    }
    isAuthorized() {
        var e;
        return (null === (e = this.state.connector) || void 0 === e ? void 0 : e.isAuthorized()) || !1;
    }
    isPaused() {
        var e;
        return null === (e = this.state.connector) || void 0 === e ? void 0 : e.isPaused();
    }
    disconnect(e) {
        var t, n, r;
        Au("[RemoteConnection: disconnect()]", e), (null == e ? void 0 : e.terminate) && (qu.getProvider().handleDisconnect({
            terminate: !0
        }), null === (n = null === (t = this.state.pendingModal) || void 0 === t ? void 0 : t.unmount) || void 0 === n || n.call(t), this.state.otpAnswer = void 0), null === (r = this.state.connector) || void 0 === r || r.disconnect(e), function(e) {
            Au("[RemoteConnection: cleanupConnector()] cleaning up connector"), e.connector && (Jh(e), e.connector.disconnect({
                terminate: !0
            }).catch((e)=>{
                Au("[RemoteConnection: cleanupConnector()] error disconnecting connector", e);
            }));
        }(this.state);
    }
}
function nf(e) {
    var r, i, o, s, a, l, d, u, h, f, p;
    return c(this, void 0, void 0, function*() {
        const { options: g } = e;
        if (g.logging = null !== (r = g.logging) && void 0 !== r ? r : {}, g.communicationLayerPreference = null !== (i = g.communicationLayerPreference) && void 0 !== i ? i : jo.SOCKET, void 0 !== g.enableDebug && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].enable("MM_SDK"), console.warn("enableDebug is removed. Please use enableAnalytics instead.")), g.enableAnalytics = null === (o = g.enableAnalytics) || void 0 === o || o, g.injectProvider = null === (s = g.injectProvider) || void 0 === s || s, g.shouldShimWeb3 = null === (a = g.shouldShimWeb3) || void 0 === a || a, g.extensionOnly = null === (l = g.extensionOnly) || void 0 === l || l, g.useDeeplink = null === (d = g.useDeeplink) || void 0 === d || d, g.storage = null !== (u = g.storage) && void 0 !== u ? u : {
            enabled: !0
        }, g.headless) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])("[MetaMaskSDK: performSDKInitialization()] headless mode enabled");
            const e = ()=>{}, n = {
                install: ()=>({
                        mount: e,
                        unmount: e
                    })
            }, r = {
                installer: e
            };
            g.modals = n, g.ui = r;
        }
        const m = !0 === (null === (h = g.logging) || void 0 === h ? void 0 : h.developerMode);
        e.debug = (null === (f = g.logging) || void 0 === f ? void 0 : f.sdk) || m, Au("[MetaMaskSDK: performSDKInitialization()] options", e.options);
        const y = Object.assign({}, g.logging);
        m && (y.sdk = !0, y.eciesLayer = !0, y.keyExchangeLayer = !0, y.remoteLayer = !0, y.serviceLayer = !0, y.plaintext = !0), yield function(e) {
            var t;
            return c(this, void 0, void 0, function*() {
                const { options: n } = e;
                e.platformManager = new Wu({
                    useDeepLink: null !== (t = n.useDeeplink) && void 0 !== t && t,
                    preferredOpenLink: n.openDeeplink,
                    debug: e.debug
                });
            });
        }(e), yield function(e) {
            var t, n, r, i, o;
            return c(this, void 0, void 0, function*() {
                const { options: s } = e, a = null === (t = e.platformManager) || void 0 === t ? void 0 : t.getPlatformType();
                e.analytics = new Ch({
                    serverUrl: null !== (n = s.communicationServerUrl) && void 0 !== n ? n : fo,
                    enabled: s.enableAnalytics,
                    originatorInfo: {
                        url: null !== (r = s.dappMetadata.url) && void 0 !== r ? r : "",
                        title: null !== (i = s.dappMetadata.name) && void 0 !== i ? i : "",
                        dappId: e.getDappId(),
                        platform: null != a ? a : "",
                        source: null !== (o = s._source) && void 0 !== o ? o : "",
                        anonId: ""
                    }
                });
            });
        }(e), yield function(e) {
            var t, r, i;
            return c(this, void 0, void 0, function*() {
                if (!e.options.enableAnalytics) return;
                if (!(null === (t = e.platformManager) || void 0 === t ? void 0 : t.isBrowser()) && !(null === (r = e.platformManager) || void 0 === r ? void 0 : r.isReactNative())) return;
                const o = e.getVersion(), s = e.getDappId(), a = yield e.getAnonId(), c = null === (i = e.platformManager) || void 0 === i ? void 0 : i.getPlatformType(), l = e.options._source;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].setGlobalProperty("sdk_version", o), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].setGlobalProperty("dapp_id", s), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].setGlobalProperty("anon_id", a), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].setGlobalProperty("platform", c), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].setGlobalProperty("integration_type", l), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].enable(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2d$analytics$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["analytics"].track("sdk_initialized", {});
            });
        }(e), yield function(e) {
            var t;
            return c(this, void 0, void 0, function*() {
                const { options: n } = e;
                !0 !== (null === (t = n.storage) || void 0 === t ? void 0 : t.enabled) || n.storage.storageManager || (n.storage.storageManager = yield Vu(n.storage));
            });
        }(e), yield function(e) {
            return c(this, void 0, void 0, function*() {
                const { options: t } = e, n = /^(http|https):\/\/[^\s]*$/;
                if (t.dappMetadata) {
                    t.dappMetadata.iconUrl && !n.test(t.dappMetadata.iconUrl) && (console.warn("Invalid dappMetadata.iconUrl: URL must start with http:// or https://"), t.dappMetadata.iconUrl = void 0), t.dappMetadata.base64Icon && t.dappMetadata.base64Icon.length > Ah && (console.warn("Invalid dappMetadata.base64Icon: Base64-encoded icon string length must be less than 163400 characters"), t.dappMetadata.base64Icon = void 0), t.dappMetadata.url && !n.test(t.dappMetadata.url) && console.warn("Invalid dappMetadata.url: URL must start with http:// or https://");
                    const e = kh();
                    if (e && !t.dappMetadata.iconUrl && !t.dappMetadata.base64Icon) {
                        const n = `${window.location.protocol}//${window.location.host}${e}`;
                        t.dappMetadata.iconUrl = n;
                    }
                }
                e.dappMetadata = t.dappMetadata;
            });
        }(e), yield Ph(e), yield Oh(e);
        const { metamaskBrowserExtension: v, preferExtension: b, shouldReturn: w } = yield function(e) {
            var t, n, r, i;
            return c(this, void 0, void 0, function*() {
                const { options: o } = e;
                let s, a = !1, l = !1;
                if ("undefined" != ("TURBOPACK compile-time value", "undefined") && window.ethereum && !(null === (t = e.platformManager) || void 0 === t ? void 0 : t.isMetaMaskMobileWebView())) //TURBOPACK unreachable
                ;
                else (null === (n = e.platformManager) || void 0 === n ? void 0 : n.isMetaMaskMobileWebView()) && (null === (r = e.analytics) || void 0 === r || r.send({
                    event: Ao.SDK_USE_INAPP_BROWSER
                }), e.activeProvider = Ih({
                    provider: window.ethereum,
                    sdkInstance: e
                }), e._initialized = !0, l = !0);
                return s && o.extensionOnly && (Au("[MetaMaskSDK: setupExtensionPreferences()] EXTENSION ONLY --- prevent sdk initialization"), null === (i = e.analytics) || void 0 === i || i.send({
                    event: Ao.SDK_USE_EXTENSION
                }), e.activeProvider = s, e.extensionActive = !0, e.extension = s, e._initialized = !0, l = !0), {
                    preferExtension: a,
                    shouldReturn: l,
                    metamaskBrowserExtension: s
                };
            });
        }(e);
        if (w) Au("[MetaMaskSDK: performSDKInitialization()] shouldReturn=true --- prevent sdk initialization");
        else {
            yield function(e, t) {
                var n, r, i, o, s;
                return c(this, void 0, void 0, function*() {
                    const { options: a } = e, c = Object.assign({}, a.logging);
                    e.remoteConnection = new tf({
                        anonId: yield e.getAnonId(),
                        preferDesktop: null !== (n = a.preferDesktop) && void 0 !== n && n,
                        communicationLayerPreference: null !== (r = a.communicationLayerPreference) && void 0 !== r ? r : jo.SOCKET,
                        analytics: e.analytics,
                        dappMetadata: a.dappMetadata,
                        _source: a._source,
                        enableAnalytics: null === (i = a.enableAnalytics) || void 0 === i || i,
                        timer: a.timer,
                        sdk: e,
                        platformManager: e.platformManager,
                        transports: a.transports,
                        communicationServerUrl: a.communicationServerUrl,
                        storage: null !== (o = a.storage) && void 0 !== o ? o : {
                            enabled: !0
                        },
                        getMetaMaskInstaller: ()=>{
                            if (!e.installer) throw new Error("Invalid SDK status -- installer not initialized");
                            return e.installer;
                        },
                        logging: c,
                        connectWithExtensionProvider: void 0 === t ? void 0 : ()=>gh(e),
                        modals: Object.assign(Object.assign({}, a.modals), {
                            onPendingModalDisconnect: e.terminate.bind(e)
                        })
                    }), yield e.remoteConnection.initRemoteCommunication({
                        sdkInstance: e
                    }), e.installer = new Wh({
                        remote: e.remoteConnection,
                        preferDesktop: null !== (s = a.preferDesktop) && void 0 !== s && s,
                        platformManager: e.platformManager,
                        debug: e.debug
                    });
                });
            }(e, v), yield Sh(e), yield function(e, t) {
                var n, r;
                return c(this, void 0, void 0, function*() {
                    const { options: i } = e;
                    t ? (Au("[MetaMaskSDK: handleAutoAndExtensionConnections()] preferExtension is detected -- connect with it."), null === (n = e.analytics) || void 0 === n || n.send({
                        event: Ao.SDK_EXTENSION_UTILIZED
                    }), gh(e).catch((e)=>{
                        console.warn("Can't connect with MetaMask extension...", e), localStorage.removeItem(ah);
                    })) : i.checkInstallationImmediately && ((null === (r = e.platformManager) || void 0 === r ? void 0 : r.isDesktopWeb()) ? (Au("[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately"), e.connect().catch((e)=>{
                        Au(`[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- error on autoconnect _err=${e}`);
                    })) : console.warn("[handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- only for web desktop")), e._initialized = !0;
                });
            }(e, b);
            try {
                yield null === (p = e.remoteConnection) || void 0 === p ? void 0 : p.startConnection({
                    initialCheck: !0
                });
            } catch (e) {
                console.error("[MetaMaskSDK: setupRemoteConnectionAndInstaller()] Error while checking installation", e);
            }
            e.emit(zu.ProviderUpdate, hh.INITIALIZED);
        }
    });
}
class rf extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter2$2f$lib$2f$eventemitter2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"] {
    constructor(e = {
        storage: {
            enabled: !0
        },
        injectProvider: !0,
        forceInjectProvider: !1,
        enableAnalytics: !0,
        shouldShimWeb3: !0,
        useDeeplink: !0,
        extensionOnly: !0,
        headless: !1,
        dappMetadata: {
            name: "",
            url: "",
            iconUrl: ""
        },
        _source: Ju,
        i18nOptions: {
            enabled: !1
        }
    }){
        var n, r, i;
        super(), this.extensionActive = !1, this._initialized = !1, this.sdkInitPromise = void 0, this.debug = !1, this.readonlyRPCCalls = !1, this.availableLanguages = [
            "en"
        ], this.ANON_ID_STORAGE_KEY = "mm-sdk-anon-id", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].disable();
        const o = !0 === (null === (n = e.logging) || void 0 === n ? void 0 : n.developerMode);
        if (((null === (r = e.logging) || void 0 === r ? void 0 : r.sdk) || o) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$sdk$2f$node_modules$2f$debug$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].enable("MM_SDK"), Au("[MetaMaskSDK: constructor()]: begin."), this.setMaxListeners(50), !(null === (i = e.dappMetadata) || void 0 === i ? void 0 : i.url)) {
            if ("TURBOPACK compile-time truthy", 1) throw new Error("You must provide dAppMetadata url");
            e.dappMetadata = Object.assign(Object.assign({}, e.dappMetadata), {
                url: `${window.location.protocol}//${window.location.host}`
            });
        }
        this.options = e, this.options._source || (e._source = Ju), this.init().then(()=>{
            Au("[MetaMaskSDK: constructor()]: initialized successfully."), "undefined" != ("TURBOPACK compile-time value", "undefined") && (window.mmsdk = this);
        }).catch((e)=>{
            console.error("[MetaMaskSDK: constructor()] error during initialization", e);
        });
    }
    init() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                var t;
                return c(this, void 0, void 0, function*() {
                    if ("undefined" != ("TURBOPACK compile-time value", "undefined") && (null === (t = window.mmsdk) || void 0 === t ? void 0 : t.isInitialized())) //TURBOPACK unreachable
                    ;
                    if (e._initialized) return Au("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), e.sdkInitPromise;
                    if (e.sdkInitPromise) return Au("[MetaMaskSDK: initializeMetaMaskSDK()] already initializing"), e.sdkInitPromise;
                    try {
                        e.sdkInitPromise = nf(e), yield e.sdkInitPromise;
                    } catch (e) {
                        throw console.error(e), e;
                    }
                    return e.sdkInitPromise;
                });
            }(this);
        });
    }
    isExtensionActive() {
        return this.extensionActive;
    }
    checkExtensionAvailability() {
        var e;
        return "undefined" != ("TURBOPACK compile-time value", "undefined") && Boolean(null === (e = window.ethereum) || void 0 === e ? void 0 : e.isMetaMask);
    }
    connect() {
        return c(this, void 0, void 0, function*() {
            return function(e) {
                return c(this, void 0, void 0, function*() {
                    if (e._initialized || (Au("[MetaMaskSDK: connect()] provider not ready -- wait for init()"), yield e.init()), Au(`[MetaMaskSDK: connect()] isExtensionActive=${e.isExtensionActive()} activeProvider`, e.activeProvider), !e.activeProvider) throw new Error("SDK state invalid -- undefined provider");
                    const t = e.activeProvider.getSelectedAddress();
                    return t ? [
                        t
                    ] : e.activeProvider.request({
                        method: nh.ETH_REQUESTACCOUNTS,
                        params: []
                    });
                });
            }(this);
        });
    }
    connectAndSign({ msg: e }) {
        return c(this, void 0, void 0, function*() {
            return ph({
                instance: this,
                msg: e
            });
        });
    }
    connectWith(e) {
        return c(this, void 0, void 0, function*() {
            return function({ instance: e, rpc: t }) {
                return c(this, void 0, void 0, function*() {
                    if (e._initialized || (Au("[MetaMaskSDK: connectWith()] provider not ready -- wait for init()"), yield e.init()), Au(`[MetaMaskSDK: connectWith()] method: ${t.method} rpc=${t}`), !e.activeProvider) throw new Error("SDK state invalid -- undefined provider");
                    return e.activeProvider.request({
                        method: nh.METAMASK_CONNECTWITH,
                        params: [
                            t
                        ]
                    });
                });
            }({
                instance: this,
                rpc: e
            });
        });
    }
    resume() {
        return function(e) {
            var t, n, r;
            return c(this, void 0, void 0, function*() {
                if (!(null === (n = null === (t = e.remoteConnection) || void 0 === t ? void 0 : t.getConnector()) || void 0 === n ? void 0 : n.isReady())) return Au("[MetaMaskSDK: resume()] channel is not ready -- starting connection"), void (null === (r = e.remoteConnection) || void 0 === r || r.startConnection());
                Au("[MetaMaskSDK: resume()] channel is ready");
            });
        }(this);
    }
    disconnect() {
        return console.warn("MetaMaskSDK.disconnect() is deprecated, use terminate()"), this.terminate();
    }
    isAuthorized() {
        var e;
        null === (e = this.remoteConnection) || void 0 === e || e.isAuthorized();
    }
    terminate() {
        return function(e) {
            var t, n, r;
            return c(this, void 0, void 0, function*() {
                if (!(null === (t = e.platformManager) || void 0 === t ? void 0 : t.isMetaMaskMobileWebView())) {
                    if (fh && (window.localStorage.removeItem(ah), window.localStorage.removeItem(lh), window.localStorage.removeItem(ch)), e.extensionActive) {
                        try {
                            yield null === (n = e.activeProvider) || void 0 === n ? void 0 : n.request({
                                method: nh.WALLET_REVOKEPERMISSIONS,
                                params: [
                                    {
                                        eth_accounts: {}
                                    }
                                ]
                            });
                        } catch (e) {
                            Au("[MetaMaskSDK: terminate()] error revoking permissions", e);
                        }
                        return e.options.extensionOnly ? (e.emit(zu.ProviderUpdate, hh.TERMINATE), void Au("[MetaMaskSDK: terminate()] extensionOnly --- prevent switching providers")) : (e.activeProvider = e.sdkProvider, window.ethereum = e.activeProvider, e.extensionActive = !1, void e.emit(zu.ProviderUpdate, hh.TERMINATE));
                    }
                    e.emit(zu.ProviderUpdate, hh.TERMINATE), Au(`[MetaMaskSDK: terminate()] remoteConnection=${e.remoteConnection}`), null === (r = e.remoteConnection) || void 0 === r || r.disconnect({
                        terminate: !0,
                        sendMessage: !0
                    });
                }
            });
        }(this);
    }
    isInitialized() {
        return this._initialized;
    }
    setReadOnlyRPCCalls(e) {
        this.readonlyRPCCalls = e;
    }
    hasReadOnlyRPCCalls() {
        return this.readonlyRPCCalls;
    }
    getProvider() {
        if (this.activeProvider) return this.activeProvider;
        console.warn("MetaMaskSDK: No active provider found");
    }
    getMobileProvider() {
        if (!this.sdkProvider) throw new Error("SDK state invalid -- undefined mobile provider");
        return this.sdkProvider;
    }
    getUniversalLink() {
        var e;
        const t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getUniversalLink();
        if (!t) throw new Error("No Universal Link available, please call eth_requestAccounts first.");
        return t;
    }
    getChannelId() {
        var e, t;
        return null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getChannelConfig()) || void 0 === t ? void 0 : t.channelId;
    }
    getRPCHistory() {
        var e, t;
        return null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t ? void 0 : t.getRPCMethodTracker();
    }
    getVersion() {
        return Zu.version;
    }
    getDappId() {
        var e, t, n, r;
        return ("TURBOPACK compile-time truthy", 1) ? null !== (r = null !== (t = null === (e = this.options.dappMetadata) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : null === (n = this.options.dappMetadata) || void 0 === n ? void 0 : n.url) && void 0 !== r ? r : "N/A" : "TURBOPACK unreachable";
    }
    getAnonId() {
        var e, t;
        return c(this, void 0, void 0, function*() {
            if (this._anonId) return this._anonId;
            let n;
            return n = (null === (e = this.platformManager) || void 0 === e ? void 0 : e.isBrowser()) ? this.getBrowserAnonId() : (null === (t = this.platformManager) || void 0 === t ? void 0 : t.isReactNative()) ? yield this.getReactNativeAnonId() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])(), this._anonId = n, n;
        });
    }
    getBrowserAnonId() {
        const e = this.ANON_ID_STORAGE_KEY;
        try {
            const t = localStorage.getItem(e);
            if (t) return t;
            const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
            return localStorage.setItem(e, n), n;
        } catch (e) {
            return console.error("[MetaMaskSDK: getBrowserAnonId()] LocalStorage access error:", e), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
        }
    }
    getReactNativeAnonId() {
        return c(this, void 0, void 0, function*() {
            const e = this.ANON_ID_STORAGE_KEY;
            try {
                const t = (()=>{
                    const e = new Error("Cannot find module '@react-native-async-storage/async-storage'");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })().default, n = yield t.getItem(e);
                if (n) return n;
                const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
                return yield t.setItem(e, r), r;
            } catch (e) {
                return console.error("[MetaMaskSDK: getReactNativeAnonId()] Error accessing AsyncStorage:", e), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
            }
        });
    }
    getWalletStatus() {
        var e, t;
        return null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t ? void 0 : t.getConnectionStatus();
    }
    _getChannelConfig() {
        var e;
        return null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getChannelConfig();
    }
    _ping() {
        var e, t;
        null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t || t.ping();
    }
    _keyCheck() {
        var e, t;
        null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t || t.keyCheck();
    }
    _getServiceStatus() {
        var e, t;
        return null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t ? void 0 : t.getServiceStatus();
    }
    _getRemoteConnection() {
        return this.remoteConnection;
    }
    _getDappMetadata() {
        return this.dappMetadata;
    }
    _getKeyInfo() {
        var e;
        return null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getKeyInfo();
    }
    _resetKeys() {
        var e, t;
        null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t || t.resetKeys();
    }
    _getConnection() {
        return this.remoteConnection;
    }
    emit(e, t) {
        return super.emit(e, t);
    }
    on(e, t) {
        return super.on(e, t);
    }
}
var of = Object.freeze({
    __proto__: null,
    StorageManagerWeb: class {
        constructor({ enabled: e } = {
            enabled: !1
        }){
            this.enabled = !1, this.enabled = e;
        }
        persistChannelConfig(e) {
            return c(this, void 0, void 0, function*() {
                const t = JSON.stringify(e);
                Au(`[StorageManagerWeb: persistChannelConfig()] enabled=${this.enabled}`, e), localStorage.setItem(sh, t);
            });
        }
        getPersistedChannelConfig() {
            return c(this, void 0, void 0, function*() {
                let e;
                try {
                    if (Au(`[StorageManagerWeb: getPersistedChannelConfig()] enabled=${this.enabled}`), e = localStorage.getItem(sh), Au("[StorageManagerWeb: getPersistedChannelConfig()]", e), !e) return;
                    const t = JSON.parse(e);
                    return Au("[StorageManagerWeb: getPersistedChannelConfig()] channelConfig", t), t;
                } catch (e) {
                    return void console.error("[StorageManagerWeb: getPersistedChannelConfig()] Can't find existing channel config", e);
                }
            });
        }
        persistAccounts(e) {
            return c(this, void 0, void 0, function*() {
                Au(`[StorageManagerWeb: persistAccounts()] enabled=${this.enabled}`, e);
                const t = JSON.stringify(e);
                localStorage.setItem(ch, t);
            });
        }
        getCachedAccounts() {
            return c(this, void 0, void 0, function*() {
                try {
                    const e = localStorage.getItem(ch);
                    return e ? JSON.parse(e) : [];
                } catch (e) {
                    throw console.error("[StorageManagerWeb: getCachedAccounts()] Error reading cached accounts", e), e;
                }
            });
        }
        persistChainId(e) {
            return c(this, void 0, void 0, function*() {
                Au(`[StorageManagerWeb: persistChainId()] enabled=${this.enabled}`, e), localStorage.setItem(lh, e);
            });
        }
        getCachedChainId() {
            return c(this, void 0, void 0, function*() {
                try {
                    const e = localStorage.getItem(lh);
                    return null != e ? e : void 0;
                } catch (e) {
                    throw console.error("[StorageManagerWeb: getCachedChainId()] Error reading cached chainId", e), e;
                }
            });
        }
        terminate() {
            return c(this, void 0, void 0, function*() {
                Au(`[StorageManagerWeb: terminate()] enabled=${this.enabled}`), localStorage.removeItem(sh);
            });
        }
    }
});
const sf = "hydrated", af = !1, cf = !1, lf = !0;
var df = Object.defineProperty, uf = new WeakMap, hf = (e)=>uf.get(e), ff = (e, t)=>uf.set(t.$lazyInstance$ = e, t), pf = (e, t)=>t in e, gf = (e, t)=>(0, console.error)(e, t), mf = new Map, yf = new Map, vf = "slot-fb{display:contents}slot-fb[hidden]{display:none}", bf = ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : {}, wf = bf.document || {
    head: {}
}, Ef = {
    $flags$: 0,
    $resourcesUrl$: "",
    jmp: (e)=>e(),
    raf: (e)=>requestAnimationFrame(e),
    ael: (e, t, n, r)=>e.addEventListener(t, n, r),
    rel: (e, t, n, r)=>e.removeEventListener(t, n, r),
    ce: (e, t)=>new CustomEvent(e, t)
}, Sf = (()=>{
    try {
        return new CSSStyleSheet, "function" == typeof (new CSSStyleSheet).replaceSync;
    } catch (e) {}
    return !1;
})(), _f = !1, Cf = [], kf = [], Af = (e, t)=>(t)=>{
        e.push(t), _f || (_f = !0, 4 & Ef.$flags$ ? If(Mf) : Ef.raf(Mf));
    }, xf = (e)=>{
    for(let t = 0; t < e.length; t++)try {
        e[t](performance.now());
    } catch (e) {
        gf(e);
    }
    e.length = 0;
}, Mf = ()=>{
    xf(Cf), xf(kf), (_f = Cf.length > 0) && Ef.raf(Mf);
}, If = (e)=>((e)=>Promise.resolve(e))().then(e), Tf = Af(kf), Rf = {}, Pf = (e)=>"object" === (e = typeof e) || "function" === e;
function Of(e) {
    var t, n, r;
    return null != (r = null == (n = null == (t = e.head) ? void 0 : t.querySelector('meta[name="csp-nonce"]')) ? void 0 : n.getAttribute("content")) ? r : void 0;
}
((e, t)=>{
    for(var n in t)df(e, n, {
        get: t[n],
        enumerable: !0
    });
})({}, {
    err: ()=>Lf,
    map: ()=>Df,
    ok: ()=>Nf,
    unwrap: ()=>Kf,
    unwrapErr: ()=>jf
});
var Nf = (e)=>({
        isOk: !0,
        isErr: !1,
        value: e
    }), Lf = (e)=>({
        isOk: !1,
        isErr: !0,
        value: e
    });
function Df(e, t) {
    if (e.isOk) {
        const n = t(e.value);
        return n instanceof Promise ? n.then((e)=>Nf(e)) : Nf(n);
    }
    if (e.isErr) {
        const t = e.value;
        return Lf(t);
    }
    throw "should never get here";
}
var $f, Bf, Kf = (e)=>{
    if (e.isOk) return e.value;
    throw e.value;
}, jf = (e)=>{
    if (e.isErr) return e.value;
    throw e.value;
}, Uf = (e, t, ...n)=>{
    let r = null, i = !1, o = !1;
    const s = [], a = (t)=>{
        for(let n = 0; n < t.length; n++)r = t[n], Array.isArray(r) ? a(r) : null != r && "boolean" != typeof r && ((i = "function" != typeof e && !Pf(r)) && (r = String(r)), i && o ? s[s.length - 1].$text$ += r : s.push(i ? Hf(null, r) : r), o = i);
    };
    if (a(n), t) {
        const e = t.className || t.class;
        e && (t.class = "object" != typeof e ? e : Object.keys(e).filter((t)=>e[t]).join(" "));
    }
    if ("function" == typeof e) return e(null === t ? {} : t, s, zf);
    const c = Hf(e, null);
    return c.$attrs$ = t, s.length > 0 && (c.$children$ = s), c;
}, Hf = (e, t)=>{
    const n = {
        $flags$: 0,
        $tag$: e,
        $text$: t,
        $elm$: null,
        $children$: null,
        $attrs$: null
    };
    return n;
}, Ff = {}, zf = {
    forEach: (e, t)=>e.map(qf).forEach(t),
    map: (e, t)=>e.map(qf).map(t).map(Wf)
}, qf = (e)=>({
        vattrs: e.$attrs$,
        vchildren: e.$children$,
        vkey: e.$key$,
        vname: e.$name$,
        vtag: e.$tag$,
        vtext: e.$text$
    }), Wf = (e)=>{
    if ("function" == typeof e.vtag) {
        const t = {
            ...e.vattrs
        };
        return e.vkey && (t.key = e.vkey), e.vname && (t.name = e.vname), Uf(e.vtag, t, ...e.vchildren || []);
    }
    const t = Hf(e.vtag, e.vtext);
    return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t;
}, Vf = (e)=>hf(e).$hostElement$, Gf = (e, t, n)=>{
    const r = Vf(e);
    return {
        emit: (e)=>Yf(r, t, {
                bubbles: !!(4 & n),
                composed: !!(2 & n),
                cancelable: !!(1 & n),
                detail: e
            })
    };
}, Yf = (e, t, n)=>{
    const r = Ef.ce(t, n);
    return e.dispatchEvent(r), r;
}, Zf = new WeakMap, Jf = (e)=>{
    const t = e.$cmpMeta$, n = e.$hostElement$, r = t.$flags$, i = (t.$tagName$, ()=>{}), o = ((e, t, n)=>{
        var r;
        const i = Qf(t), o = yf.get(i);
        if (e = 11 === e.nodeType ? e : wf, o) if ("string" == typeof o) {
            e = e.head || e;
            let n, s = Zf.get(e);
            if (s || Zf.set(e, s = new Set), !s.has(i)) {
                {
                    n = wf.createElement("style"), n.innerHTML = o;
                    const i = null != (r = Ef.$nonce$) ? r : Of(wf);
                    if (null != i && n.setAttribute("nonce", i), !(1 & t.$flags$)) if ("HEAD" === e.nodeName) {
                        const t = e.querySelectorAll("link[rel=preconnect]"), r = t.length > 0 ? t[t.length - 1].nextSibling : e.querySelector("style");
                        e.insertBefore(n, r);
                    } else if ("host" in e) if (Sf) {
                        const t = new CSSStyleSheet;
                        t.replaceSync(o), e.adoptedStyleSheets = [
                            t,
                            ...e.adoptedStyleSheets
                        ];
                    } else {
                        const t = e.querySelector("style");
                        t ? t.innerHTML = o + t.innerHTML : e.prepend(n);
                    }
                    else e.append(n);
                    1 & t.$flags$ && "HEAD" !== e.nodeName && e.insertBefore(n, null);
                }
                4 & t.$flags$ && (n.innerHTML += vf), s && s.add(i);
            }
        } else e.adoptedStyleSheets.includes(o) || (e.adoptedStyleSheets = [
            ...e.adoptedStyleSheets,
            o
        ]);
        return i;
    })(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t);
    10 & r && 2 & r && (n["s-sc"] = o, n.classList.add(o + "-h")), i();
}, Qf = (e, t)=>"sc-" + e.$tagName$, Xf = (e, t, n, r, i, o)=>{
    if (n !== r) {
        let s = pf(e, t), a = t.toLowerCase();
        if ("class" === t) {
            const t = e.classList, i = tp(n), o = tp(r);
            t.remove(...i.filter((e)=>e && !o.includes(e))), t.add(...o.filter((e)=>e && !i.includes(e)));
        } else if ("style" === t) {
            for(const t in n)r && null != r[t] || (t.includes("-") ? e.style.removeProperty(t) : e.style[t] = "");
            for(const t in r)n && r[t] === n[t] || (t.includes("-") ? e.style.setProperty(t, r[t]) : e.style[t] = r[t]);
        } else if (s || "o" !== t[0] || "n" !== t[1]) {
            const a = Pf(r);
            if ((s || a && null !== r) && !i) try {
                if (e.tagName.includes("-")) e[t] = r;
                else {
                    const i = null == r ? "" : r;
                    "list" === t ? s = !1 : null != n && e[t] == i || ("function" == typeof e.__lookupSetter__(t) ? e[t] = i : e.setAttribute(t, i));
                }
            } catch (e) {}
            null == r || !1 === r ? !1 === r && "" !== e.getAttribute(t) || e.removeAttribute(t) : (!s || 4 & o || i) && !a && (r = !0 === r ? "" : r, e.setAttribute(t, r));
        } else if (t = "-" === t[2] ? t.slice(3) : pf(bf, a) ? a.slice(2) : a[2] + t.slice(3), n || r) {
            const i = t.endsWith(np);
            t = t.replace(rp, ""), n && Ef.rel(e, t, n, i), r && Ef.ael(e, t, r, i);
        }
    }
}, ep = /\s/, tp = (e)=>e ? e.split(ep) : [], np = "Capture", rp = new RegExp(np + "$"), ip = (e, t, n)=>{
    const r = 11 === t.$elm$.nodeType && t.$elm$.host ? t.$elm$.host : t.$elm$, i = e && e.$attrs$ || Rf, o = t.$attrs$ || Rf;
    for (const e of op(Object.keys(i)))e in o || Xf(r, e, i[e], void 0, n, t.$flags$);
    for (const e of op(Object.keys(o)))Xf(r, e, i[e], o[e], n, t.$flags$);
};
function op(e) {
    return e.includes("ref") ? [
        ...e.filter((e)=>"ref" !== e),
        "ref"
    ] : e;
}
var sp = !1, ap = !1, cp = (e, t, n, r)=>{
    const i = t.$children$[n];
    let o, s, a = 0;
    if (null !== i.$text$) o = i.$elm$ = wf.createTextNode(i.$text$);
    else {
        ap || (ap = "svg" === i.$tag$), o = i.$elm$ = wf.createElementNS(ap ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", !sp && cf && 2 & i.$flags$ ? "TURBOPACK unreachable" : i.$tag$), ap && "foreignObject" === i.$tag$ && (ap = !1), ip(null, i, ap);
        if (!!o.getRootNode().querySelector("body") && af && ((e)=>null != e)($f) && o["s-si"] !== $f && o.classList.add(o["s-si"] = $f), i.$children$) for(a = 0; a < i.$children$.length; ++a)s = cp(e, i, a), s && o.appendChild(s);
        "svg" === i.$tag$ ? ap = !1 : "foreignObject" === o.tagName && (ap = !0);
    }
    return o["s-hn"] = Bf, o;
}, lp = (e, t, n, r, i, o)=>{
    let s, a = e;
    for(a.shadowRoot && a.tagName === Bf && (a = a.shadowRoot); i <= o; ++i)r[i] && (s = cp(null, n, i), s && (r[i].$elm$ = s, fp(a, s, t)));
}, dp = (e, t, n)=>{
    for(let r = t; r <= n; ++r){
        const t = e[r];
        if (t) {
            const e = t.$elm$;
            e && e.remove();
        }
    }
}, up = (e, t, n = !1)=>e.$tag$ === t.$tag$, hp = (e, t, n = !1)=>{
    const r = t.$elm$ = e.$elm$, i = e.$children$, o = t.$children$, s = t.$tag$, a = t.$text$;
    null === a ? (ip(e, t, ap = "svg" === s || "foreignObject" !== s && ap), null !== i && null !== o ? ((e, t, n, r, i = !1)=>{
        let o, s = 0, a = 0, c = t.length - 1, l = t[0], d = t[c], u = r.length - 1, h = r[0], f = r[u];
        for(; s <= c && a <= u;)null == l ? l = t[++s] : null == d ? d = t[--c] : null == h ? h = r[++a] : null == f ? f = r[--u] : up(l, h, i) ? (hp(l, h, i), l = t[++s], h = r[++a]) : up(d, f, i) ? (hp(d, f, i), d = t[--c], f = r[--u]) : up(l, f, i) ? (hp(l, f, i), fp(e, l.$elm$, d.$elm$.nextSibling), l = t[++s], f = r[--u]) : up(d, h, i) ? (hp(d, h, i), fp(e, d.$elm$, l.$elm$), d = t[--c], h = r[++a]) : (o = cp(t && t[a], n, a), h = r[++a], o && fp(l.$elm$.parentNode, o, l.$elm$));
        s > c ? lp(e, null == r[u + 1] ? null : r[u + 1].$elm$, n, r, a, u) : a > u && dp(t, s, c);
    })(r, i, t, o, n) : null !== o ? (null !== e.$text$ && (r.textContent = ""), lp(r, null, t, o, 0, o.length - 1)) : !n && lf && null !== i && dp(i, 0, i.length - 1), ap && "svg" === s && (ap = !1)) : e.$text$ !== a && (r.data = a);
}, fp = (e, t, n)=>null == e ? void 0 : e.insertBefore(t, n), pp = (e, t, n = !1)=>{
    const r = e.$hostElement$, i = e.$cmpMeta$, o = e.$vnode$ || Hf(null, null), s = (a = t) && a.$tag$ === Ff ? t : Uf(null, null, t);
    var a;
    if (Bf = r.tagName, n && s.$attrs$) for (const e of Object.keys(s.$attrs$))r.hasAttribute(e) && ![
        "key",
        "ref",
        "style",
        "class"
    ].includes(e) && (s.$attrs$[e] = r[e]);
    s.$tag$ = null, s.$flags$ |= 4, e.$vnode$ = s, s.$elm$ = o.$elm$ = r.shadowRoot || r, $f = r["s-sc"], sp = 0 != (1 & i.$flags$), hp(o, s, n);
}, gp = (e, t)=>{
    t && !e.$onRenderResolve$ && t["s-p"] && t["s-p"].push(new Promise((t)=>e.$onRenderResolve$ = t));
}, mp = (e, t)=>{
    if (e.$flags$ |= 16, 4 & e.$flags$) return void (e.$flags$ |= 512);
    gp(e, e.$ancestorComponent$);
    return Tf(()=>yp(e, t));
}, yp = (e, t)=>{
    const n = e.$hostElement$, r = (e.$cmpMeta$.$tagName$, ()=>{}), i = e.$lazyInstance$;
    if (!i) throw new Error(`Can't render component <${n.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);
    return r(), vp(undefined, ()=>wp(e, i, t));
}, vp = (e, t)=>bp(e) ? e.then(t).catch((e)=>{
        console.error(e), t();
    }) : t(), bp = (e)=>e instanceof Promise || e && e.then && "function" == typeof e.then, wp = async (e, t, n)=>{
    var r;
    const i = e.$hostElement$, o = (e.$cmpMeta$.$tagName$, ()=>{}), s = i["s-rc"];
    n && Jf(e);
    const a = (e.$cmpMeta$.$tagName$, ()=>{});
    Ep(e, t, i, n), s && (s.map((e)=>e()), i["s-rc"] = void 0), a(), o();
    {
        const t = null != (r = i["s-p"]) ? r : [], n = ()=>Sp(e);
        0 === t.length ? n() : (Promise.all(t).then(n), e.$flags$ |= 4, t.length = 0);
    }
}, Ep = (e, t, n, r)=>{
    try {
        t = t.render(), e.$flags$ &= -17, e.$flags$ |= 2, pp(e, t, r);
    } catch (t) {
        gf(t, e.$hostElement$);
    }
    return null;
}, Sp = (e)=>{
    e.$cmpMeta$.$tagName$;
    const t = e.$hostElement$, n = ()=>{}, r = e.$lazyInstance$, i = e.$ancestorComponent$;
    64 & e.$flags$ ? n() : (e.$flags$ |= 64, kp(t), Cp(r, "componentDidLoad"), n(), e.$onReadyResolve$(t), i || _p()), e.$onRenderResolve$ && (e.$onRenderResolve$(), e.$onRenderResolve$ = void 0), 512 & e.$flags$ && If(()=>mp(e, !1)), e.$flags$ &= -517;
}, _p = (e)=>{
    kp(wf.documentElement), If(()=>Yf(bf, "appload", {
            detail: {
                namespace: "sdk-install-modal-web"
            }
        }));
}, Cp = (e, t, n)=>{
    if (e && e[t]) try {
        return e[t](n);
    } catch (e) {
        gf(e);
    }
}, kp = (e)=>{
    var t;
    return e.classList.add(null != (t = sf) ? t : "hydrated");
}, Ap = (e, t, n, r)=>{
    const i = hf(e);
    if (!i) throw new Error(`Couldn't find host element for "${r.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);
    const o = i.$hostElement$, s = i.$instanceValues$.get(t), a = i.$flags$, c = i.$lazyInstance$;
    var l, d;
    l = n, d = r.$members$[t][0], n = null == l || Pf(l) ? l : 4 & d ? "false" !== l && ("" === l || !!l) : 1 & d ? String(l) : l;
    const u = Number.isNaN(s) && Number.isNaN(n);
    if ((!(8 & a) || void 0 === s) && n !== s && !u && (i.$instanceValues$.set(t, n), c)) {
        if (r.$watchers$ && 128 & a) {
            const e = r.$watchers$[t];
            e && e.map((e)=>{
                try {
                    c[e](n, s, t);
                } catch (e) {
                    gf(e, o);
                }
            });
        }
        2 == (18 & a) && mp(i, !1);
    }
}, xp = (e, t, n)=>{
    var r, i;
    const o = e.prototype;
    if (t.$members$ || t.$watchers$ || e.watchers) {
        e.watchers && !t.$watchers$ && (t.$watchers$ = e.watchers);
        const s = Object.entries(null != (r = t.$members$) ? r : {});
        if (s.map(([e, [r]])=>{
            (31 & r || 2 & n && 32 & r) && Object.defineProperty(o, e, {
                get () {
                    return t = e, hf(this).$instanceValues$.get(t);
                    //TURBOPACK unreachable
                    ;
                    var t;
                },
                set (n) {
                    Ap(this, e, n, t);
                },
                configurable: !0,
                enumerable: !0
            });
        }), 1 & n) {
            const n = new Map;
            o.attributeChangedCallback = function(e, r, i) {
                Ef.jmp(()=>{
                    var s;
                    const a = n.get(e);
                    if (this.hasOwnProperty(a)) i = this[a], delete this[a];
                    else {
                        if (o.hasOwnProperty(a) && "number" == typeof this[a] && this[a] == i) return;
                        if (null == a) {
                            const n = hf(this), o = null == n ? void 0 : n.$flags$;
                            if (o && !(8 & o) && 128 & o && i !== r) {
                                const o = n.$lazyInstance$, a = null == (s = t.$watchers$) ? void 0 : s[e];
                                null == a || a.forEach((t)=>{
                                    null != o[t] && o[t].call(o, i, r, e);
                                });
                            }
                            return;
                        }
                    }
                    this[a] = (null !== i || "boolean" != typeof this[a]) && i;
                });
            }, e.observedAttributes = Array.from(new Set([
                ...Object.keys(null != (i = t.$watchers$) ? i : {}),
                ...s.filter(([e, t])=>15 & t[0]).map(([e, t])=>{
                    const r = t[1] || e;
                    return n.set(r, e), r;
                })
            ]));
        }
    }
    return e;
}, Mp = async (e, t, n, r)=>{
    let i;
    if (0 == (32 & t.$flags$)) {
        t.$flags$ |= 32;
        if (n.$lazyBundleId$) {
            const e = ((e, t, n)=>{
                const r = e.$tagName$.replace(/-/g, "_"), i = e.$lazyBundleId$;
                if (!i) return;
                const o = mf.get(i);
                if (o) return o[r];
                {
                    const e = (e)=>(mf.set(i, e), e[r]);
                    if ("mm-install-modal_3" === i) return Promise.resolve().then(function() {
                        return yg;
                    }).then(e, gf);
                }
                return import(/* webpackIgnore: true */ /* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ `./${i}.entry.js`).then((e)=>(mf.set(i, e), e[r]), gf);
            })(n);
            if (e && "then" in e) {
                const t = ()=>{};
                i = await e, t();
            } else i = e;
            if (!i) throw new Error(`Constructor for "${n.$tagName$}#${t.$modeName$}" was not found`);
            i.isProxied || (n.$watchers$ = i.watchers, xp(i, n, 2), i.isProxied = !0);
            const r = (n.$tagName$, ()=>{});
            t.$flags$ |= 8;
            try {
                new i(t);
            } catch (e) {
                gf(e);
            }
            t.$flags$ &= -9, t.$flags$ |= 128, r(), Ip(t.$lazyInstance$);
        } else {
            i = e.constructor;
            const n = e.localName;
            customElements.whenDefined(n).then(()=>t.$flags$ |= 128);
        }
        if (i && i.style) {
            let e;
            "string" == typeof i.style && (e = i.style);
            const t = Qf(n);
            if (!yf.has(t)) {
                const r = (n.$tagName$, ()=>{});
                ((e, t, n)=>{
                    let r = yf.get(e);
                    Sf && n ? (r = r || new CSSStyleSheet, "string" == typeof r ? r = t : r.replaceSync(t)) : r = t, yf.set(e, r);
                })(t, e, !!(1 & n.$flags$)), r();
            }
        }
    }
    const o = t.$ancestorComponent$, s = ()=>mp(t, !0);
    o && o["s-rc"] ? o["s-rc"].push(s) : s();
}, Ip = (e)=>{
    Cp(e, "connectedCallback");
}, Tp = (e)=>{
    Cp(e, "disconnectedCallback");
}, Rp = (e, t = {})=>{
    var n;
    const r = ()=>{}, i = [], o = t.exclude || [], s = bf.customElements, a = wf.head, c = a.querySelector("meta[charset]"), l = wf.createElement("style"), d = [];
    let u, h = !0;
    Object.assign(Ef, t), Ef.$resourcesUrl$ = new URL(t.resourcesUrl || "./", wf.baseURI).href;
    let f = !1;
    if (e.map((e)=>{
        e[1].map((t)=>{
            var n;
            const r = {
                $flags$: t[0],
                $tagName$: t[1],
                $members$: t[2],
                $listeners$: t[3]
            };
            4 & r.$flags$ && (f = !0), r.$members$ = t[2], r.$watchers$ = null != (n = t[4]) ? n : {};
            const a = r.$tagName$, c = class extends HTMLElement {
                constructor(e){
                    if (super(e), this.hasRegisteredEventListeners = !1, ((e, t)=>{
                        const n = {
                            $flags$: 0,
                            $hostElement$: e,
                            $cmpMeta$: t,
                            $instanceValues$: new Map
                        };
                        n.$onReadyPromise$ = new Promise((e)=>n.$onReadyResolve$ = e), e["s-p"] = [], e["s-rc"] = [], uf.set(e, n);
                    })(e = this, r), 1 & r.$flags$) if (e.shadowRoot) {
                        if ("open" !== e.shadowRoot.mode) throw new Error(`Unable to re-use existing shadow root for ${r.$tagName$}! Mode is set to ${e.shadowRoot.mode} but Stencil only supports open shadow roots.`);
                    } else e.attachShadow({
                        mode: "open"
                    });
                }
                connectedCallback() {
                    hf(this), this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = !0), u && (clearTimeout(u), u = null), h ? d.push(this) : Ef.jmp(()=>((e)=>{
                            if (0 == (1 & Ef.$flags$)) {
                                const t = hf(e), n = t.$cmpMeta$, r = (n.$tagName$, ()=>{});
                                if (1 & t.$flags$) (null == t ? void 0 : t.$lazyInstance$) ? Ip(t.$lazyInstance$) : (null == t ? void 0 : t.$onReadyPromise$) && t.$onReadyPromise$.then(()=>Ip(t.$lazyInstance$));
                                else {
                                    t.$flags$ |= 1;
                                    {
                                        let n = e;
                                        for(; n = n.parentNode || n.host;)if (n["s-p"]) {
                                            gp(t, t.$ancestorComponent$ = n);
                                            break;
                                        }
                                    }
                                    n.$members$ && Object.entries(n.$members$).map(([t, [n]])=>{
                                        if (31 & n && e.hasOwnProperty(t)) {
                                            const n = e[t];
                                            delete e[t], e[t] = n;
                                        }
                                    }), Mp(e, t, n);
                                }
                                r();
                            }
                        })(this));
                }
                disconnectedCallback() {
                    Ef.jmp(()=>(async (e)=>{
                            if (0 == (1 & Ef.$flags$)) {
                                const t = hf(e);
                                (null == t ? void 0 : t.$lazyInstance$) ? Tp(t.$lazyInstance$) : (null == t ? void 0 : t.$onReadyPromise$) && t.$onReadyPromise$.then(()=>Tp(t.$lazyInstance$));
                            }
                        })(this));
                }
                componentOnReady() {
                    return hf(this).$onReadyPromise$;
                }
            };
            r.$lazyBundleId$ = e[0], o.includes(a) || s.get(a) || (i.push(a), s.define(a, xp(c, r, 1)));
        });
    }), i.length > 0 && (f && (l.textContent += vf), l.textContent += i.sort() + "{visibility:hidden}.hydrated{visibility:inherit}", l.innerHTML.length)) {
        l.setAttribute("data-styles", "");
        const e = null != (n = Ef.$nonce$) ? n : Of(wf);
        null != e && l.setAttribute("nonce", e), a.insertBefore(l, c ? c.nextSibling : a.firstChild);
    }
    h = !1, d.length ? d.map((e)=>e.connectedCallback()) : Ef.jmp(()=>u = setTimeout(_p, 30)), r();
};
!function() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    {
        var e;
    }
}();
var Pp = Object.freeze({
    __proto__: null,
    defineCustomElements: async (e, t)=>{
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    },
    setNonce: (e)=>Ef.$nonce$ = e
});
const Op = {
    fontFamily: "Roboto, sans-serif"
}, Np = ({ className: e }, t)=>Uf("div", {
        style: Op,
        class: e
    }, t), Lp = ({ Icon: e, text: t })=>Uf("div", {
        class: "flexContainer",
        style: {
            padding: "6",
            flexDirection: "row"
        }
    }, Uf("div", {
        class: "flexItem1"
    }, Uf(e, null)), Uf("div", {
        class: "flexItem11"
    }, Uf("span", {
        style: {
            lineHeight: "2",
            color: "black"
        }
    }, t))), Dp = ()=>Uf("svg", {
        width: "20",
        height: "18",
        viewBox: "0 0 20 18",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, Uf("path", {
        d: "M20.0002 7.9702V10.0302C20.0002 10.5802 19.5602 11.0302 19.0002 11.0502H17.0402C15.9602 11.0502 14.9702 10.2602 14.8802 9.1802C14.8202 8.5502 15.0602 7.9602 15.4802 7.5502C15.8502 7.1702 16.3602 6.9502 16.9202 6.9502H19.0002C19.5602 6.9702 20.0002 7.4202 20.0002 7.9702Z",
        fill: "#037DD6"
    }), Uf("path", {
        d: "M18.47 12.55H17.04C15.14 12.55 13.54 11.12 13.38 9.3C13.29 8.26 13.67 7.22 14.43 6.48C15.07 5.82 15.96 5.45 16.92 5.45H18.47C18.76 5.45 19 5.21 18.97 4.92C18.75 2.49 17.14 0.83 14.75 0.55C14.51 0.51 14.26 0.5 14 0.5H5C4.72 0.5 4.45 0.52 4.19 0.56C1.64 0.88 0 2.78 0 5.5V12.5C0 15.26 2.24 17.5 5 17.5H14C16.8 17.5 18.73 15.75 18.97 13.08C19 12.79 18.76 12.55 18.47 12.55ZM11 6.75H5C4.59 6.75 4.25 6.41 4.25 6C4.25 5.59 4.59 5.25 5 5.25H11C11.41 5.25 11.75 5.59 11.75 6C11.75 6.41 11.41 6.75 11 6.75Z",
        fill: "#037DD6"
    })), $p = ()=>Uf("svg", {
        width: "20",
        height: "18",
        viewBox: "0 0 20 18",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, Uf("path", {
        d: "M14.44 0.0999756C12.63 0.0999756 11.01 0.979976 10 2.32998C8.99 0.979976 7.37 0.0999756 5.56 0.0999756C2.49 0.0999756 0 2.59998 0 5.68998C0 6.87998 0.19 7.97998 0.52 8.99998C2.1 14 6.97 16.99 9.38 17.81C9.72 17.93 10.28 17.93 10.62 17.81C13.03 16.99 17.9 14 19.48 8.99998C19.81 7.97998 20 6.87998 20 5.68998C20 2.59998 17.51 0.0999756 14.44 0.0999756Z",
        fill: "#037DD6"
    })), Bp = ()=>Uf("svg", {
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, Uf("path", {
        d: "M16.28 7.53V6.28C16.28 3.58 15.63 0 10 0C4.37 0 3.72 3.58 3.72 6.28V7.53C0.92 7.88 0 9.3 0 12.79V14.65C0 18.75 1.25 20 5.35 20H14.65C18.75 20 20 18.75 20 14.65V12.79C20 9.3 19.08 7.88 16.28 7.53ZM10 16.74C8.33 16.74 6.98 15.38 6.98 13.72C6.98 12.05 8.34 10.7 10 10.7C11.66 10.7 13.02 12.06 13.02 13.72C13.02 15.39 11.67 16.74 10 16.74ZM5.35 7.44C5.27 7.44 5.2 7.44 5.12 7.44V6.28C5.12 3.35 5.95 1.4 10 1.4C14.05 1.4 14.88 3.35 14.88 6.28V7.45C14.8 7.45 14.73 7.45 14.65 7.45H5.35V7.44Z",
        fill: "#037DD6"
    })), Kp = ()=>Uf("svg", {
        width: "20",
        height: "20",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, Uf("path", {
        d: "M16.4405 8.8999C20.0405 9.2099 21.5105 11.0599 21.5105 15.1099V15.2399C21.5105 19.7099 19.7205 21.4999 15.2505 21.4999H8.74047C4.27047 21.4999 2.48047 19.7099 2.48047 15.2399V15.1099C2.48047 11.0899 3.93047 9.2399 7.47047 8.9099",
        stroke: "white",
        "stroke-width": "1.5",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }), Uf("path", {
        d: "M12 2V14.88",
        stroke: "white",
        "stroke-width": "1.5",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }), Uf("path", {
        d: "M15.3504 12.6499L12.0004 15.9999L8.65039 12.6499",
        stroke: "white",
        "stroke-width": "1.5",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }));
function jp({ version: e }) {
    return Uf("div", {
        style: {
            textAlign: "center",
            color: "#BBC0C5",
            fontSize: "12"
        }
    }, "SDK Version ", e ? `v${e}` : "unknown");
}
const Up = ()=>Uf("svg", {
        width: "14",
        height: "14",
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, Uf("rect", {
        width: "16",
        height: "16",
        fill: "white"
    }), Uf("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M2.40554 2.40554C2.94627 1.86482 3.82296 1.86482 4.36369 2.40554L8 6.04186L11.6363 2.40554C12.177 1.86482 13.0537 1.86482 13.5945 2.40554C14.1352 2.94627 14.1352 3.82296 13.5945 4.36369L9.95814 8L13.5945 11.6363C14.1352 12.177 14.1352 13.0537 13.5945 13.5945C13.0537 14.1352 12.177 14.1352 11.6363 13.5945L8 9.95814L4.36369 13.5945C3.82296 14.1352 2.94627 14.1352 2.40554 13.5945C1.86482 13.0537 1.86482 12.177 2.40554 11.6363L6.04186 8L2.40554 4.36369C1.86482 3.82296 1.86482 2.94627 2.40554 2.40554Z",
        fill: "#BBC0C5"
    })), Hp = ()=>Uf("svg", {
        width: "120",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 127 63"
    }, Uf("path", {
        fill: "currentColor",
        d: "M71.554 48.607v13.81h-7.072v-9.568l-8.059.945c-1.77.205-2.548.79-2.548 1.864 0 1.575 1.478 2.239 4.648 2.239 1.932 0 4.073-.29 5.963-.79l-3.66 5.225c-1.479.332-2.92.496-4.44.496-6.414 0-10.074-2.57-10.074-7.132 0-4.023 2.877-6.136 9.416-6.884l8.638-1.012c-.467-2.532-2.362-3.633-6.13-3.633-3.537 0-7.443.912-10.937 2.613l1.111-6.18c3.248-1.369 6.95-2.074 10.69-2.074 8.226 0 12.461 3.444 12.461 10.075l-.008.005ZM7.938 31.315.208 62.416h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73l-7.73-31.105-14.518 17.388L7.934 31.311l.004.004ZM36.97.21 22.452 17.598 7.938.21.208 31.315h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73L36.97.21Zm53.17 48.107-6.25-.912c-1.562-.247-2.178-.747-2.178-1.617 0-1.41 1.52-2.032 4.647-2.032 3.62 0 6.868.747 10.283 2.364l-.862-6.094c-2.757-.995-5.922-1.491-9.212-1.491-7.688 0-11.886 2.696-11.886 7.547 0 3.776 2.303 5.889 7.196 6.636l6.335.954c1.603.248 2.261.87 2.261 1.865 0 1.41-1.478 2.074-4.481 2.074-3.948 0-8.225-.953-11.72-2.654l.7 6.094c3.003 1.122 6.91 1.785 10.57 1.785 7.896 0 12.007-2.78 12.007-7.715 0-3.94-2.303-6.057-7.4-6.8l-.01-.004ZM100.3 34.09v28.325h7.071V34.091H100.3Zm15.334 15.595 9.833-10.744h-8.8l-9.296 11.114 9.912 12.356h8.925l-10.574-12.73v.004Zm-16.321-25.09c0 4.56 3.66 7.13 10.074 7.13 1.52 0 2.961-.167 4.44-.495l3.66-5.225c-1.89.496-4.031.79-5.963.79-3.166 0-4.648-.664-4.648-2.239 0-1.079.783-1.659 2.549-1.864l8.058-.945v9.567h7.072v-13.81c0-6.635-4.236-10.075-12.461-10.075-3.744 0-7.442.705-10.691 2.075l-1.112 6.178c3.495-1.701 7.401-2.613 10.937-2.613 3.769 0 5.664 1.1 6.13 3.633l-8.637 1.013c-6.539.747-9.417 2.86-9.417 6.883l.009-.004Zm-19.779-1.492c0 5.725 3.29 8.627 9.787 8.627 2.59 0 4.732-.416 6.785-1.37l.903-6.261c-1.974 1.2-3.99 1.822-6.005 1.822-3.044 0-4.402-1.243-4.402-4.023v-8.295h10.732V7.84H86.601V2.948l-13.448 7.174v3.482h6.372V23.1l.008.004Zm-6.95-2.612v1.411H53.47c.862 2.873 3.423 4.187 7.97 4.187 3.62 0 6.993-.747 9.992-2.196l-.862 6.056c-2.757 1.16-6.251 1.785-9.829 1.785-9.5 0-14.68-4.23-14.68-12.066 0-7.838 5.264-12.235 13.406-12.235s13.119 4.771 13.119 13.062l-.005-.004ZM53.378 17.09h12.086c-.637-2.751-2.732-4.188-6.08-4.188-3.349 0-5.335 1.399-6.006 4.188Z"
    }));
function Fp(e, t) {
    return e.toString(2).padStart(t, "0");
}
function zp(e, t) {
    const n = e % t;
    return n >= 0 ? n : t + n;
}
function qp(e, t) {
    return new Array(e).fill(t);
}
function Wp(...e) {
    let t = 0;
    for (const n of e)t = Math.max(t, n.length);
    const n = [];
    for(let r = 0; r < t; r++)for (const t of e)r >= t.length || n.push(t[r]);
    return new Uint8Array(n);
}
function Vp(e, t, n) {
    if (n < 0 || n + t.length > e.length) return !1;
    for(let r = 0; r < t.length; r++)if (t[r] !== e[n + r]) return !1;
    return !0;
}
function Gp(e) {
    return {
        has: (t)=>e.includes(t),
        decode: (t)=>{
            if (!Array.isArray(t) || t.length && "string" != typeof t[0]) throw new Error("alphabet.decode input should be array of strings");
            return t.map((t)=>{
                if ("string" != typeof t) throw new Error(`alphabet.decode: not string element=${t}`);
                const n = e.indexOf(t);
                if (-1 === n) throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);
                return n;
            });
        },
        encode: (t)=>{
            if (!Array.isArray(t) || t.length && "number" != typeof t[0]) throw new Error("alphabet.encode input should be an array of numbers");
            return t.map((t)=>{
                if (function(e) {
                    if (!Number.isSafeInteger(e)) throw new Error(`Wrong integer: ${e}`);
                }(t), t < 0 || t >= e.length) throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`);
                return e[t];
            });
        }
    };
}
class Yp {
    static size(e, t) {
        if ("number" == typeof e && (e = {
            height: e,
            width: e
        }), !Number.isSafeInteger(e.height) && e.height !== 1 / 0) throw new Error(`Bitmap: wrong height=${e.height} (${typeof e.height})`);
        if (!Number.isSafeInteger(e.width) && e.width !== 1 / 0) throw new Error(`Bitmap: wrong width=${e.width} (${typeof e.width})`);
        return void 0 !== t && (e = {
            width: Math.min(e.width, t.width),
            height: Math.min(e.height, t.height)
        }), e;
    }
    static fromString(e) {
        const t = (e = e.replace(/^\n+/g, "").replace(/\n+$/g, "")).split("\n"), n = t.length, r = new Array(n);
        let i;
        for (const e of t){
            const t = e.split("").map((e)=>{
                if ("X" === e) return !0;
                if (" " === e) return !1;
                if ("?" !== e) throw new Error(`Bitmap.fromString: unknown symbol=${e}`);
            });
            if (i && t.length !== i) throw new Error(`Bitmap.fromString different row sizes: width=${i} cur=${t.length}`);
            i = t.length, r.push(t);
        }
        return i || (i = 0), new Yp({
            height: n,
            width: i
        }, r);
    }
    constructor(e, t){
        const { height: n, width: r } = Yp.size(e);
        this.data = t || Array.from({
            length: n
        }, ()=>qp(r, void 0)), this.height = n, this.width = r;
    }
    point(e) {
        return this.data[e.y][e.x];
    }
    isInside(e) {
        return 0 <= e.x && e.x < this.width && 0 <= e.y && e.y < this.height;
    }
    size(e) {
        if (!e) return {
            height: this.height,
            width: this.width
        };
        const { x: t, y: n } = this.xy(e);
        return {
            height: this.height - n,
            width: this.width - t
        };
    }
    xy(e) {
        if ("number" == typeof e && (e = {
            x: e,
            y: e
        }), !Number.isSafeInteger(e.x)) throw new Error(`Bitmap: wrong x=${e.x}`);
        if (!Number.isSafeInteger(e.y)) throw new Error(`Bitmap: wrong y=${e.y}`);
        return e.x = zp(e.x, this.width), e.y = zp(e.y, this.height), e;
    }
    rect(e, t, n) {
        const { x: r, y: i } = this.xy(e), { height: o, width: s } = Yp.size(t, this.size({
            x: r,
            y: i
        }));
        for(let e = 0; e < o; e++)for(let t = 0; t < s; t++)this.data[i + e][r + t] = "function" == typeof n ? n({
            x: t,
            y: e
        }, this.data[i + e][r + t]) : n;
        return this;
    }
    rectRead(e, t, n) {
        return this.rect(e, t, (e, t)=>(n(e, t), t));
    }
    hLine(e, t, n) {
        return this.rect(e, {
            width: t,
            height: 1
        }, n);
    }
    vLine(e, t, n) {
        return this.rect(e, {
            width: 1,
            height: t
        }, n);
    }
    border(e = 2, t) {
        const n = this.height + 2 * e, r = this.width + 2 * e, i = qp(e, t), o = Array.from({
            length: e
        }, ()=>qp(r, t));
        return new Yp({
            height: n,
            width: r
        }, [
            ...o,
            ...this.data.map((e)=>[
                    ...i,
                    ...e,
                    ...i
                ]),
            ...o
        ]);
    }
    embed(e, t) {
        return this.rect(e, t.size(), ({ x: e, y: n })=>t.data[n][e]);
    }
    rectSlice(e, t = this.size()) {
        const n = new Yp(Yp.size(t, this.size(this.xy(e))));
        return this.rect(e, t, ({ x: e, y: t }, r)=>n.data[t][e] = r), n;
    }
    inverse() {
        const { height: e, width: t } = this;
        return new Yp({
            height: t,
            width: e
        }).rect({
            x: 0,
            y: 0
        }, 1 / 0, ({ x: e, y: t })=>this.data[e][t]);
    }
    scale(e) {
        if (!Number.isSafeInteger(e) || e > 1024) throw new Error(`Wrong scale factor: ${e}`);
        const { height: t, width: n } = this;
        return new Yp({
            height: e * t,
            width: e * n
        }).rect({
            x: 0,
            y: 0
        }, 1 / 0, ({ x: t, y: n })=>this.data[Math.floor(n / e)][Math.floor(t / e)]);
    }
    clone() {
        return new Yp(this.size()).rect({
            x: 0,
            y: 0
        }, this.size(), ({ x: e, y: t })=>this.data[t][e]);
    }
    assertDrawn() {
        this.rectRead(0, 1 / 0, (e, t)=>{
            if ("boolean" != typeof t) throw new Error("Invalid color type=" + typeof t);
        });
    }
    toString() {
        return this.data.map((e)=>e.map((e)=>void 0 === e ? "?" : e ? "X" : " ").join("")).join("\n");
    }
    toASCII() {
        const { height: e, width: t, data: n } = this;
        let r = "";
        for(let i = 0; i < e; i += 2){
            for(let o = 0; o < t; o++){
                const t = n[i][o], s = i + 1 >= e || n[i + 1][o];
                t || s ? !t && s ? r += "" : t && !s ? r += "" : t && s && (r += " ") : r += "";
            }
            r += "\n";
        }
        return r;
    }
    toTerm() {
        const e = "[0m", t = `[1;47m  ${e}`, n = `[40m  ${e}`;
        return this.data.map((e)=>e.map((e)=>e ? n : t).join("")).join("\n");
    }
    toSVG() {
        let e = `<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 ${this.width} ${this.height}" version="1.1" xmlns="http://www.w3.org/2000/svg">`;
        return this.rectRead(0, 1 / 0, ({ x: t, y: n }, r)=>{
            r && (e += `<rect x="${t}" y="${n}" width="1" height="1" />`);
        }), e += "</svg>", e;
    }
    toGIF() {
        const e = (e)=>[
                255 & e,
                e >>> 8 & 255
            ], t = [
            ...e(this.width),
            ...e(this.height)
        ], n = [];
        this.rectRead(0, 1 / 0, (e, t)=>n.push(+(!0 === t)));
        const r = 126, i = [
            71,
            73,
            70,
            56,
            55,
            97,
            ...t,
            246,
            0,
            0,
            255,
            255,
            255,
            ...qp(381, 0),
            44,
            0,
            0,
            0,
            0,
            ...t,
            0,
            7
        ], o = Math.floor(n.length / r);
        for(let e = 0; e < o; e++)i.push(127, 128, ...n.slice(r * e, r * (e + 1)).map((e)=>+e));
        return i.push(n.length % r + 1, 128, ...n.slice(o * r).map((e)=>+e)), i.push(1, 129, 0, 59), new Uint8Array(i);
    }
    toImage(e = !1) {
        const { height: t, width: n } = this.size(), r = new Uint8Array(t * n * (e ? 3 : 4));
        let i = 0;
        for(let o = 0; o < t; o++)for(let t = 0; t < n; t++){
            const n = this.data[o][t] ? 0 : 255;
            r[i++] = n, r[i++] = n, r[i++] = n, e || (r[i++] = 255);
        }
        return {
            height: t,
            width: n,
            data: r
        };
    }
}
const Zp = [
    "low",
    "medium",
    "quartile",
    "high"
], Jp = [
    "numeric",
    "alphanumeric",
    "byte",
    "kanji",
    "eci"
], Qp = [
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
], Xp = {
    low: [
        7,
        10,
        15,
        20,
        26,
        18,
        20,
        24,
        30,
        18,
        20,
        24,
        26,
        30,
        22,
        24,
        28,
        30,
        28,
        28,
        28,
        28,
        30,
        30,
        26,
        28,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30
    ],
    medium: [
        10,
        16,
        26,
        18,
        24,
        16,
        18,
        22,
        22,
        26,
        30,
        22,
        22,
        24,
        24,
        28,
        28,
        26,
        26,
        26,
        26,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        28
    ],
    quartile: [
        13,
        22,
        18,
        26,
        18,
        24,
        18,
        22,
        20,
        24,
        28,
        26,
        24,
        20,
        30,
        24,
        28,
        28,
        26,
        30,
        28,
        30,
        30,
        30,
        30,
        28,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30
    ],
    high: [
        17,
        28,
        22,
        16,
        22,
        28,
        26,
        26,
        24,
        28,
        24,
        28,
        22,
        24,
        24,
        30,
        28,
        28,
        26,
        28,
        30,
        24,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30,
        30
    ]
}, eg = {
    low: [
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        4,
        4,
        4,
        4,
        4,
        6,
        6,
        6,
        6,
        7,
        8,
        8,
        9,
        9,
        10,
        12,
        12,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        19,
        20,
        21,
        22,
        24,
        25
    ],
    medium: [
        1,
        1,
        1,
        2,
        2,
        4,
        4,
        4,
        5,
        5,
        5,
        8,
        9,
        9,
        10,
        10,
        11,
        13,
        14,
        16,
        17,
        17,
        18,
        20,
        21,
        23,
        25,
        26,
        28,
        29,
        31,
        33,
        35,
        37,
        38,
        40,
        43,
        45,
        47,
        49
    ],
    quartile: [
        1,
        1,
        2,
        2,
        4,
        4,
        6,
        6,
        8,
        8,
        8,
        10,
        12,
        16,
        12,
        17,
        16,
        18,
        21,
        20,
        23,
        23,
        25,
        27,
        29,
        34,
        34,
        35,
        38,
        40,
        43,
        45,
        48,
        51,
        53,
        56,
        59,
        62,
        65,
        68
    ],
    high: [
        1,
        1,
        2,
        4,
        4,
        4,
        5,
        6,
        8,
        8,
        11,
        11,
        16,
        16,
        18,
        16,
        19,
        21,
        25,
        25,
        25,
        34,
        30,
        32,
        35,
        37,
        40,
        42,
        45,
        48,
        51,
        54,
        57,
        60,
        63,
        66,
        70,
        74,
        77,
        81
    ]
}, tg = {
    size: {
        encode: (e)=>21 + 4 * (e - 1),
        decode: (e)=>(e - 17) / 4
    },
    sizeType: (e)=>Math.floor((e + 7) / 17),
    alignmentPatterns (e) {
        if (1 === e) return [];
        const t = tg.size.encode(e) - 6 - 1, n = t - 6, r = Math.ceil(n / 28);
        let i = Math.floor(n / r);
        i % 2 ? i += 1 : n % r * 2 >= r && (i += 2);
        const o = [
            6
        ];
        for(let e = 1; e < r; e++)o.push(t - (r - e) * i);
        return o.push(t), o;
    },
    ECCode: {
        low: 1,
        medium: 0,
        quartile: 3,
        high: 2
    },
    formatMask: 21522,
    formatBits (e, t) {
        const n = tg.ECCode[e] << 3 | t;
        let r = n;
        for(let e = 0; e < 10; e++)r = r << 1 ^ 1335 * (r >> 9);
        return (n << 10 | r) ^ tg.formatMask;
    },
    versionBits (e) {
        let t = e;
        for(let e = 0; e < 12; e++)t = t << 1 ^ 7973 * (t >> 11);
        return e << 12 | t;
    },
    alphabet: {
        numeric: Gp("0123456789"),
        alphanumerc: Gp("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:")
    },
    lengthBits: (e, t)=>({
            numeric: [
                10,
                12,
                14
            ],
            alphanumeric: [
                9,
                11,
                13
            ],
            byte: [
                8,
                16,
                16
            ],
            kanji: [
                8,
                10,
                12
            ],
            eci: [
                0,
                0,
                0
            ]
        })[t][tg.sizeType(e)],
    modeBits: {
        numeric: "0001",
        alphanumeric: "0010",
        byte: "0100",
        kanji: "1000",
        eci: "0111"
    },
    capacity (e, t) {
        const n = Qp[e - 1], r = Xp[t][e - 1], i = eg[t][e - 1], o = Math.floor(n / i) - r, s = i - n % i;
        return {
            words: r,
            numBlocks: i,
            shortBlocks: s,
            blockLen: o,
            capacity: 8 * (n - r * i),
            total: (r + o) * i + i - s
        };
    }
}, ng = [
    (e, t)=>(e + t) % 2 == 0,
    (e, t)=>t % 2 == 0,
    (e, t)=>e % 3 == 0,
    (e, t)=>(e + t) % 3 == 0,
    (e, t)=>(Math.floor(t / 2) + Math.floor(e / 3)) % 2 == 0,
    (e, t)=>e * t % 2 + e * t % 3 == 0,
    (e, t)=>(e * t % 2 + e * t % 3) % 2 == 0,
    (e, t)=>((e + t) % 2 + e * t % 3) % 2 == 0
], rg = {
    tables: ((e)=>{
        const t = qp(256, 0), n = qp(256, 0);
        for(let e = 0, r = 1; e < 256; e++)t[e] = r, n[r] = e, r <<= 1, 256 & r && (r ^= 285);
        return {
            exp: t,
            log: n
        };
    })(),
    exp: (e)=>rg.tables.exp[e],
    log (e) {
        if (0 === e) throw new Error(`GF.log: wrong arg=${e}`);
        return rg.tables.log[e] % 255;
    },
    mul: (e, t)=>0 === e || 0 === t ? 0 : rg.tables.exp[(rg.tables.log[e] + rg.tables.log[t]) % 255],
    add: (e, t)=>e ^ t,
    pow: (e, t)=>rg.tables.exp[rg.tables.log[e] * t % 255],
    inv (e) {
        if (0 === e) throw new Error(`GF.inverse: wrong arg=${e}`);
        return rg.tables.exp[255 - rg.tables.log[e]];
    },
    polynomial (e) {
        if (0 == e.length) throw new Error("GF.polymomial: wrong length");
        if (0 !== e[0]) return e;
        let t = 0;
        for(; t < e.length - 1 && 0 == e[t]; t++);
        return e.slice(t);
    },
    monomial (e, t) {
        if (e < 0) throw new Error(`GF.monomial: wrong degree=${e}`);
        if (0 == t) return [
            0
        ];
        let n = qp(e + 1, 0);
        return n[0] = t, rg.polynomial(n);
    },
    degree: (e)=>e.length - 1,
    coefficient: (e, t)=>e[rg.degree(e) - t],
    mulPoly (e, t) {
        if (0 === e[0] || 0 === t[0]) return [
            0
        ];
        const n = qp(e.length + t.length - 1, 0);
        for(let r = 0; r < e.length; r++)for(let i = 0; i < t.length; i++)n[r + i] = rg.add(n[r + i], rg.mul(e[r], t[i]));
        return rg.polynomial(n);
    },
    mulPolyScalar (e, t) {
        if (0 == t) return [
            0
        ];
        if (1 == t) return e;
        const n = qp(e.length, 0);
        for(let r = 0; r < e.length; r++)n[r] = rg.mul(e[r], t);
        return rg.polynomial(n);
    },
    mulPolyMonomial (e, t, n) {
        if (t < 0) throw new Error("GF.mulPolyMonomial: wrong degree");
        if (0 == n) return [
            0
        ];
        const r = qp(e.length + t, 0);
        for(let t = 0; t < e.length; t++)r[t] = rg.mul(e[t], n);
        return rg.polynomial(r);
    },
    addPoly (e, t) {
        if (0 === e[0]) return t;
        if (0 === t[0]) return e;
        let n = e, r = t;
        n.length > r.length && ([n, r] = [
            r,
            n
        ]);
        let i = qp(r.length, 0), o = r.length - n.length, s = r.slice(0, o);
        for(let e = 0; e < s.length; e++)i[e] = s[e];
        for(let e = o; e < r.length; e++)i[e] = rg.add(n[e - o], r[e]);
        return rg.polynomial(i);
    },
    remainderPoly (e, t) {
        const n = Array.from(e);
        for(let r = 0; r < e.length - t.length + 1; r++){
            const e = n[r];
            if (0 !== e) for(let i = 1; i < t.length; i++)0 !== t[i] && (n[r + i] = rg.add(n[r + i], rg.mul(t[i], e)));
        }
        return n.slice(e.length - t.length + 1, n.length);
    },
    divisorPoly (e) {
        let t = [
            1
        ];
        for(let n = 0; n < e; n++)t = rg.mulPoly(t, [
            1,
            rg.pow(2, n)
        ]);
        return t;
    },
    evalPoly (e, t) {
        if (0 == t) return rg.coefficient(e, 0);
        let n = e[0];
        for(let r = 1; r < e.length; r++)n = rg.add(rg.mul(t, n), e[r]);
        return n;
    },
    euclidian (e, t, n) {
        rg.degree(e) < rg.degree(t) && ([e, t] = [
            t,
            e
        ]);
        let r = e, i = t, o = [
            0
        ], s = [
            1
        ];
        for(; 2 * rg.degree(i) >= n;){
            let e = r, t = o;
            if (r = i, o = s, 0 === r[0]) throw new Error("rLast[0] === 0");
            i = e;
            let n = [
                0
            ];
            const a = rg.inv(r[0]);
            for(; rg.degree(i) >= rg.degree(r) && 0 !== i[0];){
                const e = rg.degree(i) - rg.degree(r), t = rg.mul(i[0], a);
                n = rg.addPoly(n, rg.monomial(e, t)), i = rg.addPoly(i, rg.mulPolyMonomial(r, e, t));
            }
            if (n = rg.mulPoly(n, o), s = rg.addPoly(n, t), rg.degree(i) >= rg.degree(r)) throw new Error(`Division failed r: ${i}, rLast: ${r}`);
        }
        const a = rg.coefficient(s, 0);
        if (0 == a) throw new Error("sigmaTilde(0) was zero");
        const c = rg.inv(a);
        return [
            rg.mulPolyScalar(s, c),
            rg.mulPolyScalar(i, c)
        ];
    }
};
function ig(e, t) {
    const { words: n, shortBlocks: r, numBlocks: i, blockLen: o, total: s } = tg.capacity(e, t), a = (c = n, {
        encode (e) {
            const t = rg.divisorPoly(c), n = Array.from(e);
            return n.push(...t.slice(0, -1).fill(0)), Uint8Array.from(rg.remainderPoly(n, t));
        },
        decode (e) {
            const t = e.slice(), n = rg.polynomial(Array.from(e));
            let r = qp(c, 0), i = !1;
            for(let e = 0; e < c; e++){
                const t = rg.evalPoly(n, rg.exp(e));
                r[r.length - 1 - e] = t, 0 !== t && (i = !0);
            }
            if (!i) return t;
            r = rg.polynomial(r);
            const o = rg.monomial(c, 1), [s, a] = rg.euclidian(o, r, c), l = qp(rg.degree(s), 0);
            let d = 0;
            for(let e = 1; e < 256 && d < l.length; e++)0 === rg.evalPoly(s, e) && (l[d++] = rg.inv(e));
            if (d !== l.length) throw new Error("RS.decode: wrong errors number");
            for(let e = 0; e < l.length; e++){
                const n = t.length - 1 - rg.log(l[e]);
                if (n < 0) throw new Error("RS.decode: wrong error location");
                const r = rg.inv(l[e]);
                let i = 1;
                for(let t = 0; t < l.length; t++)e !== t && (i = rg.mul(i, rg.add(1, rg.mul(l[t], r))));
                t[n] = rg.add(t[n], rg.mul(rg.evalPoly(a, r), rg.inv(i)));
            }
            return t;
        }
    });
    var c;
    return {
        encode (e) {
            const t = [], n = [];
            for(let s = 0; s < i; s++){
                const i = o + (s < r ? 0 : 1);
                t.push(e.subarray(0, i)), n.push(a.encode(e.subarray(0, i))), e = e.subarray(i);
            }
            const s = Wp(...t), c = Wp(...n), l = new Uint8Array(s.length + c.length);
            return l.set(s), l.set(c, s.length), l;
        },
        decode (e) {
            if (e.length !== s) throw new Error(`interleave.decode: len(data)=${e.length}, total=${s}`);
            const t = [];
            for(let e = 0; e < i; e++){
                const i = e < r;
                t.push(new Uint8Array(n + o + (i ? 0 : 1)));
            }
            let c = 0;
            for(let n = 0; n < o; n++)for(let r = 0; r < i; r++)t[r][n] = e[c++];
            for(let n = r; n < i; n++)t[n][o] = e[c++];
            for(let s = o; s < o + n; s++)for(let n = 0; n < i; n++){
                const i = n < r;
                t[n][s + (i ? 0 : 1)] = e[c++];
            }
            const l = [];
            for (const e of t)l.push(...Array.from(a.decode(e)).slice(0, -n));
            return Uint8Array.from(l);
        }
    };
}
function og(e, t, n, r) {
    let i = "", o = n.length;
    if ("numeric" === r) {
        const e = tg.alphabet.numeric.decode(n.split("")), t = e.length;
        for(let n = 0; n < t - 2; n += 3)i += Fp(100 * e[n] + 10 * e[n + 1] + e[n + 2], 10);
        t % 3 == 1 ? i += Fp(e[t - 1], 4) : t % 3 == 2 && (i += Fp(10 * e[t - 2] + e[t - 1], 7));
    } else if ("alphanumeric" === r) {
        const e = tg.alphabet.alphanumerc.decode(n.split("")), t = e.length;
        for(let n = 0; n < t - 1; n += 2)i += Fp(45 * e[n] + e[n + 1], 11);
        t % 2 == 1 && (i += Fp(e[t - 1], 6));
    } else {
        if ("byte" !== r) throw new Error("encode: unsupported type");
        {
            const e = function(e) {
                if ("string" != typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
                return new Uint8Array((new TextEncoder).encode(e));
            }(n);
            o = e.length, i = Array.from(e).map((e)=>Fp(e, 8)).join("");
        }
    }
    const { capacity: s } = tg.capacity(e, t), a = Fp(o, tg.lengthBits(e, r));
    let c = tg.modeBits[r] + a + i;
    if (c.length > s) throw new Error("Capacity overflow");
    c += "0".repeat(Math.min(4, Math.max(0, s - c.length))), c.length % 8 && (c += "0".repeat(8 - c.length % 8));
    const l = "1110110000010001";
    for(let e = 0; c.length !== s; e++)c += l[e % 16];
    const d = Uint8Array.from(c.match(/(.{8})/g).map((e)=>Number(`0b${e}`)));
    return ig(e, t).encode(d);
}
function sg(e, t, n, r, i = !1) {
    const o = function(e, t, n, r = !1) {
        const i = tg.size.encode(e);
        let o = new Yp(i + 2);
        const s = new Yp(3).rect(0, 3, !0).border(1, !1).border(1, !0).border(1, !1);
        o = o.embed(0, s).embed({
            x: -s.width,
            y: 0
        }, s).embed({
            x: 0,
            y: -s.height
        }, s), o = o.rectSlice(1, i);
        const a = new Yp(1).rect(0, 1, !0).border(1, !1).border(1, !0), c = tg.alignmentPatterns(e);
        for (const e of c)for (const t of c)void 0 === o.data[e][t] && o.embed({
            x: t - 2,
            y: e - 2
        }, a);
        o = o.hLine({
            x: 0,
            y: 6
        }, 1 / 0, ({ x: e }, t)=>void 0 === t ? e % 2 == 0 : t).vLine({
            x: 6,
            y: 0
        }, 1 / 0, ({ y: e }, t)=>void 0 === t ? e % 2 == 0 : t);
        {
            const e = tg.formatBits(t, n), s = (t)=>!r && 1 == (e >> t & 1);
            for(let e = 0; e < 6; e++)o.data[e][8] = s(e);
            for(let e = 6; e < 8; e++)o.data[e + 1][8] = s(e);
            for(let e = 8; e < 15; e++)o.data[i - 15 + e][8] = s(e);
            for(let e = 0; e < 8; e++)o.data[8][i - e - 1] = s(e);
            for(let e = 8; e < 9; e++)o.data[8][15 - e - 1 + 1] = s(e);
            for(let e = 9; e < 15; e++)o.data[8][15 - e - 1] = s(e);
            o.data[i - 8][8] = !r;
        }
        if (e >= 7) {
            const t = tg.versionBits(e);
            for(let e = 0; e < 18; e += 1){
                const n = !r && 1 == (t >> e & 1), s = Math.floor(e / 3), a = e % 3 + i - 8 - 3;
                o.data[s][a] = n, o.data[a][s] = n;
            }
        }
        return o;
    }(e, t, r, i);
    let s = 0;
    const a = 8 * n.length;
    if (function(e, t, n) {
        const r = e.height, i = ng[t];
        let o = -1, s = r - 1;
        for(let t = r - 1; t > 0; t -= 2){
            for(6 == t && (t = 5);; s += o){
                for(let r = 0; r < 2; r += 1){
                    const o = t - r;
                    void 0 === e.data[s][o] && n(o, s, i(o, s));
                }
                if (s + o < 0 || s + o >= r) break;
            }
            o = -o;
        }
    }(o, r, (e, t, r)=>{
        let i = !1;
        s < a && (i = 0 != (n[s >>> 3] >> (7 - s & 7) & 1), s++), o.data[t][e] = i !== r;
    }), s !== a) throw new Error("QR: bytes left after draw");
    return o;
}
function ag(e) {
    const t = e.inverse(), n = (e)=>{
        let t = 0;
        for(let n, r = 0, i = 1; r < e.length; r++)n === e[r] && (i++, r !== e.length - 1) || (i >= 5 && (t += i - 5 + 3), n = e[r], i = 1);
        return t;
    };
    let r = 0;
    e.data.forEach((e)=>r += n(e)), t.data.forEach((e)=>r += n(e));
    let i = 0, o = e.data;
    const s = e.width - 1, a = e.height - 1;
    for(let e = 0; e < s; e++)for(let t = 0; t < a; t++){
        const n = e + 1, r = t + 1;
        o[e][t] === o[n][t] && o[n][t] === o[e][r] && o[n][t] === o[n][r] && (i += 3);
    }
    const c = (e)=>{
        const t = [
            !0,
            !1,
            !0,
            !0,
            !0,
            !1,
            !0
        ], n = [
            !1,
            !1,
            !1,
            !1
        ], r = [
            ...t,
            ...n
        ], i = [
            ...n,
            ...t
        ];
        let o = 0;
        for(let t = 0; t < e.length; t++)Vp(e, r, t) && (o += 40), Vp(e, i, t) && (o += 40);
        return o;
    };
    let l = 0;
    for (const t of e.data)l += c(t);
    for (const e of t.data)l += c(e);
    let d = 0;
    e.rectRead(0, 1 / 0, (e, t)=>d += t ? 1 : 0);
    const u = d / (e.height * e.width) * 100, h = 10 * Math.floor(Math.abs(u - 50) / 5);
    return r + i + l + h;
}
function cg(e, t = "raw", n = {}) {
    const r = void 0 !== n.ecc ? n.ecc : "medium";
    !function(e) {
        if (!Zp.includes(e)) throw new Error(`Invalid error correction mode=${e}. Expected: ${Zp}`);
    }(r);
    const i = void 0 !== n.encoding ? n.encoding : function(e) {
        let t = "numeric";
        for (let n of e)if (!tg.alphabet.numeric.has(n) && (t = "alphanumeric", !tg.alphabet.alphanumerc.has(n))) return "byte";
        return t;
    }(e);
    !function(e) {
        if (!Jp.includes(e)) throw new Error(`Encoding: invalid mode=${e}. Expected: ${Jp}`);
        if ("kanji" === e || "eci" === e) throw new Error(`Encoding: ${e} is not supported (yet?).`);
    }(i), void 0 !== n.mask && function(e) {
        if (![
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7
        ].includes(e) || !ng[e]) throw new Error(`Invalid mask=${e}. Expected number [0..7]`);
    }(n.mask);
    let o, s = n.version, a = new Error("Unknown error");
    if (void 0 !== s) !function(e) {
        if (!Number.isSafeInteger(e) || e < 1 || e > 40) throw new Error(`Invalid version=${e}. Expected number [1..40]`);
    }(s), o = og(s, r, e, i);
    else for(let t = 1; t <= 40; t++)try {
        o = og(t, r, e, i), s = t;
        break;
    } catch (e) {
        a = e;
    }
    if (!s || !o) throw a;
    let c = function(e, t, n, r) {
        if (void 0 === r) {
            const i = function() {
                let e, t = 1 / 0;
                return {
                    add (n, r) {
                        n >= t || (e = r, t = n);
                    },
                    get: ()=>e,
                    score: ()=>t
                };
            }();
            for(let r = 0; r < ng.length; r++)i.add(ag(sg(e, t, n, r, !0)), r);
            r = i.get();
        }
        if (void 0 === r) throw new Error("Cannot find mask");
        return sg(e, t, n, r);
    }(s, r, o, n.mask);
    c.assertDrawn();
    const l = void 0 === n.border ? 2 : n.border;
    if (!Number.isSafeInteger(l)) throw new Error("Wrong border type=" + typeof l);
    if (c = c.border(l, !1), void 0 !== n.scale && (c = c.scale(n.scale)), "raw" === t) return c.data;
    if ("ascii" === t) return c.toASCII();
    if ("svg" === t) return c.toSVG();
    if ("gif" === t) return c.toGIF();
    if ("term" === t) return c.toTerm();
    throw new Error(`Unknown output: ${t}`);
}
const lg = {
    DESKTOP: "Desktop",
    MOBILE: "Mobile",
    META_MASK_MOBILE_APP: "MetaMask mobile app",
    SCAN_TO_CONNECT: "Scan to connect and sign with",
    CONNECT_WITH_EXTENSION: "Connect With MetaMask Extension",
    INSTALL_MODAL: {
        TRUSTED_BY_USERS: "Trusted by over 30 million users to buy, store, send and swap crypto securely",
        LEADING_CRYPTO_WALLET: "The leading crypto wallet & gateway to blockchain apps built on Ethereum Mainnet, Polygon, Optimism, and many other networks",
        CONTROL_DIGITAL_INTERACTIONS: "Puts you in control of your digital interactions by making power of cryptography more accessible",
        INSTALL_META_MASK_EXTENSION: "Install MetaMask Extension"
    },
    PENDING_MODAL: {
        OPEN_META_MASK_SELECT_CODE: "Please open the MetaMask wallet app and select the code on the screen OR disconnect",
        OPEN_META_MASK_CONTINUE: "Open the MetaMask app to continue with your session.",
        NUMBER_AFTER_OPEN_NOTICE: "If a number doesn't appear after opening MetaMask, please click disconnect and re-scan the QRCode.",
        DISCONNECT: "Disconnect"
    },
    SELECT_MODAL: {
        CRYPTO_TAKE_CONTROL_TEXT: "Take control of your crypto and explore the blockchain with the wallet trusted by over 30 million people worldwide"
    },
    META_MASK_MODAL: {
        ADDRESS_COPIED: "Address copied to clipboard!",
        DISCONNECT: "Disconnect",
        ACTIVE_NETWORK: "Active Network"
    }
};
class dg {
    constructor(e){
        var t;
        this.translations = lg, this.supportedLocales = [
            "es",
            "fr",
            "he",
            "it",
            "pt",
            "tr"
        ], this.baseUrl = null !== (t = null == e ? void 0 : e.baseUrl) && void 0 !== t ? t : "https://raw.githubusercontent.com/MetaMask/metamask-sdk/refs/heads/gh-pages/locales";
    }
    getBrowserLanguage() {
        if ((navigator.languages || [
            navigator.language
        ]).some((e)=>e.toLowerCase().startsWith("en"))) return "en";
        const e = navigator.language.toLowerCase().split("-")[0];
        return this.supportedLocales.includes(e) ? e : "en";
    }
    async init(e) {
        const t = this.getBrowserLanguage() || e.fallbackLng;
        await this.loadTranslations(t);
    }
    async loadTranslations(e) {
        const t = e.split("-")[0];
        if ("en" !== t && this.supportedLocales.includes(t)) try {
            const e = `${this.baseUrl}/${t}.json`, n = await fetch(e);
            if (!n.ok) throw new Error(`HTTP error! status: ${n.status}`);
            this.translations = await n.json();
        } catch (e) {
            console.warn(` Failed to load ${t} translations, falling back to English:`, e), this.translations = lg;
        }
        else this.translations = lg;
    }
    t(e) {
        return this.getNestedTranslation(e, this.translations) || e;
    }
    getNestedTranslation(e, t) {
        const n = e.split(".");
        let r = t;
        for (const e of n){
            if ("object" != typeof r) return "";
            r = r[e];
        }
        return "string" == typeof r ? r : "";
    }
}
var ug;
!function(e) {
    e.SDK_MODAL_VIEWED = "sdk_modal_viewed", e.SDK_MODAL_BUTTON_CLICKED = "sdk_modal_button_clicked", e.SDK_MODAL_TOGGLE_CHANGED = "sdk_modal_toggle_changed";
}(ug || (ug = {}));
const hg = class {
    constructor(e){
        ff(this, e), this.close = Gf(this, "close", 7), this.startDesktopOnboarding = Gf(this, "startDesktopOnboarding", 7), this.trackAnalytics = Gf(this, "trackAnalytics", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = !0, this.translationsLoaded = !1, this.onClose = this.onClose.bind(this), this.onStartDesktopOnboardingHandler = this.onStartDesktopOnboardingHandler.bind(this), this.setTab = this.setTab.bind(this), this.render = this.render.bind(this), this.setTab(this.preferDesktop ? 1 : 2), this.i18nInstance = new dg;
    }
    componentDidLoad() {
        this.trackAnalytics.emit({
            event: ug.SDK_MODAL_VIEWED,
            params: {
                extensionInstalled: !1,
                tab: 1 === this.tab ? "desktop" : "mobile"
            }
        });
    }
    async connectedCallback() {
        await this.i18nInstance.init({
            fallbackLng: "en"
        }), this.translationsLoaded = !0;
    }
    updatePreferDesktop(e) {
        e ? this.setTab(1) : this.setTab(2);
    }
    onClose(e = !1) {
        this.close.emit({
            shouldTerminate: e
        });
    }
    onStartDesktopOnboardingHandler() {
        this.trackAnalytics.emit({
            event: ug.SDK_MODAL_BUTTON_CLICKED,
            params: {
                button_type: "install_extension",
                tab: "desktop"
            }
        }), this.startDesktopOnboarding.emit();
    }
    setTab(e, t = !1) {
        t && this.trackAnalytics.emit({
            event: ug.SDK_MODAL_TOGGLE_CHANGED,
            params: {
                toggle: 1 === this.tab ? "desktop_to_mobile" : "mobile_to_desktop"
            }
        }), this.tab = e, this.isDefaultTab = !1;
    }
    render() {
        if (!this.translationsLoaded) return null;
        const e = (e)=>this.i18nInstance.t(e), t = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, n = cg(this.link, "svg", {
            ecc: "medium",
            scale: 2
        });
        return Uf(Np, {
            className: "install-model"
        }, Uf("div", {
            class: "backdrop",
            onClick: ()=>this.onClose(!0)
        }), Uf("div", {
            class: "modal"
        }, Uf("div", {
            class: "closeButtonContainer"
        }, Uf("div", {
            class: "right"
        }, Uf("span", {
            class: "closeButton",
            onClick: ()=>this.onClose(!0)
        }, Uf(Up, null)))), Uf("div", {
            class: "logoContainer"
        }, Uf(Hp, null)), Uf("div", null, Uf("div", {
            class: "tabcontainer"
        }, Uf("div", {
            class: "flexContainer"
        }, Uf("div", {
            onClick: ()=>this.setTab(1, !0),
            class: "tab flexItem " + (1 === t ? "tabactive" : "")
        }, e("DESKTOP")), Uf("div", {
            onClick: ()=>this.setTab(2, !0),
            class: "tab flexItem " + (2 === t ? "tabactive" : "")
        }, e("MOBILE")))), Uf("div", {
            style: {
                display: 1 === t ? "none" : "block"
            }
        }, Uf("div", {
            class: "flexContainer"
        }, Uf("div", {
            class: "flexItem",
            style: {
                textAlign: "center",
                marginTop: "4"
            }
        }, n && Uf("div", {
            id: "sdk-mm-qrcode",
            class: "center",
            innerHTML: n
        }), Uf("div", {
            class: "connectMobileText"
        }, e("SCAN_TO_CONNECT"), " ", Uf("br", null), Uf("span", {
            class: "blue"
        }, Uf("b", null, e("META_MASK_MOBILE_APP"))))))), Uf("div", {
            style: {
                display: 2 === t ? "none" : "block"
            }
        }, Uf("div", {
            class: "item"
        }, Uf(Lp, {
            Icon: $p,
            text: e("INSTALL_MODAL.TRUSTED_BY_USERS")
        })), Uf("div", {
            class: "item"
        }, Uf(Lp, {
            Icon: Dp,
            text: e("INSTALL_MODAL.LEADING_CRYPTO_WALLET")
        })), Uf("div", {
            class: "item"
        }, Uf(Lp, {
            Icon: Bp,
            text: e("INSTALL_MODAL.CONTROL_DIGITAL_INTERACTIONS")
        })), Uf("button", {
            class: "button",
            onClick: ()=>this.onStartDesktopOnboardingHandler()
        }, Uf(Kp, null), Uf("span", {
            class: "installExtensionText"
        }, e("INSTALL_MODAL.INSTALL_META_MASK_EXTENSION"))))), Uf(jp, {
            version: this.sdkVersion
        })));
    }
    get el() {
        return Vf(this);
    }
    static get watchers() {
        return {
            preferDesktop: [
                "updatePreferDesktop"
            ]
        };
    }
};
hg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
const fg = class {
    constructor(e){
        ff(this, e), this.close = Gf(this, "close", 7), this.disconnect = Gf(this, "disconnect", 7), this.updateOTPValue = Gf(this, "updateOTPValue", 7), this.displayOTP = void 0, this.sdkVersion = void 0, this.otpCode = void 0, this.translationsLoaded = !1, this.i18nInstance = new dg;
    }
    async connectedCallback() {
        await this.i18nInstance.init({
            fallbackLng: "en"
        }), this.translationsLoaded = !0;
    }
    onClose() {
        this.close.emit();
    }
    onDisconnect() {
        this.disconnect.emit();
    }
    onUpdateOTPValueHandler(e) {
        this.updateOTPValue.emit({
            otpValue: e
        });
    }
    disconnectedCallback() {
        this.onClose();
    }
    render() {
        var e;
        if (!this.translationsLoaded) return null;
        const t = null === (e = this.displayOTP) || void 0 === e || e, n = this.sdkVersion, r = (e)=>this.i18nInstance.t(e);
        return Uf(Np, {
            className: "pending-modal"
        }, Uf("div", {
            class: "backdrop",
            onClick: ()=>this.onClose()
        }), Uf("div", {
            class: "modal"
        }, Uf("div", {
            class: "closeButtonContainer"
        }, Uf("div", {
            class: "right"
        }, Uf("span", {
            class: "closeButton",
            onClick: ()=>this.onClose()
        }, Uf(Up, null)))), Uf("div", {
            class: "logoContainer"
        }, Uf(Hp, null)), Uf("div", null, Uf("div", {
            class: "flexContainer",
            style: {
                flexDirection: "column",
                color: "black"
            }
        }, Uf("div", {
            class: "flexItem",
            style: {
                textAlign: "center",
                marginTop: "30px",
                marginBottom: "30px",
                fontSize: "16px"
            }
        }, r(t ? "PENDING_MODAL.OPEN_META_MASK_SELECT_CODE" : "PENDING_MODAL.OPEN_META_MASK_CONTINUE")), Uf("div", {
            id: "sdk-mm-otp-value",
            style: {
                padding: "10px",
                fontSize: "32px",
                display: this.otpCode ? "block" : "none"
            }
        }, this.otpCode), t && Uf("div", {
            class: "notice"
        }, "* ", r("PENDING_MODAL.NUMBER_AFTER_OPEN_NOTICE"))), Uf("div", {
            style: {
                marginTop: "20px"
            }
        }, Uf("button", {
            class: "button blue",
            style: {
                marginTop: "5px",
                color: "#0376C9",
                borderColor: "#0376C9",
                borderWidth: "1px",
                borderStyle: "solid",
                backgroundColor: "white"
            },
            onClick: ()=>this.onDisconnect()
        }, r("PENDING_MODAL.DISCONNECT")))), Uf(jp, {
            version: n
        })));
    }
    get el() {
        return Vf(this);
    }
};
fg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
const pg = ()=>Uf("svg", {
        width: "21",
        height: "15",
        viewBox: "0 0 21 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, Uf("path", {
        d: "M14.1364 14.9851C13.5909 14.9851 13.2273 14.5851 13.2273 13.9851C13.2273 13.3851 13.5909 12.9851 14.1364 12.9851C16.6818 12.9851 18.6818 10.7851 18.6818 7.98508C18.6818 5.18508 16.6818 2.98508 14.1364 2.98508C11.5909 2.98508 9.59091 5.18508 9.59091 7.98508C9.59091 8.58508 9.22727 8.98508 8.68182 8.98508C8.13636 8.98508 7.77273 8.58508 7.77273 7.98508C7.77273 4.08508 10.5909 0.985077 14.1364 0.985077C17.6818 0.985077 20.5 4.08508 20.5 7.98508C20.5 11.8851 17.6818 14.9851 14.1364 14.9851ZM6.68182 14.7851C3.22727 14.7851 0.5 11.6851 0.5 7.98508C0.5 4.28508 3.22727 1.18508 6.68182 1.18508C7.22727 1.18508 7.59091 1.58508 7.59091 2.18508C7.59091 2.78508 7.22727 3.18508 6.68182 3.18508C4.22727 3.18508 2.31818 5.38508 2.31818 7.98508C2.31818 10.5851 4.22727 12.7851 6.68182 12.7851C9.13636 12.7851 11.0455 10.6851 11.0455 7.98508C11.0455 7.38508 11.4091 6.98508 11.9545 6.98508C12.5 6.98508 12.8636 7.38508 12.8636 7.98508C12.7727 11.6851 10.0455 14.7851 6.68182 14.7851Z",
        fill: "white"
    })), gg = ()=>Uf("svg", {
        width: "400",
        height: "300",
        viewBox: "0 0 400 300",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, Uf("rect", {
        width: "400",
        height: "300",
        fill: "white"
    }), Uf("path", {
        d: "M300.116 242.46L250.485 227.681L213.057 250.055L186.944 250.045L149.493 227.681L99.8843 242.46L84.7939 191.518L99.8843 134.979L84.7939 87.1777L99.8843 27.9336L177.402 74.2466H222.598L300.116 27.9336L315.206 87.1777L300.116 134.979L315.206 191.518L300.116 242.46Z",
        fill: "#FF5C16"
    }), Uf("path", {
        d: "M99.8955 27.9336L177.414 74.2792L174.331 106.085L99.8955 27.9336Z",
        fill: "#FF5C16"
    }), Uf("path", {
        d: "M149.505 191.539L183.612 217.521L149.505 227.681V191.539Z",
        fill: "#FF5C16"
    }), Uf("path", {
        d: "M180.886 148.585L174.33 106.107L132.369 134.991L132.348 134.98V135.001L132.477 164.732L149.493 148.585H149.504H180.886Z",
        fill: "#FF5C16"
    }), Uf("path", {
        d: "M300.116 27.9336L222.598 74.2792L225.67 106.085L300.116 27.9336Z",
        fill: "#FF5C16"
    }), Uf("path", {
        d: "M250.508 191.539L216.4 217.521L250.508 227.681V191.539Z",
        fill: "#FF5C16"
    }), Uf("path", {
        d: "M267.652 135.001H267.663H267.652V134.98L267.641 134.991L225.68 106.107L219.125 148.585H250.507L267.533 164.732L267.652 135.001Z",
        fill: "#FF5C16"
    }), Uf("path", {
        d: "M149.493 227.681L99.8843 242.46L84.7939 191.54H149.493V227.681Z",
        fill: "#E34807"
    }), Uf("path", {
        d: "M180.875 148.574L190.351 209.98L177.219 175.838L132.456 164.732L149.483 148.574H180.864H180.875Z",
        fill: "#E34807"
    }), Uf("path", {
        d: "M250.507 227.681L300.116 242.46L315.206 191.54H250.507V227.681Z",
        fill: "#E34807"
    }), Uf("path", {
        d: "M219.126 148.574L209.649 209.98L222.782 175.838L267.545 164.732L250.507 148.574H219.126Z",
        fill: "#E34807"
    }), Uf("path", {
        d: "M84.7939 191.517L99.8843 134.979H132.337L132.456 164.721L177.219 175.826L190.351 209.969L183.601 217.488L149.493 191.506H84.7939V191.517Z",
        fill: "#FF8D5D"
    }), Uf("path", {
        d: "M315.206 191.517L300.116 134.979H267.664L267.545 164.721L222.782 175.826L209.649 209.969L216.4 217.488L250.507 191.506H315.206V191.517Z",
        fill: "#FF8D5D"
    }), Uf("path", {
        d: "M222.598 74.2466H200H177.402L174.33 106.053L190.351 209.936H209.649L225.681 106.053L222.598 74.2466Z",
        fill: "#FF8D5D"
    }), Uf("path", {
        d: "M99.8843 27.9336L84.7939 87.1777L99.8843 134.979H132.337L174.319 106.085L99.8843 27.9336Z",
        fill: "#661800"
    }), Uf("path", {
        d: "M171.496 160.906H156.795L148.79 168.752L177.229 175.804L171.496 160.896V160.906Z",
        fill: "#661800"
    }), Uf("path", {
        d: "M300.116 27.9336L315.206 87.1777L300.116 134.979H267.663L225.681 106.085L300.116 27.9336Z",
        fill: "#661800"
    }), Uf("path", {
        d: "M228.525 160.906H243.248L251.253 168.763L222.781 175.826L228.525 160.896V160.906Z",
        fill: "#661800"
    }), Uf("path", {
        d: "M213.046 229.789L216.399 217.51L209.649 209.991H190.34L183.59 217.51L186.943 229.789",
        fill: "#661800"
    }), Uf("path", {
        d: "M213.047 229.789V250.066H186.944V229.789H213.047Z",
        fill: "#C0C4CD"
    }), Uf("path", {
        d: "M149.504 227.66L186.965 250.056V229.779L183.611 217.5L149.504 227.66Z",
        fill: "#E7EBF6"
    }), Uf("path", {
        d: "M250.506 227.66L213.045 250.056V229.779L216.398 217.5L250.506 227.66Z",
        fill: "#E7EBF6"
    })), mg = class {
    constructor(e){
        ff(this, e), this.close = Gf(this, "close", 7), this.connectWithExtension = Gf(this, "connectWithExtension", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = !0, this.translationsLoaded = !1, this.i18nInstance = new dg, this.setTab(this.preferDesktop ? 1 : 2);
    }
    async connectedCallback() {
        await this.i18nInstance.init({
            fallbackLng: "en"
        }), this.translationsLoaded = !0;
    }
    onClose(e = !1) {
        this.close.emit({
            shouldTerminate: e
        });
    }
    connectWithExtensionHandler() {
        this.connectWithExtension.emit();
    }
    setTab(e) {
        this.tab = e, this.isDefaultTab = !1;
    }
    disconnectedCallback() {
        this.onClose();
    }
    updatePreferDesktop(e) {
        e ? this.setTab(1) : this.setTab(2);
    }
    render() {
        if (!this.translationsLoaded) return null;
        const e = (e)=>this.i18nInstance.t(e), t = this.sdkVersion, n = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, r = cg(this.link, "svg", {
            ecc: "medium",
            scale: 2
        });
        return Uf(Np, {
            className: "select-modal"
        }, Uf("div", {
            class: "backdrop",
            onClick: ()=>this.onClose(!0)
        }), Uf("div", {
            class: "modal"
        }, Uf("div", {
            class: "closeButtonContainer"
        }, Uf("div", {
            class: "right"
        }, Uf("span", {
            class: "closeButton",
            onClick: ()=>this.onClose(!0)
        }, Uf(Up, null)))), Uf("div", {
            class: "logoContainer"
        }, Uf(Hp, null)), Uf("div", null, Uf("div", {
            class: "tabcontainer"
        }, Uf("div", {
            class: "flexContainer"
        }, Uf("div", {
            onClick: ()=>this.setTab(1),
            class: "tab flexItem " + (1 === n ? "tabactive" : "")
        }, e("DESKTOP")), Uf("div", {
            onClick: ()=>this.setTab(2),
            class: "tab flexItem " + (2 === n ? "tabactive" : "")
        }, e("MOBILE")))), Uf("div", {
            style: {
                display: 1 === n ? "none" : "block"
            }
        }, Uf("div", {
            class: "flexContainer"
        }, Uf("div", {
            class: "flexItem",
            style: {
                textAlign: "center",
                marginTop: "4"
            }
        }, Uf("div", {
            class: "center",
            id: "sdk-mm-qrcode",
            innerHTML: r
        }), Uf("div", {
            class: "connectMobileText"
        }, e("SCAN_TO_CONNECT"), Uf("br", null), Uf("span", {
            class: "blue"
        }, Uf("b", null, e("META_MASK_MOBILE_APP"))))))), Uf("div", {
            style: {
                display: 2 === n ? "none" : "block"
            }
        }, Uf("div", {
            style: {
                display: "flex",
                justifyContent: "center",
                height: "300",
                marginTop: "-20"
            }
        }, Uf(gg, null)), Uf("div", {
            class: "extensionLabel"
        }, e("SELECT_MODAL.CRYPTO_TAKE_CONTROL_TEXT")), Uf("button", {
            class: "button",
            onClick: ()=>this.connectWithExtensionHandler()
        }, Uf(pg, null), Uf("span", {
            class: "installExtensionText"
        }, e("CONNECT_WITH_EXTENSION"))))), Uf(jp, {
            version: t
        })));
    }
    get el() {
        return Vf(this);
    }
    static get watchers() {
        return {
            preferDesktop: [
                "updatePreferDesktop"
            ]
        };
    }
};
mg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var yg = Object.freeze({
    __proto__: null,
    mm_install_modal: hg,
    mm_pending_modal: fg,
    mm_select_modal: mg
});
;
 //# sourceMappingURL=metamask-sdk.js.map
}),
];

//# sourceMappingURL=node_modules_%40metamask_sdk_dist_browser_es_metamask-sdk_81d8f133.js.map